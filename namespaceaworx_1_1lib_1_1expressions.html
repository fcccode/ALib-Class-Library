<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALib: aworx::lib::expressions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALib
   &#160;<span id="projectnumber">V. 1805 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html">expressions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Nested namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">aworx::lib::expressions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Programmer's Manual</h2>
<div class="textblock"><hr/>
<p> This is namespace documentation starts with a comprehensive programmer's manual.<br />
 <b>Reference documentation</b> is found below:</p>
<ul>
<li><a href="#namespaces">Nested Namespaces</a></li>
<li><a href="#nested-classes">Classes</a></li>
<li><a href="#typedef-members">Typedefs</a> and</li>
<li><a href="#func-members">Functions</a></li>
</ul>
<h1>ALib Expressions - Programmer's Manual</h1>
<h2>Contents</h2>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_intro">1. Introduction</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_intro_goals">1.1 Goals</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_intro_procon">1.2 Pros and Cons: When To Use ALib Expressions</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_calculator">2. Tutorial: Hello Calculator</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prerequisites">3. Prerequisites</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_boxing">3.1 ALib Boxing</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">3.2 Type Definitions With "Sample Boxes"</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_virtual_types">3.3 Use Of Virtual Types Rather Than Templates</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_bauhaus">3.4 Bauhaus Code Style</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff">4. Tutorial: Implementing A File Filter</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_skel">4.1 Skeleton Code For Filtering Files</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_generic">4.2 Adding Generic Ingredients Needed For Expression Evaluation</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_checkresult">4.3 Checking An Expression's Result Type</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_scope">4.4 Exposing The Directory Entry To ALib Expressions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_scope">4.4 Exposing The Directory Entry To ALib Expressions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_cp">4.5 Implementing A Compiler Plug-In</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_cpcc">5. Compiler Plug-Ins And Class Calculus</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_cpcc_process">5.1 The Compilation Process</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_cpcc_bipl">5.2 The Built-In Compiler Plug-Ins</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_cpcc_class">5.3 Class CompilerPlugin</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_cpcc_calculus">5.4 Class Calculus</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ffext">6. Tutorial: Extending The File Filter Sample</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ffext_calc">6.1 Replacing CompilerPlugin By Calculus</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ffext_ident">6.2 Adding More Identifiers</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ffext_func">6.3 Adding Functions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ffext_ops">6.4 Adding Operators</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ffext_autocasts">6.5 Implementing Auto-Casts</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin">7. Built-In Expression Functionality</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin_completeness">7.1 Completeness Of Built-In Functionality</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin_types">7.2 Types</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin_arithmetics">7.3 Arithmetics</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin_math">7.4 Math Functions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin_string">7.5 String Expressions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin_datetime">7.6 Date And Time Expressions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin_ternary">7.7 Conditional Operator</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_builtin_autocast">7.8 Auto Casts</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_scopes">8. Scopes</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_scopes_stack">8.1 Provision Of The Evaluation Stack</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_scopes_allocations">8.2 Scope Allocations</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_scopes_ctscope">8.3 Compile-Time Scopes</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_scopes_custom_ctscope">8.4 Custom Compile-Time Scopes</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_scopes_ctresources">8.5 Using Compile-Time Resources At Evaluation Time</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_scopes_ctrressample">8.6 Sample For Using Compile-Time Resources At Evaluation Time</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators">9. Operators</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_default">9.1 Built-In Operators</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_custom">9.2 Tutorial: Adding A Custom Operator</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_verbal">9.3 Verbal Operator Aliases</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_aliases">9.4 Type-Specific Operator Aliases</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_subscript">9.5 Array Subscript Operator</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_nested">9.6 Unary Operator For Nested Expressions</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested">10. Nested Expressions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested_named">10.1 Named Expressions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested_operator">10.2 Nested Expressions Identified At Compile-Time</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested_function">10.3 Nested Expressions Identified At Evaluation-Time</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested_throw">10.4 Assuring The Existence Of Nested Expressions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested_config">10.5 Automated Named Expressions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested_summary">10.6 Summary and Final Notes On Nested Expressions</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details">11. Detail Topics</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_types">11.1 Types</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_literals">11.2 Literals</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_identifiers">11.3 Identifiers/Functions</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_localization">11.4 Localization</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_optimizations">11.5 Optimizations</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_concurrency">11.6 Shared Resources And Concurrent Use</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_concurrency">11.7 Exception Handling</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_appendix">A. Appendix</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_appendix_vm">A.1 The Built-In Virtual Machine</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_appendix_architecture">A.2 Notes On The Architecture Of The Library</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_appendix_boostspirit">A.3 Using Built-In Alternative Parser Based On boost::spirit</a></p>
<p><a class="anchor" id="alib_expressions_intro"></a></p><h1>1. Introduction</h1>
<p><a class="anchor" id="alib_expressions_intro_goals"></a></p><h2>1.1 Goals</h2>
<p>The goal of this <a class="el" href="alib_man_intro.html">ALib Module</a> is to provide a C++ library that helps to integrate functionality in custom software to allow end users to write expression strings, which are understood and evaluated at <em>runtime</em> by that software.</p>
<p>Usually, to achieve this, it is needed to</p><ul>
<li>Think about the expression <em>grammar</em> and specify such.</li>
<li>Use programming tools like <a href="https://savannah.gnu.org/projects/bison/">bison</a>, <a href="http://www.boost.org/doc/libs/1_66_0/libs/spirit/doc/html/index.html">boost::spirit</a> or alike (<a href="https://en.wikipedia.org/wiki/Comparison_of_parser_generators">Wikipedia: Comparison of parser generators</a>).</li>
<li>Write custom code that evaluates parsed expressions.</li>
</ul>
<p>This is of-course a lot of work and a month of programming time quickly is consumed, unless a programmer has done this several times before.</p>
<p>Lets quickly consider two samples.</p><ol type="1">
<li>An application that processes files and folders. The end-user should be allowed to write "filter" expressions like: <pre class="fragment">     ( date &gt; today - days(7) )  &amp; (name = "*.jpg")
     isFolder &amp; notEmpty
</pre></li>
<li>An application that manages a table of employee data. The end-user should be allowed to write expressions like: <pre class="fragment">     (StartDate + years(10) &lt; today   &amp; (NumberOfSalaryRaises = 0)
     StartDate( find( "John", "Miller", "Accounting" ) )
     BirthDate( find( 832735 ) )
</pre></li>
</ol>
<p>While on the first glance, these are very different types of expressions, they still have a lot in common:</p>
<ul>
<li>They use <em>functions</em> and <em>identifiers</em> like <code>date</code>, <code>name</code> or <code>find()</code> </li>
<li>They do <em>calculations</em> like <code>today - days(7)</code> or <code>10 * 365</code>.</li>
<li>They use <em>comparisons</em> like <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code> and <code>=</code></li>
<li>They use <em>boolean</em> operators like <code>&amp;</code> or <code>|</code></li>
<li>They use <em>brackets</em> to overrule operator precedences or just as a redundant helper for better readability</li>
</ul>
<p>The areas where the expressions of the two samples differ is:</p><ul>
<li>They offer different named functions and identifiers.</li>
<li>Such functions and identifiers may return <b>custom types</b>. Those types may be intermediate results as well as results of the expression.</li>
<li>The operators and functions used are eventually defined (<em>"overloaded"</em>) for custom types.</li>
</ul>
<p>With this said, we can much better explain what module <b>ALib Expressions</b> offers:</p>
<dl class="section user"><dt></dt><dd><em><b>"ALib Expressions provide an expression string parser, formatter and evaluator using customizable operators, identifiers and functions which support to process or return built-in and custom types."</b></em></dd></dl>
<p>You will see later in this documentation, that the amount of coding needed to implement functionality like given in the samples above is <b>surprisingly</b> low.</p>
<p><a class="anchor" id="alib_expressions_intro_procon"></a></p><h2>1.2 Pros and Cons: When To Use ALib Expressions</h2>
<p>It is common to using code libraries, that a certain trade-off between flexibility and ease of use has to be made. With the description above of what this library provides the important "limiting" term is "fixed grammar".</p>
<p>To give you some help in deciding whether module <b>ALib Expressions</b> suits your needs, the "pros" and "cons" should be listed in bullets. We start with the cons:</p>
<p><b>Reasons to NOT use ALib Expressions Library</b></p><ul>
<li>The syntax and grammar rules of expressions is rather fixed along the lines of C++ expressions.<br />
 Rather here means: There are some important tweaks and options available, and even custom operators can be defined and the precedence of existing and custom operators may be altered, however no complete "syntax paradigms" can be defined without touching the library code itself.</li>
</ul>
<ul>
<li><b>ALib Expressions</b> builds on other core modules of <b>ALib</b>.<br />
 Why is this a disadvantage? Well, if you are used to <b>ALib</b> it is absolutely not, but you have to be aware that with the use of this <a class="el" href="alib_man_intro.html">ALib Module</a>, some other modules need to be compiled into your code. Note that this is relevant only in respect to project setup effort, compile time and resulting code size. Your own custom code will not be 'cluttered' or otherwise heavily impacted by the internal use of these modules.<br />
 Especially important modules to name are <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a> and <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">ALib Strings</a>. When using this module, you need to learn about at least the basics of these two other modules.</li>
</ul>
<p>The pros should be given as a feature list:</p>
<p><b>Features of ALib Expressions</b></p><ul>
<li><b>Free</b> software, boost open source license.</li>
</ul>
<ul>
<li>Well tested, very fast.</li>
</ul>
<ul>
<li>Pure handwritten C++ 11 code, <b>no generation tools or 3rd party libraries</b> needed for the built.</li>
</ul>
<ul>
<li><b>Complete expression syntax</b> along the lines of C++ expressions<br />
 All operators implemented, including:<ul>
<li>Ternary, conditional <code>Q ? T : F</code></li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1ElvisOperator.html">Elvis operator</a> <code>A ?: B</code></li>
<li>Array subscript operator <code>[]</code> to access array elements.<br />
 This may also be used as <b>hash-map</b> access operator to form expressions like: <pre class="fragment">   Preferences["DATA_FOLDER"] + "/database.dat"
</pre> </li>
</ul>
</li>
<li>All functions and operators can be <b>"overloaded"</b> to support custom types without interfering existing functions and operators.</li>
<li><b>Verbal operators</b> like "not", "and", "equals" or "greater" can be defined.</li>
<li>Optional <b>localization</b> of operator names, identifiers, functions, the number format, etc.</li>
</ul>
<ul>
<li><p class="startli">More than <b>130 built-in functions</b> and <b>180 (overloaded) operators</b>!<br />
 Areas that are covered:</p><ul>
<li>Boolean, integer and floating point arithmetics.</li>
<li>Math functions.</li>
<li>String manipulation, including <b>wildcard</b> and <b>regex matching</b>.</li>
<li>Date and time functions.</li>
</ul>
<p class="startli">As a sample, the following expression: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a1560a557676f73ac8ce95f0f192a6957">Format</a>(<span class="stringliteral">&quot;Result: {}&quot;</span>, GetDayOfWeek( today + Years(42) ) * <span class="keywordtype">int</span>( remainder( PI * exp( sin( E ) ), 1.2345) * random ) % 7 ) != <span class="stringliteral">&quot;&quot;</span></div></div><!-- fragment --><p> compiles with (optional) built-in functionality. (Compile time less than 40 &micro;s, evaluation time less 15 &micro;s, on a year 2018 developer machine.)</p>
</li>
<li>All built-in logic is <b>optional/configurable</b>.</li>
</ul>
<ul>
<li>Support for <b>n-ary and variadic custom functions</b>, including "ellipsis" parameter definitions, like in <code>Format(formatString, ...)</code>.<br />
</li>
<li>Optional definition of <b>custom operators</b>, including custom parsing precedence.</li>
</ul>
<ul>
<li>Support of <b>nested expressions</b>, which is support of "named" expressions that are recursively referred to from within other (named or anonymous) expressions.<br />
 Supports mechanics to externally define nested expressions using command line parameters, environment variables or within arbitrary (custom) configuration resources, e.g INI-files.</li>
</ul>
<ul>
<li><b>Easy use</b>, integration and customization of the library. (This is proved in the tutorial sections below).</li>
</ul>
<ul>
<li><b>Compile-time type safety</b><br />
 <dl class="section note"><dt>Note</dt><dd>What does this mean and why is this important? Because almost all malformed expression input (by end-users) is detected at "compile time" of the expression. This way, a software can tell a user that an expression is malformed (almost always) already in the moment that a user announces an expression to the software. With that, a software can in turn reject the expression before taking any action to start working with it.<br />
 The other way round: Once an expression got compiled, its evaluation is deemed to succeed.</dd></dl>
</li>
</ul>
<ul>
<li>"Seamless" support of <b>arbitrary custom types</b> within expressions. Types digested by expressions can be any C++ type (class).<br />
 <dl class="section note"><dt>Note</dt><dd>Custom types are "introduced" to module <b>ALib Expressions</b> just by having custom identifiers, functions and/or operators return them!<br />
 To then further "support" these types, operators and functions can to be added (or overloaded) to work with the types. Of-course, the result of expressions can be of such arbitrary types as well.<br />
 </dd></dl>
</li>
<li>Support of <b>automatic type cast</b> of built-in types as well as custom types.<br />
 (This reduces the amount of needed "permutations" of overloaded operators and the types they support, and thus the time to customize).</li>
</ul>
<ul>
<li><b>Internationalization</b> of number formats in expression literals, including thousands separator character.</li>
</ul>
<ul>
<li>All identifier and function names are <b>"resourced"</b> and can be changed without touching the library code.</li>
</ul>
<ul>
<li><b>Decimal, hexadecimal, binary</b> and <b>octal</b> integer number literals. Scientific and normal floating point parsing and formatting.</li>
</ul>
<ul>
<li>Largely configurable <b>normalization</b> of user-defined expression strings. Configuration offers a choice of <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3">more than 30 options</a>, including:<ul>
<li>Removal of redundant brackets and whitespaces (not optional, always performed)</li>
<li>Addition of redundant brackets that make expression more readable (several sub-options).</li>
<li>Addition of whitespaces for better readability (several sub-options)</li>
<li>Replacement of 'alias' operators (e.g. <code>&amp;</code> on boolean converts to <code>&amp;&amp;</code> or assign <code>=</code> converts to <code>==</code>).</li>
<li>Replacement of abbreviations of identifiers and functions to their full name.</li>
</ul>
</li>
</ul>
<ul>
<li>Configurable compiler options, some most obvious ones with simple flags. For example to allow comparison operator <code>'=='</code> to be aliased by assign operator <code>'='</code>, which is more intuitive to end-users.</li>
</ul>
<ul>
<li><p class="startli">Very <b>fast expression evaluation</b><br />
</p><ul>
<li>Expressions get <b>compiled</b> to a "program" which are executed by an extremely lightweight built-in <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1VirtualMachine.html">virtual machine</a>. This avoids the otherwise needed evaluation based on an "abstract syntax tree" with expensive recursive invocations of virtual functions.</li>
</ul>
<ul>
<li><p class="startli">The expression compiler performs various optimizations. For example, expression </p><pre class="fragment">   2 * 3 + 4
</pre><p class="startli">results in one single program command that provides the constant result <code>10</code>.<br />
 Compile-time optimization is also supported with custom identifiers, functions and operators.</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>Optional <b>decompilation</b> of expression programs. This can be used for generating a normalized expression string of the <em>optimized</em> expression. (Just needed if you are mean enough to tell your user about the redundancies in his/her given expressions :-)</li>
</ul>
<ul>
<li>Throws <b>detailed exceptions</b> (exceptions with additional information collected along the stacktrace) that contain information that can be displayed to the user to help finding errors in given expressions.<br />
 All exceptions and other strings are resourced and can be changed and/or translated to target languages.</li>
</ul>
<ul>
<li>Generation of formatted, commented <b>listings of the compiled expression programs</b>.<br />
 (Available with debug-compilations only. Offered just for curious users of the library that are eager to view the simplistic beauty of a stack machine.)</li>
</ul>
<ul>
<li><p class="startli">Provision of an <b>alternative parser</b> that builds on <a href="http://www.boost.org/doc/libs/1_66_0/libs/spirit/doc/html/index.html">boost::spirit</a>.<br />
 This parser and the compilation of its code is switched off by default. In case that the library should be extended to support custom syntax paradigms, there are two options:</p><ol type="1">
<li>Customize the built-in, "hand written" parser.</li>
<li>Enable the compilation and integration of the provided alternative parser based on <em>boost::spirit</em> and do you customizations based on this parser - which by definition is meant to be customized. (Good luck boys and girls!)</li>
</ol>
<p class="startli">For more information on this alternative parser, see chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_appendix_boostspirit">A.3 Using Built-In Alternative Parser Based On boost::spirit</a>.</p>
</li>
</ul>
<ul>
<li><b>Extensive documentation</b>. (Please excuse verbosity, writing docs inspires us to do better code.)</li>
</ul>
<p><a class="anchor" id="alib_expressions_calculator"></a></p><h1>2. Tutorial: Hello Calculator</h1>
<p>This documentation switches between in-depth informational sections and tutorial-like sample sections. Let's start with a quick tutorial section!</p>
<p>What is "hello world" for each new programming language is a "simple calculator" for expression compilers. Here is the code for implementing one using module <b>ALib Expressions</b>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="alib_8hpp.html">alib/alib.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;alib/expressions/compiler.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;alib/expressions/scope.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="std__string_8hpp.html">alib/compatibility/std_string.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="simpletext_8hpp.html">alib/strings/format/simpletext.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceaworx.html">aworx</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <a class="code" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">character</a> *argv[] )</div><div class="line">{</div><div class="line">    <span class="comment">// 1. Create the expression compiler</span></div><div class="line">    <span class="comment">//    Add all built-in stuff: number arithmetics, strings, time/date, etc.</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> compiler;</div><div class="line">    compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"></div><div class="line">    <span class="comment">// 2. Compile. Catch exceptions please, never trust your user</span></div><div class="line">    <a class="code" href="namespaceaworx.html#a291705379bcfc84d47ab5978e89326ab">SPExpression</a> expression;</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        expression= compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a48950a23ca943cebf76688bc80c0e40b">Compile</a>( argv[1] );</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (<a class="code" href="classaworx_1_1lib_1_1lang_1_1Exception.html">Exception</a>&amp; e)</div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;An exception occurred compiling the expression. Details follow:&quot;</span> &lt;&lt; endl</div><div class="line">             &lt;&lt; <a class="code" href="namespaceaworx.html#a1248f05714a4c6606a991a5a27992cf9">SimpleText</a>().AddException(e).Text                                 &lt;&lt; endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> e.<a class="code" href="classaworx_1_1lib_1_1lang_1_1Exception.html#af73059d3c0862fb540cc22808afe3a46">Code</a>().<a class="code" href="structaworx_1_1lib_1_1lang_1_1Enum.html#ae3ed6856fae3288e7d259bc756ef1382">Value</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 2. We need an evaluation &quot;scope&quot;</span></div><div class="line">    <span class="comment">//    (later we will use a custom type here, that allows custom identifiers, functions and</span></div><div class="line">    <span class="comment">//    operators to access application data)</span></div><div class="line">    <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">lib::expressions::Scope</a> scope(compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a2a8ce7737f852a400bd8c2a366a4d74b">CfgFormatter</a>);</div><div class="line"></div><div class="line">    <span class="comment">// 4. Evaluate the expression</span></div><div class="line">    <span class="comment">//    (We must not fear exceptions here, as the compiler did all type checking, and resolved</span></div><div class="line">    <span class="comment">//    everything to a duly checked internal &quot;program&quot; running on a virtual machine.)</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> result= expression-&gt;Evaluate( scope );</div><div class="line"></div><div class="line">    <span class="comment">// 5. Write result</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Input:      &quot;</span> &lt;&lt; expression-&gt;GetOriginalString()   &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Normalized: &quot;</span> &lt;&lt; expression-&gt;GetNormalizedString() &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Result:     &quot;</span> &lt;&lt; result                            &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Compile the program and run it passing some simple sample expressions (or be lazy and just read on), we give it some tries:</p>
<div class="fragment"><div class="line">Input:      1 + 2 * 3</div><div class="line">Normalized: 1 + (2 * 3)</div><div class="line">Result:     7</div></div><!-- fragment --><p> Fine, it calculates! Notable on this first simple sample are the brackets inserted in the what we call "normalized" expression string. Compare this to the next sample:</p>
<div class="fragment"><div class="line">Input:      1 * 2 + 3</div><div class="line">Normalized: 1 * 2 + 3</div><div class="line">Result:     5</div></div><!-- fragment --><p> Why are the brackets gone here, while in the first case they had been redundant anyhow? The answer is, that human beings could easily misunderstand the first version, so module <b>ALib Expressions</b> feels free to help making an expression more readable.<br />
 You think this is childish? A six-year old school kid, knows these math rules? Ok, then what do you think about this expression: </p><pre class="fragment">       true &amp;&amp; false == true &lt; false
</pre><p>Either you are a crack or you need to consult a C++ reference manual and check for the operator precedence. Here is what our calculator says:</p>
<div class="fragment"><div class="line">Input:      <span class="keyword">true</span> &amp;&amp; <span class="keyword">false</span> == <span class="keyword">true</span> &lt; <span class="keyword">false</span></div><div class="line">Normalized: <span class="keyword">true</span> &amp;&amp; (<span class="keyword">false</span> == (<span class="keyword">true</span> &lt; <span class="keyword">false</span>))</div><div class="line">Result:     <span class="keyword">true</span></div></div><!-- fragment --><p> The insertion of redundant brackets is one of more than 30 <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3">normalization options</a> that are switchable with enumeration flags.<br />
 The recent sample has more to show:</p><ul>
<li>Boolean arithmetics and operators</li>
<li>Built-in <em>identifiers</em>, namely <code>true</code> and <code>false</code>.</li>
</ul>
<p>Note, that we use the term <em>"identifier"</em> for parameterless expression functions. By default, the parameter brackets can be omitted with parameterless functions.</p>
<p>Functions with parameters are for example found in the area of maths:</p>
<div class="fragment"><div class="line">Input:      asin(1.0) * 2.0</div><div class="line">Normalized: asin( 1.0 ) * 2.0</div><div class="line">Result:     3.141592653589793</div></div><!-- fragment --><p> or with string processing:</p>
<div class="fragment"><div class="line">Input:      tolo(<span class="stringliteral">&quot;Hello &quot;</span>) + toup(<span class="stringliteral">&quot;World&quot;</span>)</div><div class="line">Normalized: ToLower( &quot;Hello &quot; ) + ToUpper( &quot;World&quot; )</div><div class="line">Result:     hello WORLD</div></div><!-- fragment --> <div class="fragment"><div class="line">Input:      <a class="code" href="namespaceaworx.html#a1560a557676f73ac8ce95f0f192a6957">Format</a>( <span class="stringliteral">&quot;Today is: {:yyyy/MM/dd}&quot;</span>, today )</div><div class="line">Normalized: <a class="code" href="namespaceaworx.html#a1560a557676f73ac8ce95f0f192a6957">Format</a>( <span class="stringliteral">&quot;Today is: {:yyyy/MM/dd}&quot;</span>, Today )</div><div class="line">Result:     Today is: 2018/05/12</div></div><!-- fragment --><p>As it can be seen, a whole lot of identifiers, functions and operators are already available with the simple calculator example. All of these built-in definitions can be switched off. In fact, the built-in stuff is implemented with the very same interface that custom extensions would be. The only difference between built-in expression identifiers, functions and operators to custom ones is that the built-in ones are distributed with the library.</p>
<p>To get an overview of the built-in functionality, you might have a quick look at the tables found in the following class documentations:</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html">plugins::Arithmetics</a></li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">plugins::Strings</a></li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Math.html">plugins::Math</a></li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1DateAndTime.html">plugins::DateAndTime</a></li>
</ul>
<p><a class="anchor" id="alib_expressions_prerequisites"></a></p><h1>3. Prerequisites</h1>
<p>To fully understand this tutorial, library source code and finally as a prerequisite to implementing your custom expression compiler, a certain level of understanding of some underlying library and principles is helpful.</p>
<p><a class="anchor" id="alib_expressions_prereq_boxing"></a></p><h2>3.1 ALib Boxing</h2>
<p>As mentioned in the introduction, module <b>ALib Expressions</b> make intensive use of underlying module <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a>.</p>
<p>For the time being, lets quickly summarize what module <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a> provides:</p><ul>
<li>Encapsulates any C++ value or pointer in an object of type <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>.</li>
<li>A box is very lightweight (3 x 8 bytes on a 64-bit system) and contains a copy of the value (if possible) or a pointer to the object that it capsules.</li>
<li>Construction of Boxes is seamless: Using template meta programming (TMP) and implicit constructors, values, "anything" can just be assigned to a box.</li>
<li>Similar features in other programming languages are called auto-boxing. It is especially useful if function arguments or return types are of type <b>Box</b>: Such function can be invoked with (almost) any parameter, without providing explicit conversions.</li>
<li><b>ALib Boxing</b> is 100% type safe: The boxed type can be queried and trying to unbox a wrong type, raises a run-time assertion (in debug compilations).</li>
<li><b>ALib Boxing</b> supports a sort of "virtual function" invocation on boxes. This means, that functions can be invoked on boxes without prior type-checking and/or unboxing of values. Such functions are called implemented by specializing class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> for a custom type.</li>
</ul>
<p>An extensive tutorial and reference documentation is found <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">here</a>.</p>
<p><a class="anchor" id="alib_expressions_prereq_sb"></a></p><h2>3.2 Type Definitions With "Sample Boxes"</h2>
<p>The type-safety mechanisms and the possibilities of querying the type encapsulated in a box is used by module <b>ALib Expressions</b> in an inarguably lazy fashion: Wherever this expression library needs type information, such information is given as a <b>"sample box"</b> which is created with a sample value of the corresponding C++ type.</p>
<p>Consequently, the value stored (and passed with) the box is ignored and may even become invalid after the creation of the box without any harm (for example in cases of pointer types).</p>
<p>While this approach causes a little overhead in run-time performance, the benefit in respect to simplification of the API surpasses any such penalty by far! Also, note that the performance drawback is restricted to the code that compiles an expression. During the evaluation, no "sample boxes" are created or passed.</p>
<p>The following code shows how to create sample boxes for some of the <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html">built-in standard types</a>: </p><pre class="fragment">   Box sampleBool      =    false;
   Box sampleInteger   =        0;
   Box sampleFloat     =      0.0;
   Box sampleString    = String();
</pre><p>The values assigned in the samples are meaningless. Instead of <code>false</code>, the value <code>true</code> could be used and instead of <code>0.0</code>, we could have written <code>3.1415</code>. The good news is, that the construction of the empty <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">String</a> instance, will even be optimized away by the C++ compiler in release compilations!</p>
<p>For custom types, there is no need for more efforts, as this code snippet demonstrates: </p><pre class="fragment">   struct Person
   {
       String Name;
       int    Age;
   };

   Box samplePerson= Person();
</pre><p>The magic of module <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a> makes life as simple as this! Let us preempt what is explained in the following chapters: All native callback functions to be implemented for custom operators, identifiers and functions are defined to return an object of type <b>Box</b>. Thus, these functions can just return any value of custom type. The type of the returned (boxed) value has to correspond with what a custom <b>CompilerPlugin</b> suggested by providing a sample box at expression compile-time. Once understood, this is all very simple!</p>
<dl class="section note"><dt>Note</dt><dd>Wherever possible, this library uses alias type definition <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> instead of <code>const Box&amp;</code> to indicate that a box received is a sample box and not a real value. However, sometimes it is not possible. In these cases the parameter or member itself, as well as the corresponding documentation will give a hint whether an object is a just a "sample box" or a boxed value.</dd>
<dd>
For the built-in types, static one-time sample boxes are defined with struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html">Types</a>. It is recommended to use those and, if custom types are introduced, create one singleton sample box for each custom type in a similar fashion. This approach makes the code smaller, because mostly only a reference to the static box is passed, and the creation of a sample box on the stack is avoided. Also the use of static constant objects in bulk-information-tables (introduced later), allows the compiler to build static compile-time tables.</dd></dl>
<p><a class="anchor" id="alib_expressions_prereq_virtual_types"></a></p><h2>3.3 Use Of Virtual Types Rather Than Templates</h2>
<p>A design decision of this <a class="el" href="alib_man_intro.html">ALib Module</a> is to rather use "classic" virtual types instead of using templates, with all the pros and cons taken into account of such a decision. As a result, some "contracts" have to be assured to be fulfilled by the user of the library. The term "contracts" here means: If a at some place a certain specialization of a virtual type is expected, at a different place the creation of an object of that virtual type has to be assured. Details of these contracts will be explained in the next chapters.</p>
<dl class="section note"><dt>Note</dt><dd>The main reason to use this traditional virtual library design is the use of plenty (mostly very short) native callback functions, which this way can be placed in anonymous namespaces of compilation units and thus completely be hidden from library header files and even from the C++ linker.</dd></dl>
<p><a class="anchor" id="alib_expressions_prereq_bauhaus"></a></p><h2>3.4 Bauhaus Code Style</h2>
<p><b>ALib</b> generally sometimes uses what we call "Bauhaus Code Style". It is not easy to state what we mean by this exactly, but a little notion of what it could be may have come to a programmers mind already by reading the previous two chapters about:</p><ul>
<li>(Mis-)using class <b>Box</b> for just type propagation, and</li>
<li>Imposing contract rules with specialized types, instead of templating things.</li>
</ul>
<p>In addition to that, it is notable, that a lot of the types of module <b>ALib Expressions</b> are <em>structs</em> rather than classes. Hence, fields and methods are exposed publicly. The library does not take a lot of effort to be duly abstract and minimal in exposure. Of-course, such design this neither suitable nor preferred in most situations. While we are far from feeling that we need to excuse for obviously doing even more "Bauhaus" here than usually, we rather want to convince and explain, why this design was chosen.</p>
<p>The goal of this library is to allow other software (libraries or internal units of a software) to expose an interface that has two main functions:</p><ul>
<li>Allow the input of expression strings.</li>
<li>Allow the evaluation of compiled expressions.</li>
</ul>
<p>Now, lets take a sample: A list of files should be 'filtered' by name, size, date etc. The custom library or internal software unit, would probably expose</p><ul>
<li>A class named <b>FileFilter</b> that takes an expression string in the constructor.</li>
<li>A method called "Includes" that takes a file object and returns <code>true</code> if the file matches the filter.</li>
</ul>
<p>Using this custom class could look like this: </p><pre class="fragment">   FileFilter  photosOfToday( "name * +\".jpg\" &amp;&amp; date &gt;= today" );

   if( photosOfToday.Includes( aFile ) )
   {
       ...
   }
</pre><p>As it is easily understood, really just nothing of library module <b>ALib Expressions</b> needs to be exposed to the "end user" of the code. Especially:</p><ul>
<li>Only the sources (compilation units) that implement class <b>FileFilter</b> need to include headers of module <b>ALib Expressions</b></li>
<li>Consequently, not only details of module <b>ALib Expressions</b>, like <a class="el" href="structaworx_1_1lib_1_1expressions_1_1detail_1_1Parser.html">detail::Parser</a>, <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1Program.html">detail::Program</a> or <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1VirtualMachine.html">detail::VirtualMachine</a>, but also central types like <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html">Expression</a>, <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a> or <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a>, usually remain completely invisible to most parts of the custom software.</li>
<li>The same is true for custom derived types and therefore also for the "contract rules" (see previous chapter) between these types.</li>
</ul>
<p>This all means, that the "natural way" of using module <b>ALib Expressions</b> automatically hides away all internals, which on the other side gives this module the freedom to generously use Bauhaus style, what here then finally translates to:</p><ul>
<li>Generously exposing types and their internals.</li>
<li>Avoid redundant getter/setter methods.</li>
<li>Impose contracts and avoid templates.</li>
<li>Optimizations for speed.</li>
<li>Optimizations for short code.</li>
</ul>
<p><a class="anchor" id="alib_expressions_tut_ff"></a></p><h1>4. Tutorial: Implementing A File Filter</h1>
<p>After this already lengthy introduction and discussion of prerequisites, it is now time to implement custom expression logic. The sample application that we use to demonstrate how this is done, implements expressions to filter files of directories, as it may be required by a simple file search software or otherwise be used by a third party application.</p>
<p>As a foundation, we are using the <a href="https://en.cppreference.com/w/cpp/filesystem">Filesystem Library</a> of <b>C++ 17</b>. Note that this, as of the time of writing this documentation, is an upcoming feature and with some compilers it might not be available today, or instead of including header </p><pre class="fragment">   #include &lt;filesystem&gt;
</pre><p>header </p><pre class="fragment">   #include &lt;experimental/filesystem&gt;
</pre><p>needs to be used. This library originates from a development of the <a href="https://www.boost.org">boost C++ Libraries</a> and even if you have never used it, this should not introduce more burden to understand this sample, as it is very straight forward.</p>
<p>For example, the following three lines of code:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* sourceDir= <span class="stringliteral">&quot;../../../../../src/alib/expressions/&quot;</span>;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span>&amp; directoryEntry : fs::directory_iterator( sourceDir ) )</div><div class="line">    cout &lt;&lt; directoryEntry.path().filename().generic_u8string() &lt;&lt; endl;</div></div><!-- fragment --><p> produce the following output:</p>
<div class="fragment"><div class="line">detail</div><div class="line">plugins</div><div class="line">details</div><div class="line">expression.hpp</div><div class="line">scope.hpp</div><div class="line">compiler.hpp</div><div class="line">compilerplugin.hpp</div><div class="line">expressionslib.cpp</div><div class="line">expression.cpp</div><div class="line">expressionslib.hpp</div><div class="line">compiler.cpp</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>As all sample code is extracted directly from special unit-tests that exist just for the purpose to be tutorial sample code and generate tutorial sample output, above and in the following sections we are addressing some parent directories. This results from the fact that the unit tests are executed in the built-directory, which is a sub-directory of the source code of this library.<br />
 Consequently, our samples are around searching and filtering the source files of the library. This avoids to introduce sample files, and other overhead in respect to documentation maintenance.</dd>
<dd>
Furthermore, please note that we are using the following statement to shortcut the libraries namespace: <pre class="fragment"> namespace fs = experimental::filesystem;
</pre></dd></dl>
<p><a class="anchor" id="alib_expressions_tut_ff_skel"></a></p><h2>4.1 Skeleton Code For Filtering Files</h2>
<p>Now, the loop of the above sample should be extended to use a filter to select a subset of the files and folders to be printed. Hence, a filter is needed. We start with a skeleton definition of a struct:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>step1 {</div><div class="line"><span class="keyword">struct </span>FileFilter</div><div class="line">{</div><div class="line">    <span class="comment">// Constructor</span></div><div class="line">    FileFilter(<span class="keyword">const</span> <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&amp; expressionString)</div><div class="line">    {</div><div class="line">        (void) expressionString;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Filter function. Takes a directory entry and returns &#39;true&#39; if the entry is included.</span></div><div class="line">    <span class="keywordtype">bool</span> Includes(<span class="keyword">const</span> fs::directory_entry&amp; directoryEntry)</div><div class="line">    {</div><div class="line">        (void) directoryEntry;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line">} <span class="comment">// namespace step1</span></div></div><!-- fragment --><p> As we have no clue yet, how our custom filter expressions will look like, we pass a dummy string, which is anyhow ignored by the filter skeleton. The loop then looks as follows:</p>
<div class="fragment"><div class="line">step1::FileFilter filter(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;expression string syntax not defined yet&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span>&amp; directoryEntry : fs::directory_iterator( sourceDir ) )</div><div class="line">    <span class="keywordflow">if</span>( filter.Includes( directoryEntry ) )</div><div class="line">        cout &lt;&lt; directoryEntry.path().filename().generic_u8string() &lt;&lt; endl;</div></div><!-- fragment --><p> Of-course, the output of this loop remains the same, because constant <code>true</code> is returned by the filter skeleton's method <b>Includes</b>.</p>
<p>What we nevertheless have achieved: The interface of how <b>ALib Expressions</b> will be used is already defined!<br />
 This is a good point in time to quickly sort out the different perspectives on "interfaces", "libraries" or "APIs" explicitly:</p><ol type="1">
<li>Library module <b>ALib Expressions</b> exposes an interface/API to compile and evaluate expression strings.</li>
<li>The software that uses <b>ALib Expressions</b> usually exposes an own interface/API, either<ul>
<li>to other parts of the same software, or</li>
<li>to other software - in case that this 2nd level is a library itself.</li>
</ul>
</li>
<li>The "end user" that uses a software of-course does not know about any software interface or API. What she needs to know is just the syntax of expressions strings that she can pass into the software!</li>
</ol>
<p>The goal should be that on the 2nd level, the API of the 1st level (which is this <b>ALib Expressions</b> library), is <b>not</b> visible any more.<br />
 Well, and with the simple skeleton code above, this goal is already achieved!</p>
<p><a class="anchor" id="alib_expressions_tut_ff_generic"></a></p><h2>4.2 Adding Generic Ingredients Needed For Expression Evaluation</h2>
<p>The next step is about adding all components that we need to compile and evaluate expression strings to the filter class. And this is not much effort. We had seen the ingredients before in the sample code of previous section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_calculator">2. Tutorial: Hello Calculator</a>.</p>
<p>Because it is so simple, we just present the resulting code of the filter class:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>step2 {</div><div class="line"><span class="keyword">struct </span>FileFilter</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>           compiler;</div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a> scope;</div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a>       expression;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Constructor</span></div><div class="line">    FileFilter( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&amp; expressionString )</div><div class="line">    : compiler()</div><div class="line">    , scope( compiler.CfgFormatter )</div><div class="line">    {</div><div class="line">        compiler.SetupDefaults();</div><div class="line"></div><div class="line">        expression= compiler.Compile( expressionString );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Filter function. Takes a directory entry and returns &#39;true&#39; if the entry is included.</span></div><div class="line">    <span class="keywordtype">bool</span> Includes(<span class="keyword">const</span> fs::directory_entry&amp; directoryEntry)</div><div class="line">    {</div><div class="line">        (void) directoryEntry;</div><div class="line">        <span class="keywordflow">return</span> expression-&gt;Evaluate( scope ).Unbox&lt;<span class="keywordtype">bool</span>&gt;();</div><div class="line">    }</div><div class="line">};</div><div class="line">} <span class="comment">// namespace step2</span></div></div><!-- fragment --><p> Et voil: We can now use expression strings to filter the files. Here are two samples:</p>
<p><b>Sample 1:</b> All files are included with constant expression <code>"true"</code>: </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;--- Files using expression {true}: ---&quot;</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">step2::FileFilter trueFilter(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;true&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span>&amp; directoryEntry : fs::directory_iterator( sourceDir ) )</div><div class="line">    <span class="keywordflow">if</span>( trueFilter.Includes( directoryEntry ) )</div><div class="line">        cout &lt;&lt; directoryEntry.path().filename().generic_u8string() &lt;&lt; endl;</div></div><!-- fragment --><p> The output is: </p><div class="fragment"><div class="line">--- Files <span class="keyword">using</span> expression {<span class="keyword">true</span>}: ---</div><div class="line">detail</div><div class="line">plugins</div><div class="line">details</div><div class="line">expression.hpp</div><div class="line">scope.hpp</div><div class="line">compiler.hpp</div><div class="line">compilerplugin.hpp</div><div class="line">expressionslib.cpp</div><div class="line">expression.cpp</div><div class="line">expressionslib.hpp</div><div class="line">compiler.cpp</div></div><!-- fragment --><p> <b>Sample 2:</b> All files are filtered out with constant expression <code>"false"</code>: </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;--- Files using expression {false}: ---&quot;</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">step2::FileFilter falseFilter(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;false&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span>&amp; directoryEntry : fs::directory_iterator( sourceDir ) )</div><div class="line">    <span class="keywordflow">if</span>( falseFilter.Includes( directoryEntry ) )</div><div class="line">        cout &lt;&lt; directoryEntry.path().filename().generic_u8string() &lt;&lt; endl;</div></div><!-- fragment --><p> Which results to the empty output: </p><div class="fragment"><div class="line">--- Files <span class="keyword">using</span> expression {<span class="keyword">false</span>}: ---</div></div><!-- fragment --><p> While this demonstrates fast progress towards our aim to filter files, of-course we have not linked the expression library with this custom code example, yet. All we can do is providing expressions that do not refer to the file given, hence either evaluate to <code>true</code> for any file or to <code>false</code>.<br />
 But before we feel free to start working on this, we first need to put one stumbling block aside.</p>
<p><a class="anchor" id="alib_expressions_tut_ff_checkresult"></a></p><h2>4.3 Checking An Expression's Result Type</h2>
<p>In the samples above we used simple, constant expressions <code>"true"</code> and <code>"false"</code>. As we already learned in chapter 3, these are built-in identifiers that return the corresponding boolean value. Well, and a boolean value is what the filter needs. Other valid expressions would be </p><pre class="fragment">   5 &gt; 3                 // constant true
   Year(Today) &lt; 2018    // constant false
</pre><p>"Valid" here means, that the expression returns a boolean value! But what would happen if we constructed the filter class with expression string </p><pre class="fragment">   1 + 2
</pre><p>which returns an integral value? The answer is that in method <b>Includes</b> of the filter class presented in the previous sections a runtime assertion would be raised in the following line of code: </p><pre class="fragment">   return expression-&gt;Evaluate( scope ).Unbox&lt;bool&gt;();
</pre><p>The code <em>unboxes</em> a value of type <em>bool</em>, but it is not asserted that the result of the evaluation is of that type. This quickly leads us to an enhanced version of that method:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> Includes(<span class="keyword">const</span> fs::directory_entry&amp; directoryEntry)</div><div class="line">{</div><div class="line">    (void) directoryEntry;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> result= expression-&gt;Evaluate( scope );</div><div class="line">    <span class="keywordflow">if</span>( result.IsType&lt;<span class="keywordtype">bool</span>&gt;() )</div><div class="line">        <span class="keywordflow">return</span> result.Unbox&lt;<span class="keywordtype">bool</span>&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// trow exception</span></div><div class="line">    <span class="keywordflow">throw</span> std::runtime_error( <span class="stringliteral">&quot;Expression result type mismatch: expecting boolean result!&quot;</span> );</div><div class="line">}</div></div><!-- fragment --><p> So here is some bad news: It is obvious, that there is no way around the effort of throwing and catching exceptions (or otherwise do some error processing) as soon as a software allows an end-user to "express herself" by passing expression strings to a software. Besides wrong return types, the whole expression might be malformed, for example by omitting a closing bracket or any other breach of the expression syntax rules.</p>
<p>The good news however is, that with the use of module <b>ALib Expressions</b>, most - if not all - of the errors can be handled already at compile time! Once an expression is compiled, not much can happen when an expression is later evaluated.</p>
<p>And this is also true for our current thread of facing a wrong result type: Due to the fact that module <b>ALib Expressions</b> implements a <em>type safe compiler</em>, we can detect the result type at compile time.</p>
<p>Consequently, we revert our most recent code changes and rather check the result type already right after the compilation:</p>
<div class="fragment"><div class="line">FileFilter( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&amp; expressionString )</div><div class="line">: compiler()</div><div class="line">, scope( compiler.CfgFormatter )</div><div class="line">{</div><div class="line">    compiler.SetupDefaults();</div><div class="line"></div><div class="line">    expression= compiler.Compile( expressionString );</div><div class="line"></div><div class="line">    <span class="comment">// check result type of the expression</span></div><div class="line">    <span class="keywordflow">if</span>( !expression-&gt;ResultType().IsType&lt;<span class="keywordtype">bool</span>&gt;() )</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error( <span class="stringliteral">&quot;Expression result type mismatch: expecting boolean result!&quot;</span> );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> Includes(<span class="keyword">const</span> fs::directory_entry&amp; directoryEntry)</div><div class="line">{</div><div class="line">    (void) directoryEntry;</div><div class="line"></div><div class="line">    <span class="comment">// no result type check needed: It is asserted that Evaluate() returns a boxed boolean value.</span></div><div class="line">    <span class="keywordflow">return</span> expression-&gt;Evaluate( scope ).Unbox&lt;<span class="keywordtype">bool</span>&gt;();</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>It is up to the user of this library to decide how strict an implementation would be. Later in this tutorial, we will read permissions from the files, which might get "tested" using bitwise boolean operators, e.g. <pre class="fragment">     Permissions &amp; OwnerWrite == OwnerWrite
</pre></dd>
<dd>
Similar to programming languages, it could be allowed to shorten this expression to just <pre class="fragment">     Permissions &amp; OwnerWrite
</pre></dd>
<dd>
The result is an integral value, respectively a user defined permission type that probably represents an underlying integral value. It is up to the filter class' method <b>Includes</b> to check for and interpret other types than boolean. </dd>
<dd>
To provide the biggest degree of freedom, the result of boxing interface <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsTrue.html">IIsTrue</a> might be returned instead of unboxing a boolean value. This interface is a good candidate to convert just any boxed value to a reasonable representation of a boolean value. Again, this is a design decision of the software that uses this library. It has to be documented to the end-user what type of expression results are allowed.</dd></dl>
<p><a class="anchor" id="alib_expressions_tut_ff_scope"></a></p><h2>4.4 Exposing The Directory Entry To ALib Expressions</h2>
<p>It is time to finally make our sample meaningful, namely to allow filter selected files by their attributes.</p>
<p>For this two steps are needed. The first again is extremely simple: We have to expose the current directory entry of our filter loop to the file filter. All we need to do is to specialize class <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a> to a custom version that provides the current object.<br />
 Here is our new struct:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>step4 {</div><div class="line"><span class="keyword">struct </span>FFScope : <span class="keyword">public</span> <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a></div><div class="line">{</div><div class="line">    <span class="comment">// the current directory entry</span></div><div class="line">    <span class="keyword">const</span> fs::directory_entry*    directoryEntry;</div><div class="line"></div><div class="line">    <span class="comment">// expose parent constructor</span></div><div class="line">    <span class="keyword">using</span> <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#a4a6f409355cce90e0cacfdd098f24b92">Scope::Scope</a>;</div><div class="line">};</div><div class="line">} <span class="comment">// namespace step4</span></div></div><!-- fragment --><p> With this in place, we just need two small changes in our file filter: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>step4 {</div><div class="line"><span class="keyword">struct </span>FileFilter</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>        compiler;</div><div class="line">    FFScope         scope;      <span class="comment">// CHANGE 1: we use FFScope now</span></div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a>    expression;</div><div class="line"></div><div class="line">    FileFilter( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&amp; expressionString )</div><div class="line">    : compiler()</div><div class="line">    , scope( compiler.CfgFormatter )</div><div class="line">    {</div><div class="line">        compiler.SetupDefaults();</div><div class="line">        expression= compiler.Compile( expressionString );</div><div class="line">        <span class="keywordflow">if</span>( !expression-&gt;ResultType().IsType&lt;<span class="keywordtype">bool</span>&gt;() )</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error( <span class="stringliteral">&quot;Expression result type mismatch: expecting boolean result!&quot;</span> );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> Includes(<span class="keyword">const</span> fs::directory_entry&amp; directoryEntry)</div><div class="line">    {</div><div class="line">        <span class="comment">// CHANGE 2: Store the given entry in our scope singleton which is then passed into</span></div><div class="line">        <span class="comment">//           Evaluated() as it was already before.</span></div><div class="line">        scope.directoryEntry= &amp;directoryEntry;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> expression-&gt;Evaluate( scope ).Unbox&lt;<span class="keywordtype">bool</span>&gt;();</div><div class="line">    }</div><div class="line">};</div><div class="line">} <span class="comment">// namespace step4</span></div></div><!-- fragment --><p> Now, the expression's <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1Program.html">detail::Program</a> that gets compiled in the constructor of the filter class and that is executed by the built-in <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1VirtualMachine.html">detail::VirtualMachine</a> with the invocation of <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a0b4979bb94b656999acc80e148d9da5f">Evaluate</a>, potentially has access to the directory entry.</p>
<p>The next section connects the final dots and leads to a working sample.</p>
<p><a class="anchor" id="alib_expressions_tut_ff_cp"></a></p><h2>4.5 Implementing A Compiler Plug-In</h2>
<p>We have come quite far without ever thinking about the syntax of the custom expressions that we need to be able to filter files from a directory. Without much reflection of that, it is obvious that filtering files by name should be enabled, maybe with support of <em>"wildcards"</em> just like most users know them from the command prompt: </p><pre class="fragment">   ls -l *.hpp  // GNU/Linux
   dir *.hpp    // Windows OS
</pre><p>Thus, the first thing we need is to retrieve the file name from the entry. This is done with a simple custom <em>identifier</em>. As it was said already, an <em>identifier</em> is a "parameterless function". So why don't we need a parameter, namely the file entry in the expression syntax? Well, because the entry is part of the scope. It is the central piece of custom information that the whole effort is done for. Therefore, the expression: </p><pre class="fragment">   Name
</pre><p>should return the name of the actual directory entry that is "in scope". This is lovely simple, so let's start. Again we start with a skeleton struct, this time derived from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>step5 {</div><div class="line"><span class="keyword">struct </span>FFCompilerPlugin : <span class="keyword">public</span> <a class="code" href="namespaceaworx.html#ac9c19c11a742256edba9903a1130b75c">CompilerPlugin</a></div><div class="line">{</div><div class="line">    FFCompilerPlugin( <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>&amp; compiler )</div><div class="line">    : <a class="code" href="namespaceaworx.html#ac9c19c11a742256edba9903a1130b75c">CompilerPlugin</a>( <span class="stringliteral">&quot;FF Plug-in&quot;</span>, compiler )</div><div class="line">    {}</div><div class="line"></div><div class="line">};</div><div class="line">} <span class="comment">// namespace step5</span></div></div><!-- fragment --><p> To make use of the plug-in, we have again two small changes in the custom filter class:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>step5 {</div><div class="line"><span class="keyword">struct </span>FileFilter</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>            compiler;</div><div class="line">    FFScope             scope;</div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a>        expression;</div><div class="line">    FFCompilerPlugin    ffPlugin;     <span class="comment">// CHANGE 1: We own an instance of our custom plug-in.</span></div><div class="line"></div><div class="line">    FileFilter( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&amp; expressionString )</div><div class="line">    : compiler()</div><div class="line">    , scope( compiler.CfgFormatter )</div><div class="line">    , ffPlugin( compiler )            <span class="comment">// CHANGE 1: Initialize the plug-in with the compiler.</span></div><div class="line">    {</div><div class="line">        compiler.SetupDefaults();</div><div class="line"></div><div class="line">        <span class="comment">// CHANGE 2: Add our custom plug-in to the compiler prior to compiling the expression</span></div><div class="line">        compiler.InsertPlugin( &amp; ffPlugin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59a90589c47f06eb971d548591f23c285af">CompilePriorities::Custom</a> );</div><div class="line"></div><div class="line">        expression= compiler.Compile( expressionString );</div><div class="line">        <span class="keywordflow">if</span>( !expression-&gt;ResultType().IsType&lt;<span class="keywordtype">bool</span>&gt;() )</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error( <span class="stringliteral">&quot;Expression result type mismatch: expecting boolean result!&quot;</span> );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> Includes(<span class="keyword">const</span> fs::directory_entry&amp; directoryEntry)</div><div class="line">    {</div><div class="line">        scope.directoryEntry= &amp;directoryEntry;</div><div class="line">        <span class="keywordflow">return</span> expression-&gt;Evaluate( scope ).Unbox&lt;<span class="keywordtype">bool</span>&gt;();</div><div class="line">    }</div><div class="line">};</div><div class="line">}; <span class="comment">// namespace step5</span></div></div><!-- fragment --><p> With this, the plug-in is in place and during compilation it is now asked for help. Parent class <b>CompilerPlugin</b> exposes a set of overloaded virtual functions named <b>TryCompilation</b>. In their existing default implementation each function just returns constant <code>false</code>, indicating that a plug-in is not responsible. Thus, we have to make our plug-in now responsible for <em>identifier</em> <code>"Name"</code>. For this we choose to override one of the offered virtual functions as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>step5 {</div><div class="line"><span class="keyword">struct </span>FFCompilerPlugin : <span class="keyword">public</span> <a class="code" href="namespaceaworx.html#ac9c19c11a742256edba9903a1130b75c">CompilerPlugin</a></div><div class="line">{</div><div class="line">    FFCompilerPlugin( <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>&amp; compiler )</div><div class="line">    : <a class="code" href="namespaceaworx.html#ac9c19c11a742256edba9903a1130b75c">CompilerPlugin</a>( <span class="stringliteral">&quot;FF Plug-in&quot;</span>, compiler )</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="comment">// implement &quot;TryCompilation&quot; for functions</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> TryCompilation( CIFunction&amp;  ciFunction )</div><div class="line">    {</div><div class="line">        <span class="comment">// Is parameterless and function name equals &quot;Name&quot;?</span></div><div class="line">        <span class="keywordflow">if</span>(       ciFunction.QtyArgs() == 0</div><div class="line">             &amp;&amp;   ciFunction.Name.Equals&lt;Case::Ignore&gt;( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Name&quot;</span>) )    )</div><div class="line">        {</div><div class="line">            <span class="comment">// set callback function, its return type and indicate success</span></div><div class="line">            ciFunction.Callback     = getName;</div><div class="line">            ciFunction.TypeOrValue  = <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a>;</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// For anything else, we are not responsible</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">};</div><div class="line">} <span class="comment">// namespace step5</span></div></div><!-- fragment --><p>As the code shows, the overridden function simply checks for the given name and the function "signature". If both match, then a native C++ callback function is provided together with the expected result type of that callback function.</p>
<p>The final step, before we can test the code is to implement the callback function. This is usually done in an anonymous namespace at the start of the compilation unit of the plug-in itself. The signature of any callback function that <b>ALib Expressions</b> expects, is given with <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>. The documentation shows, that it has three parameters, the scope and the begin- and end-iterators for the input parameters. The input parameters are boxed in objects of class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> and the same type is expected to be returned.</p>
<p>Because <b>ALib Boxing</b> makes a programmer's life extremely easy, especially when used with various kinds of strings, and because we are not reading any input parameters, the implementation of the callback function is done with just two lines of code:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getName( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="comment">// Create a copy of the string using the scope string allocator. This is done with utility</span></div><div class="line">    <span class="comment">// class ScopeString, which when returned, right away is boxed as a usual string,</span></div><div class="line">    <span class="comment">// aka char[]. Therefore, no intermediate string objects to be stored, neither the</span></div><div class="line">    <span class="comment">// std::string returned by &quot;generic_u8string&quot;, nor the string.</span></div><div class="line">    <span class="comment">// Note, that this must be done within the call, because the object returned by</span></div><div class="line">    <span class="comment">// generic_u8string() will be instantly deleted and thus the buffer thrown away.</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceaworx.html#ad7b7d1a2e78da4e5f66f588a6ba52798">ScopeString</a>( scope, 0,</div><div class="line">                        dynamic_cast&lt;FFScope&amp;&gt;( scope ).directoryEntry-&gt;path().filename().generic_u8string()   );</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The callback function casts the scope object to our custom type <b>FFScope</b>. The function can trust that this succeeds, if each expression that gets compiled with the compiler that uses the plug-in gets a scope object of exactly this derived custom type passed when evaluated.</dd>
<dd>
This is a sample of the "contracts" that have to be fulfilled by the user of library as already stated in previous chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_virtual_types">4.3 Use Of Virtual Types</a>. Another of such <em>contract</em> can be seen with the code of the compiler plug-in: The type of the returned boxed value of the callback function has to match the type specified in the <b>TryCompilation</b>. And furthermore, all code paths of the callback function have to return a box value of that very same type, regardless of the input parameters.</dd>
<dd>
These are constraints that the user of this library has to assure. However, as it is recommended to implement classes like <b>FileFilter</b> in our sample, this responsibility to keep the contracts is only shared within a few implementation units. What we previously called, "the custom 2nd level api", hides these constraints completely away, along with all other parts of <b>ALib Expressions</b>.</dd></dl>
<p>We are set! Our first "real" filter expressions should work. Here are some filter loops and their output:</p>
<p><b>Sample 1:</b> : </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;--- Files using expression {name == \&quot;compiler.hpp\&quot;}: ---&quot;</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">step5::FileFilter filter1(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;name == \&quot;compiler.hpp\&quot;&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span>&amp; directoryEntry : fs::directory_iterator( sourceDir ) )</div><div class="line">    <span class="keywordflow">if</span>( filter1.Includes( directoryEntry ) )</div><div class="line">        cout &lt;&lt; directoryEntry.path().filename().generic_u8string() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">--- Files <span class="keyword">using</span> expression {name == <span class="stringliteral">&quot;compiler.hpp&quot;</span>}: ---</div><div class="line">compiler.hpp</div></div><!-- fragment --><p> <b>Sample 2:</b> : </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;--- Files using expression {WildcardMatch(name, \&quot;*.hpp\&quot;}: ---&quot;</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">step5::FileFilter filter2(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;WildcardMatch(name, \&quot;*.hpp\&quot;)&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span>&amp; directoryEntry : fs::directory_iterator( sourceDir ) )</div><div class="line">    <span class="keywordflow">if</span>( filter2.Includes( directoryEntry ) )</div><div class="line">        cout &lt;&lt; directoryEntry.path().filename().generic_u8string() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">--- Files <span class="keyword">using</span> expression {WildcardMatch(name, <span class="stringliteral">&quot;*.hpp&quot;</span>}: ---</div><div class="line">expression.hpp</div><div class="line">scope.hpp</div><div class="line">compiler.hpp</div><div class="line">compilerplugin.hpp</div><div class="line">expressionslib.hpp</div></div><!-- fragment --><p><b>Sample 3:</b> : </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;--- Files using expression {name * \&quot;*.cpp\&quot;}: ---&quot;</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">step5::FileFilter filter3(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;name * \&quot;*.cpp\&quot;&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span>&amp; directoryEntry : fs::directory_iterator( sourceDir ) )</div><div class="line">    <span class="keywordflow">if</span>( filter3.Includes( directoryEntry ) )</div><div class="line">        cout &lt;&lt; directoryEntry.path().filename().generic_u8string() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">--- Files <span class="keyword">using</span> expression {name * <span class="stringliteral">&quot;*.cpp&quot;</span>}: ---</div><div class="line">expressionslib.cpp</div><div class="line">expression.cpp</div><div class="line">compiler.cpp</div></div><!-- fragment --><p> <b>This seems to work - mission accomplished!</b></p>
<p>Some notes on these samples:</p><ul>
<li>Because the custom identifier <code>Name</code> does not introduce a custom type, but returns built-in type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a>, no operators have to be overloaded. In later chapters we will see what needs to be done when custom-types are returned by identifiers, functions or operators.</li>
<li>Built-in expression function <b>WildcardMatch</b> accepts two strings, the first is the string that is matched, the second contains the wildcard string. Function <b>WildcardMatch</b> is provided with built-in compiler plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">Strings</a>.</li>
<li>The third sample uses an overloaded version of binary operator <code>'*'</code>, with left- and right-hand side being strings. This binary operator is also provided with plug-in <b>Strings</b> and is just an <em>"alias"</em> for function <b>WildcardMatch</b>.</li>
</ul>
<p>We could now easily continue implementing further identifiers, for example:</p><ul>
<li><b>IsDirectory:</b> Returns <code>true</code> if the directory entry is a sub-directory, <code>false</code> if it is a file.</li>
<li><b>Size:</b> Returns the size of the file built-in type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>.</li>
<li><b>Date:</b> Returns the date of the entry as built-in type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a58c1c61a83c381d1bb9426caa984f727">Types::DateTime</a>.</li>
<li><b>Permissions:</b> Returns the access rights of the file or folder. For this, we would probably return an integer value and introduce further identifiers like <b>GroupRead</b>, <b>GroupWrite</b>, <b>OwnerRead</b>,... and so forth that return constants.</li>
</ul>
<p>This would lead to inserting further <code>if</code>-statements to the custom plug-in, similar to the one demonstrated for identifier <b>Name</b>.</p>
<p>Before this should be sampled, the next chapter explains the general possibilities of compiler plug-ins and shows how the creation of a plug-in can be even further simplified.</p>
<p><a class="anchor" id="alib_expressions_cpcc"></a></p><h1>5. Compiler Plug-Ins And Class Calculus</h1>
<p>In the previous tutorial section, a fully working example program was developed that allows to use custom expression strings to filter files and folders by their name.</p>
<p>It was demonstrated how to attach a custom compiler plug-in to the expression compiler, which selects a native C++ callback function at compile-time. This callback function is then invoked each time a compiled expression is evaluated against a scope. The sample implemented the retrieval of a string value from an object found in a custom specialization of class <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a>.</p>
<p><a class="anchor" id="alib_expressions_cpcc_process"></a></p><h2>5.1 The Compilation Process</h2>
<p>When an expression string gets compiled, such compilation is done in two phases. The first step is called <b>"parsing"</b>. </p><dl class="section note"><dt>Note</dt><dd><b>ALib Expressions</b> provides two choices of parsers, which are selectable via a preprocessor compilation symbol. For more details on this see <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_appendix_boostspirit">A.3 Using Built-In Alternative Parser Based On boost::spirit</a>.</dd></dl>
<p>The result of the parsing process is a recursive data structure called <em>"abstract syntax tree"</em>. The nodes of this tree can have one of the following types:</p><ol type="1">
<li><b>Literals:</b><br />
 Literals are constants found in the expression strings. There are three types of literals supported: <b>Integral</b> (e.g. "42"), <b>floating-point</b> (e.g. "3.14") and <b>string</b> values (e.g. "Hello"). A literal node is a so-called <em>"terminal"</em> node, which means it has no child nodes.</li>
<li><b>Identifiers:</b><br />
 These are named tokens, starting with an alphabetical character and further consisting of alpha-numerical characters or character <code>'_'</code>.<br />
 Likewise literals, identifiers are terminal nodes.</li>
<li><b>Unary operators:</b><br />
 These are nodes that represent an unary operation like "boolean not" (<code>'!'</code>) or arithmetic negation (<code>'-'</code>). These nodes have one child node.</li>
<li><b>Binary operators:</b><br />
 Samples of binary operators are "boolean and" (<code>'&amp;&amp;'</code>) or arithmetic subtraction (<code>'-'</code>). These nodes have two child nodes.</li>
<li><b>Ternary operators:</b><br />
 Only one ternary operator is supported. It is called <em>"conditional operator"</em> and parsed in the form <b>"<em>Q</em> ? <em>T</em> : <em>F"</b></em> with <em>Q</em>, <em>T</em> and <em>F</em> being expressions. The result of the operation is <em>T</em> if <em>Q</em> represents <code>true</code>, otherwise it is <em>F</em>.</li>
<li><b>Functions:</b><br />
 Functions are identifiers followed by a pair of round brackets <code>'()'</code>. Within the brackets a list of expressions, separated by a colon (<code>','</code>) may be given. Hence, functions are <em>n-ary</em> nodes, having as many child nodes as parameters are given in the brackets.</li>
</ol>
<p>This first phase of compilation that builds the <em>AST</em> (<em>abstract syntax tree</em>) usually does not need too much customization. </p><dl class="section note"><dt>Note</dt><dd>Various customization options are nevertheless provided. The most important ones are described in:<ul>
<li><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_custom">9.2 Tutorial: Adding A Custom Operator</a></li>
<li><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_verbal">9.3 Verbal Operator Aliases</a></li>
<li><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_literals">11.2 Literals</a></li>
</ul>
</dd></dl>
<p>It could be reasonably argued, that building this tree is all that an expression library needs to do and in fact, many similar libraries stop at this point. What needs to be done to evaluate an expression is to recursively walk the <em>AST</em> in a so called "depths first search" manner, and perform the operations. The result of the evaluation would be the result of the root node of the tree.</p>
<p><b>ALib Expressions</b> goes one step further, performing a <b>second phase</b> of compilation. In this phase, the recursive walk over the <em>AST</em> is done. The result of the walk is an expression <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1Program.html">detail::Program</a>. Such program is a flat (non-recursive) list of "commands" which are later, when the expression is evaluated, executed on a virtual stack machine. (This stack machine is implemented with <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1VirtualMachine.html">detail::VirtualMachine</a>).</p>
<p>This second phase is where the customization takes place. When a node of the <em>AST</em> is translated into a program command for the virtual machine, the compiler iterates through an ordered list of <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a>s to ask for compilation information. As soon as one plug-in provides such info, the compiler creates the command and continues walking the tree.</p>
<p>Now, what does the compiler exactly "ask" a plug-in for and what information is included in the question? To answer this, let us first look at the list of <em>AST</em> nodes given above. Of the the six types of <em>AST-nodes</em> listed, two do not need customization. These are <em>literals</em> and the <em>ternary operator</em>. What remains is</p><ul>
<li>Identifiers and Functions,</li>
<li>Unary operators and</li>
<li>Binary operators.</li>
</ul>
<p>It was mentioned before, that <b>ALib Expressions</b> is type safe. To achieve this, the result type of each node is identified (deepest nodes first). Whenever a node with child nodes is compiled, the result types of each child node has already been identified.</p>
<p>With this in mind, the input and output information that compiler plug-ins receive and return becomes obvious. Input is:</p><ul>
<li>The node type and according information (e.g. the operator, the identifier or function name)</li>
<li>The result type of each child</li>
</ul>
<p>The output information is:</p><ul>
<li>A pointer to a native C++ callback function that will be invoked by the virtual machine when the program command resulting from the node is executed.</li>
<li>The result type of that native C++ callback function.</li>
<li>Alternatively to this, in case of "constant nodes", a constant result value may be returned (which likewise defines the node type). For example, built-in identifier <b>"true"</b> returns constant value boolean <code>true</code>.</li>
</ul>
<p>To finalize this section, a quick hint to the benefits of taking this approach should be given:</p><ul>
<li>Compile-time type safety allows to identify almost all errors in user-defined expression strings at compile time. On the one hand, this allows to reject malformed expressions right at the moment they are given. If such detection was deferred to evaluation-time, then usually a software has quite some effort "undo" certain actions that the software did to prepare the evaluation.</li>
<li>Both compile-time type safety and the fact that the <em>AST</em> is translated into a linear program of-course increase compile time, but this is done in favour to evaluation time. In many use-case scenarios, there is an overwhelmingly high ratio of evaluations per expression. Therefore, this library is 100% optimized for evaluation performance, while compilation performance is considered pretty unimportant.</li>
<li>Operation overloading avoids type checking at evaluation time and leads to very thin callback functions, many of them being just a single line of code. In addition, the implementation of the native C++ callback functions can be separated into various compilation units, as already demonstrated with the built-in plug-ins that each addresses a certain dedicated "topic", like <em>"string handling"</em>, "date and time", etc.</li>
</ul>
<p><a class="anchor" id="alib_expressions_cpcc_bipl"></a></p><h2>5.2 The Built-In Compiler Plug-Ins</h2>
<p>With the information given in the previous sub-chapter, some important consequence can be noted:</p>
<dl class="section user"><dt></dt><dd><b>The compilation process works on <em>"permutations"</em> of the following information:</b><ul>
<li><b>node types,</b></li>
<li><b>node type specific information (e.g. unary/binary operator type or identifier/function name) and</b></li>
<li><b>all types of child nodes.</b></li>
</ul>
</dd></dl>
<p>This fact in turn leads to the following statements:</p><ul>
<li>The compilation process fails, if no plug-in returns compilation information for a certain permutation.</li>
<li>Each permutation may lead to different C++ callback function and result type.<br />
 (In the C++ language, this behavior is called "operator and function overloading".)</li>
<li>A compiler plug-in with a higher priority, may replace (disable) an implementation of a permutation which would be responded by a plug-in of lower priority.</li>
</ul>
<p>As a sample, let's take two simple expressions </p><pre class="fragment">   1 + 2
   "Result " + 42
</pre><p>Both expressions consist of two literal nodes, which are the two children of binary operator <code> '+'</code>. As literals are not compiled using plug-ins, only the binary operator is passed to the plug-ins. To successfully compile both, plug-ins have to be available that cover the following permutations: </p><pre class="fragment">   binary op, + , integer, integer
   binary op, + , string, integer
</pre><p>For the addition of integer values, built-in compiler plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html">Arithmetics</a> is responsible. For the concatenation of integer values to string values, plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">Strings</a> steps in.</p>
<p>The documentation of the plug-ins therefore mainly consist of tables that list permutations of operators, function names and input types, together with a description of what is done in the C++ callback function and what result type is to be expected.</p>
<p>The use of the built-in plug-ins is optional and configurable. Configuration is done by tweaking member <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#af625946a92a359feef1093b444a5e343">Compiler::CfgBuiltInPlugins</a> prior to invoking method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a>. But a use-case to do so, is not so easy to find, also due to the fact that custom plug-ins default to a higher priority and this way might replace selected built-in behaviour.</p>
<p>To implement a custom compiler plug-in, the following "bottom-up" approach is recommended:</p>
<ul>
<li>An application usually provides simple custom identifier names, which for example read property values from application objects defined from a specialized version of type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a>. The compilation of such identifier should be implemented first.</li>
<li>If an identifier callback function returns values of application-specific type, then in addition a reasonable set of operators overloaded for these types should to be implemented. (Obviously, if that was not done, only simple expressions, consisting just of the custom identifiers themselves, returning that custom type could be compiled.)</li>
<li>If more complex custom functionality is needed, finally custom expression functions can be implemented. Of-course, if such functions again introduce so-far unknown return types, operators for these types have to be implemented as well.</li>
</ul>
<p>To finalize this chapter, some obvious facts should be named:</p><ul>
<li>Each and every calculation is performed by plug-ins. Even a simple <code>"1 + 2"</code> calculation might be handled by custom code.</li>
<li>Usually, there is no need to omit the default plug-ins. There is only very, very small performance decrease on compiling an expression with more plug-ins installed. And there is absolutely no impact on the usually much more important evaluation performance.</li>
<li>Three of the built-in types, namely <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#aa813c9126cceb582e44aa5a6f4c8a541">Types::Float</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a> "emerge" from parsing literals.</li>
<li>The other built-in types, namely <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a9c063c947f3dce589e49866913a7d357">Types::Boolean</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a58c1c61a83c381d1bb9426caa984f727">Types::DateTime</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a51d5b447dda0a9740c8d207617a86d89">Types::Duration</a> instead emerge as being result types of built-in compiler plug-ins. For example, type <b>Boolean</b> is a result type of identifier <b>"True"</b>, as well as the result type of <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325aafc493b6574d5529ed0ffa6f18f05b20">BinaryOp::Smaller</a> (<code>'&lt;'</code>) with various combinations of argument types provided with different built-in compiler plug-ins.</li>
<li>The introduction of custom types is done by just introducing a custom plug-in that compiles <em>AST</em> nodes with returning such custom type. There is no need to register the types. (With the exception that for the purpose of the creation of human readable compiler exceptions, method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a92a56e46c780a383d141f105b52176f1">Compiler::AddType</a> is provided.)</li>
<li>After the compilation process is done the <em>AST</em> data structure is deleted.</li>
<li>The compilation process is a little more complex than presented here. More details will be explained in later chapters, for example in <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_optimizations">11.5 Optimizations</a> and <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_types">11.1 Types</a>.</li>
</ul>
<p><a class="anchor" id="alib_expressions_cpcc_class"></a></p><h2>5.3 Class CompilerPlugin</h2>
<p>After a lot of theory was given, it is now quite straight forward to explain how struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a> is used.</p>
<p>The struct provides an inner struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CompilationInfo.html">CompilationInfo</a> which is the base of several derived further (inner) specializations. The base struct exposes the common base of the input and all of the output information provided by and received from compiler plug-ins. According to the different node types of the parsed <em>AST</em>, the specializations are:</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a></li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a></li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html">CIFunction</a></li>
</ul>
<p>Along with this, for each of these structs, an overloaded virtual method called <b>TryCompilation</b> is defined. A custom plug-in now simply derives from the plug-in struct, and overrides one or more of the virtual methods. The original implementation of the base struct returns constant <code>false</code>. In the case that the given information corresponds to a permutation that the custom plug-in chooses to compile, the plug-in needs to fill in the output parameters of the given struct and return <code>true</code>.</p>
<dl class="section note"><dt>Note</dt><dd>A fourth specialization of <b>CompilationInfo</b> is given with <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html">CIBinaryAutoCast</a> together with a corresponding overloaded method <b>TryCompilation</b>. Its purpose and use is explained in chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_types">11.1 Types</a>.</dd></dl>
<p><a class="anchor" id="alib_expressions_cpcc_calculus"></a></p><h2>5.4 Class Calculus</h2>
<p>The architecture of the expression compiler and the use of according plug-ins was explained and we could continue now with extending the sample plug-in given in section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_cp">4.5 Implementing A Compiler Plug-In</a>.</p>
<p>This would quickly lead to inserting a bunch of <code>if</code>-statements to the already overridden method <b>TryCompilation</b>. Considering all possible permutations of operators and types, this result in repetitive code. To avoid this, the library provides an optional helper class.<br />
 All built-in compiler plug-ins (with the exception of <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1ElvisOperator.html">ElvisOperator</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1AutoCast.html">AutoCast</a>) use this class and are therefore not derived from <b>CompilerPlugin</b>, but from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">plugins::Calculus</a>.</p>
<p>The trick with that type is that permutations of operators, identifiers, function names and argument types are provided as static table data, together with the information of how to compile the permutations.</p>
<p>Then in a custom constructor, these static tables are fed into hash tables that allow a performant search. The custom plug-in does not need to furthermore overrider any <b>TryCompilation</b> method, as class <b>Calculus</b> provides a default implementation that simply searches the hash tables.</p>
<p>Consequently, all that these built-in plug-ins do is feeding their keys and corresponding callback methods to these hash tables during construction. This is not just very efficient in respect to this library's code size and in respect to the compilation performance of expressions, it also makes the creation of a plug-in an even more simple and straight-forward task.</p>
<dl class="section user"><dt></dt><dd><b>Hence, the advice to library users is to also use helper type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">plugins::Calculus</a> as the parent class for custom compiler plug-ins, instead of deriving from CompilerPlugin.</b></dd></dl>
<p>With this in mind, we now go back to our tutorial sample and add more file filter functionality.</p>
<p><a class="anchor" id="alib_expressions_tut_ffext"></a></p><h1>6. Tutorial: Extending The File Filter Sample</h1>
<p><a class="anchor" id="alib_expressions_tut_ffext_calc"></a></p><h3>6.1 Replacing CompilerPlugin By Calculus</h3>
<p>Before we start adding new features to the sample code of section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff">4. Tutorial: Implementing A File Filter</a> the first task is to refactor the sample to use helper type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">plugins::Calculus</a>.</p>
<p>The already presented sample plug-in defined a callback function was: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getName( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="comment">// Create a copy of the string using the scope string allocator. This is done with utility</span></div><div class="line">    <span class="comment">// class ScopeString, which when returned, right away is boxed as a usual string,</span></div><div class="line">    <span class="comment">// aka char[]. Therefore, no intermediate string objects to be stored, neither the</span></div><div class="line">    <span class="comment">// std::string returned by &quot;generic_u8string&quot;, nor the string.</span></div><div class="line">    <span class="comment">// Note, that this must be done within the call, because the object returned by</span></div><div class="line">    <span class="comment">// generic_u8string() will be instantly deleted and thus the buffer thrown away.</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceaworx.html#ad7b7d1a2e78da4e5f66f588a6ba52798">ScopeString</a>( scope, 0,</div><div class="line">                        dynamic_cast&lt;FFScope&amp;&gt;( scope ).directoryEntry-&gt;path().filename().generic_u8string()   );</div><div class="line">}</div></div><!-- fragment --><p> Furthermore our compiler plugin was derived from <b>CompilerPlugin</b> and implemented method <b>TryCompilation</b> for functions (identifiers): </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>step5 {</div><div class="line"><span class="keyword">struct </span>FFCompilerPlugin : <span class="keyword">public</span> <a class="code" href="namespaceaworx.html#ac9c19c11a742256edba9903a1130b75c">CompilerPlugin</a></div><div class="line">{</div><div class="line">    FFCompilerPlugin( <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>&amp; compiler )</div><div class="line">    : <a class="code" href="namespaceaworx.html#ac9c19c11a742256edba9903a1130b75c">CompilerPlugin</a>( <span class="stringliteral">&quot;FF Plug-in&quot;</span>, compiler )</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="comment">// implement &quot;TryCompilation&quot; for functions</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> TryCompilation( CIFunction&amp;  ciFunction )</div><div class="line">    {</div><div class="line">        <span class="comment">// Is parameterless and function name equals &quot;Name&quot;?</span></div><div class="line">        <span class="keywordflow">if</span>(       ciFunction.QtyArgs() == 0</div><div class="line">             &amp;&amp;   ciFunction.Name.Equals&lt;Case::Ignore&gt;( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Name&quot;</span>) )    )</div><div class="line">        {</div><div class="line">            <span class="comment">// set callback function, its return type and indicate success</span></div><div class="line">            ciFunction.Callback     = getName;</div><div class="line">            ciFunction.TypeOrValue  = <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a>;</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// For anything else, we are not responsible</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">};</div><div class="line">} <span class="comment">// namespace step5</span></div></div><!-- fragment --><p> The callback function remains untouched. Struct <b>FFCompilerPlugin</b> is changed in three aspects:</p><ul>
<li>It is to be derived from struct <b>Calculus</b>,</li>
<li>it fills the function table (just one entry so far) and</li>
<li>the own implementation of <b>TryCompilation</b> is to be removed.</li>
</ul>
<p>The resulting code of the plugin looks as follows: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>FFCompilerPlugin : <span class="keyword">public</span> <a class="code" href="namespaceaworx.html#aa79b370b084bc0a74cf61e98db6f1984">Calculus</a></div><div class="line">{</div><div class="line">    FFCompilerPlugin( <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>&amp; compiler )</div><div class="line">    : <a class="code" href="namespaceaworx.html#aa79b370b084bc0a74cf61e98db6f1984">Calculus</a>( <span class="stringliteral">&quot;FF Plug-in&quot;</span>, compiler )</div><div class="line">    {</div><div class="line">        Functions=</div><div class="line">        {</div><div class="line">            {  { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Name&quot;</span>), Case::Ignore, 0 }, <span class="comment">// the function name, letter case min. abbreviation</span></div><div class="line">                nullptr                         , <span class="comment">// no arguments</span></div><div class="line">                <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getName)      , <span class="comment">// the callback, in debug mode, the name of the callback</span></div><div class="line">                <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a>                   , <span class="comment">// return type</span></div><div class="line">                ETI                               <span class="comment">// evaluation time invokeable only</span></div><div class="line">            },</div><div class="line">        };</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="alib_expressions_tut_ffext_ident"></a></p><h2>6.2 Adding More Identifiers</h2>
<p>We can now finally continue with adding more functionality to our file filter sample. At the end of chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_cp">4.5 Implementing A Compiler Plug-In</a> we already thought about what we could add:</p><ul>
<li><b>IsDirectory:</b> Returns <code>true</code> if the directory entry is a sub-directory, <code>false</code> if it is a file.</li>
<li><b>Size:</b> Returns the size of the file built-in type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>.</li>
<li><b>Date:</b> Returns the date of the entry as built-in type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a58c1c61a83c381d1bb9426caa984f727">Types::DateTime</a>.</li>
<li><b>Permissions:</b> Returns the access rights of the file or folder.</li>
</ul>
<p>OK, let's do that! First we add some boxed values that define constants for permission rights. This is still done in the anonymous namespace, hence the following boxes are on namespace scope, just as the callback functions are:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOwnRead  = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::owner_read  ) );</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOwnWrite = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::owner_write ) );</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOwnExec  = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::owner_exec  ) );</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constGrpRead  = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::group_read  ) );</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constGrpWrite = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::group_write ) );</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constGrpExec  = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::group_exec  ) );</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOthRead  = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::others_read ) );</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOthWrite = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::others_write) );</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOthExec  = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( fs::perms::others_exec ) );</div></div><!-- fragment --><p> We are doing two casts here: The first is to get the underlying integer value from the filesystem library's constants. If we did not do this, we would introduce a new type to <b>ALib Expressions</b>. In principle, this would not be a bad thing! The advantages and disadvantages will be explained in a later chapter.<br />
 The second cast is to convert the integer value to <code>unsigned</code>. Again, if we did not do this, this would introduce a new type, namely <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html#a5fcdb87abc3548c14049e3c9b6dee7b7">boxed_uint</a>. Note that this library does not provide built-in operators for unsigned integers.</p>
<p>With these casts, the permission values become compatible with built-in binary operators <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325ae5c7b3dc6fa17e0c1d0586d1a169c77d">DefaultBinaryOperators::BitAnd</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a04306ca0b4b3ed9a5cedc16d4acbc2b8">DefaultBinaryOperators::BitOr</a> and <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a710384afa7bbbef1ec4956730c792af8">DefaultBinaryOperators::BitXOr</a> which are defined for built-in type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>, which in turn is nothing else but a <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html#ae01feb126fdae1ecf8a72a70abb605d2">boxed_int</a>!</p>
<p>Next, we add the new callback functions: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> isFolder( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span>     <span class="keyword">dynamic_cast&lt;</span>FFScope&amp;<span class="keyword">&gt;</span>( scope ).directoryEntry-&gt;status().type()</div><div class="line">            == fs::file_type::directory;</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getSize ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> (  dynamic_cast&lt;FFScope&amp;&gt;( scope ).directoryEntry-&gt;status().type()</div><div class="line">            == fs::file_type::directory )</div><div class="line">            ? 0</div><div class="line">            : static_cast&lt;boxed_int&gt;(fs::file_size( *dynamic_cast&lt;FFScope&amp;&gt;( scope ).directoryEntry ));</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getDate ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> fsTime = fs::last_write_time(  *dynamic_cast&lt;FFScope&amp;&gt;( scope ).directoryEntry );</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classaworx_1_1lib_1_1time_1_1DateTime.html#a6ad4278ead5ad5b93ac532de1d18326e">DateTime::FromEpochSeconds</a>( decltype(fsTime)::clock::to_time_t(fsTime) );</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getPerm ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( <span class="keyword">dynamic_cast&lt;</span>FFScope&amp;<span class="keyword">&gt;</span>( scope ).directoryEntry-&gt;status().permissions() );</div><div class="line">}</div></div><!-- fragment --><p> All that is left to do is "announcing" the availability of these constants and functions to class <b>Calculus</b> in the constructor of the custom plug-in:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>FFCompilerPlugin : <span class="keyword">public</span> plugins::Calculus</div><div class="line">{</div><div class="line">    FFCompilerPlugin( <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>&amp; compiler )</div><div class="line">    : <a class="code" href="namespaceaworx.html#aa79b370b084bc0a74cf61e98db6f1984">Calculus</a>( <span class="stringliteral">&quot;FF Plug-in&quot;</span>, compiler )</div><div class="line">    {</div><div class="line">        ConstantIdentifiers=</div><div class="line">        {</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerRead&quot;</span>)    , Case::Ignore, 6} , constOwnRead  },</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerWrite&quot;</span>)   , Case::Ignore, 6} , constOwnWrite },</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerExecute&quot;</span>) , Case::Ignore, 6} , constOwnExec  },</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupRead&quot;</span>)    , Case::Ignore, 6} , constGrpRead  },</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupWrite&quot;</span>)   , Case::Ignore, 6} , constGrpWrite },</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupExecute&quot;</span>) , Case::Ignore, 6} , constGrpExec  },</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersRead&quot;</span>)   , Case::Ignore, 7} , constOthRead  },</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersWrite&quot;</span>)  , Case::Ignore, 7} , constOthWrite },</div><div class="line">          { { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersExecute&quot;</span>), Case::Ignore, 7} , constOthExec  },</div><div class="line">        };</div><div class="line"></div><div class="line">        Functions=</div><div class="line">        {</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Name&quot;</span>)         , Case::Ignore, 0}, <span class="keyword">nullptr</span>, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getName ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a>   , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;IsDirectory&quot;</span>)  , Case::Ignore, 3}, <span class="keyword">nullptr</span>, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(isFolder), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a9c063c947f3dce589e49866913a7d357">Types::Boolean</a>  , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Size&quot;</span>)         , Case::Ignore, 0}, <span class="keyword">nullptr</span>, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getSize ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Date&quot;</span>)         , Case::Ignore, 0}, <span class="keyword">nullptr</span>, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getDate ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a58c1c61a83c381d1bb9426caa984f727">Types::DateTime</a>, ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Permissions&quot;</span>)  , Case::Ignore, 4}, <span class="keyword">nullptr</span>, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getPerm ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , ETI },</div><div class="line">        };</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> After all this theory and discussion, this is surprisingly simple and short code! Our file filter is already quite powerful. Here are some sample expressions and their output: </p><div class="fragment"><div class="line">--- Filter Expression {IsDirectory}: ---</div><div class="line">detail</div><div class="line">plugins</div><div class="line">details</div></div><!-- fragment --> <div class="fragment"><div class="line">--- Filter Expression {!IsDirectory &amp;&amp; size &lt; 20000}: ---</div><div class="line">expression.hpp</div><div class="line">scope.hpp</div><div class="line">expression.cpp</div><div class="line">compiler.cpp</div></div><!-- fragment --> <div class="fragment"><div class="line">--- Filter Expression {date &gt; <a class="code" href="namespaceaworx.html#af0dfbf0475dcf617b7eae4218b3277c0">DateTime</a>(2018,2,5)}: ---</div><div class="line">detail</div><div class="line">plugins</div><div class="line">details</div><div class="line">expression.hpp</div><div class="line">scope.hpp</div><div class="line">compiler.hpp</div><div class="line">compilerplugin.hpp</div><div class="line">expressionslib.cpp</div><div class="line">expression.cpp</div><div class="line">expressionslib.hpp</div><div class="line">compiler.cpp</div></div><!-- fragment --> <div class="fragment"><div class="line">--- Filter Expression {(permissions &amp; OwnerExecute) != 0}: ---</div><div class="line">detail</div><div class="line">plugins</div><div class="line">details</div></div><!-- fragment --> <div class="fragment"><div class="line">--- Filter Expression {size &gt; 81920}: ---</div><div class="line">expressionslib.cpp</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Looking at the last sample: If you are wondering why file <code>expressionslib.cpp</code> is so huge, the answer is: it contains this whole manual and tutorial that you are just reading, created with marvelous <a href="http://www.doxygen.org">Doxygen</a>!</dd></dl>
<p><a class="anchor" id="alib_expressions_tut_ffext_func"></a></p><h2>6.3 Adding Functions</h2>
<p>The latest sample expression was: </p><pre class="fragment">      size &gt; 81920
</pre><p>It would be nicer to allow: </p><pre class="fragment">      size &gt; kilobytes(80)
</pre><p>Ok, let us add three functions. Here are the callbacks: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> kiloBytes ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> argsBegin-&gt;<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>&gt;() * 1024;</div><div class="line">}</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> megaBytes ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> argsBegin-&gt;<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>&gt;() * 1024 * 1024;</div><div class="line">}</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> gigaBytes ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> argsBegin-&gt;<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>&gt;() * 1024 * 1024 * 1024;</div><div class="line">}</div></div><!-- fragment --><p> The functions unbox the first parameter. For this, due to the <em>type-safe compilation</em> of <b>ALib Expressions</b>, neither the availability nor the type of the given argument needs to be checked.</p>
<p>Next we need to define the function "signature", which is defining the number and types of arguments that the functions expect. Class <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a> allows us to do this in a very simple fashion. It is just about defining a <code>std::vector</code> filled with <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">sample boxes</a>. As all three simple functions have the same signature (they all just receive one argument of type integer), we need only one signature object: </p><div class="fragment"><div class="line">std::vector&lt;Box&gt;  SIG_INT;</div></div><!-- fragment --><p> A copy of the sample box <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a> will be added to the signature vector in the constructor of the plug-in. If we did it here in the namespace already, the software suffered from a race condition: The sample boxes in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html">Types</a> will be initialized in the static bootstrap code created by the compiler/linker. The order of creation is unspecified. Therefore, adding these boxes in the constructor assures that the sample boxes are duly initialized.</p>
<dl class="section note"><dt>Note</dt><dd>Other static tables (which we will see in the next chapter) use references to the sample boxes and hence can be defined in the C++ bootstrap code, even as <code>constexpr</code> data.</dd></dl>
<p>This was all we needed to prepare: here is the new version of the plug-in: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>FFCompilerPlugin : <span class="keyword">public</span> plugins::Calculus</div><div class="line">{</div><div class="line">    FFCompilerPlugin( <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>&amp; compiler )</div><div class="line">    : <a class="code" href="namespaceaworx.html#aa79b370b084bc0a74cf61e98db6f1984">Calculus</a>( <span class="stringliteral">&quot;FF Plug-in&quot;</span>, compiler )</div><div class="line">    {</div><div class="line">        ConstantIdentifiers=</div><div class="line">        {</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerRead&quot;</span>)    , Case::Ignore, 6}, constOwnRead  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerWrite&quot;</span>)   , Case::Ignore, 6}, constOwnWrite },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerExecute&quot;</span>) , Case::Ignore, 6}, constOwnExec  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupRead&quot;</span>)    , Case::Ignore, 6}, constGrpRead  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupWrite&quot;</span>)   , Case::Ignore, 6}, constGrpWrite },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupExecute&quot;</span>) , Case::Ignore, 6}, constGrpExec  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersRead&quot;</span>)   , Case::Ignore, 7}, constOthRead  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersWrite&quot;</span>)  , Case::Ignore, 7}, constOthWrite },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersExecute&quot;</span>), Case::Ignore, 7}, constOthExec  },</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="comment">// initialize the function signature vector</span></div><div class="line">        SIG_INT= { <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>   };</div><div class="line"></div><div class="line">        Functions=</div><div class="line">        {</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Name&quot;</span>)         , Case::Ignore, 0}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getName   ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a>   , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;IsDirectory&quot;</span>)  , Case::Ignore, 3}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(isFolder  ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a9c063c947f3dce589e49866913a7d357">Types::Boolean</a>  , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Size&quot;</span>)         , Case::Ignore, 0}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getSize   ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Date&quot;</span>)         , Case::Ignore, 0}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getDate   ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a58c1c61a83c381d1bb9426caa984f727">Types::DateTime</a>, ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Permissions&quot;</span>)  , Case::Ignore, 4}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getPerm   ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , ETI },</div><div class="line"></div><div class="line">          <span class="comment">// the new functions:</span></div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Kilobytes&quot;</span>)    , Case::Ignore, 4}, &amp;SIG_INT, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(kiloBytes ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , CTI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Megabytes&quot;</span>)    , Case::Ignore, 4}, &amp;SIG_INT, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(megaBytes ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , CTI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Gigabytes&quot;</span>)    , Case::Ignore, 4}, &amp;SIG_INT, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(gigaBytes ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , CTI },</div><div class="line">        };</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> And here is a quick test using one of the functions: </p><div class="fragment"><div class="line">--- Filter Expression {size &gt; kilobytes(80)}: ---</div><div class="line">expressionslib.cpp</div></div><!-- fragment --><p> A picky reader might now think: well it is more efficient to use expression </p><pre class="fragment">      size &gt; 81920
</pre><p> instead of </p><pre class="fragment">      size &gt; kilobytes(80)
</pre><p>because the latter introduces a function call and hence is less efficient. But this is not the case, at least not in respect to evaluating the expression against a directory entry. The evaluation time of both expressions is exactly the same, because both expressions result in exactly the same expression program.</p>
<p>The only effort for the library is at compile-time. While later chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_optimizations">11.5 Optimizations</a> will discuss the details, here we only briefly note what is going on: The definition entry of the function table for function <b>Kilobytes</b> states <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">Calculus::CTI</a> in the last column. This tells class <b>Calculus</b> that the function might be evaluated at compile time in the case that <b>all</b> arguments are constant. Because the single argument given is constant literal <code>80</code>, this condition is met. Thus, the callback function is invoked at compile time and instead of the function's address, the result value is passed back to the compiler. The compiler notes this, and replaces the original command that created the constant value <code>80</code> with the constant result value <code>81920</code>. This is why both expressions lead to exactly the same program.<br />
 In contrast to this, the identifiers of the previous chapter are marked as <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9dd3f41961ca66ba27a5c43747458b67">Calculus::ETI</a>, which means <em>"evaluation-time invokable only"</em>. The obvious rational is, that these functions access custom data in the <b>Scope</b> object and such custom data is available only when the expression is evaluated for a specific directory entry.</p>
<p><a class="anchor" id="alib_expressions_tut_ffext_ops"></a></p><h2>6.4 Adding Operators</h2>
<p>Next, some binary operator definitions are to be showcased.</p>
<p>We had implemented identifier <b>Permissions</b> to return a value of <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a> instead of returning the C++ 17 filesystem library's internal type. The advantage of this was that the built-in bitwise-boolean operators defined for integer values, could instantly be used with expressions. This was demonstrated in above sample expression: </p><pre class="fragment">   (permissions &amp; OwnerExecute) != 0
</pre><p>The disadvantage however is, that the filter expressions are not really type-safe. An end-user could pass the expression: </p><pre class="fragment">   (permissions &amp; 42) != 0
</pre><p>without receiving an error. While this is a design decision when using <b>ALib Expressions</b>, in most cases, type-safeness has definite advantages. Therefore we now change the definition of identifier <b>Permission</b> and the list of according constant identifiers as follows: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getPerm ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>FFScope&amp;<span class="keyword">&gt;</span>( scope ).directoryEntry-&gt;status().permissions();</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOwnRead  =  fs::perms::owner_read;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOwnWrite =  fs::perms::owner_write;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOwnExec  =  fs::perms::owner_exec;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constGrpRead  =  fs::perms::group_read;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constGrpWrite =  fs::perms::group_write;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constGrpExec  =  fs::perms::group_exec;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOthRead  =  fs::perms::others_read;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOthWrite =  fs::perms::others_write;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> constOthExec  =  fs::perms::others_exec;</div></div><!-- fragment --><p> In the previous version we had casted the enumeration value to an integer type. Now we are just directly boxing enumeration values of the filesystem's custom enum type.</p>
<p>To denote this type as being the return type of identifier <b>Permission</b>, we need a <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">sample box</a>. This is an easy task, we just randomly choose one enumeration element as a sample value: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> TypePermission = fs::perms::owner_read;   <span class="comment">// ...could be any other enum element as well!</span></div></div><!-- fragment --><p> With this in place, the compiler plug-in only slightly changes: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>FFCompilerPlugin : <span class="keyword">public</span> plugins::Calculus</div><div class="line">{</div><div class="line">    FFCompilerPlugin( <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>&amp; compiler )</div><div class="line">    : <a class="code" href="namespaceaworx.html#aa79b370b084bc0a74cf61e98db6f1984">Calculus</a>( <span class="stringliteral">&quot;FF Plug-in&quot;</span>, compiler )</div><div class="line">    {</div><div class="line">        ConstantIdentifiers=</div><div class="line">        {</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerRead&quot;</span>)    , Case::Ignore, 6}, constOwnRead  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerWrite&quot;</span>)   , Case::Ignore, 6}, constOwnWrite },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OwnerExecute&quot;</span>) , Case::Ignore, 6}, constOwnExec  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupRead&quot;</span>)    , Case::Ignore, 6}, constGrpRead  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupWrite&quot;</span>)   , Case::Ignore, 6}, constGrpWrite },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;GroupExecute&quot;</span>) , Case::Ignore, 6}, constGrpExec  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersRead&quot;</span>)   , Case::Ignore, 7}, constOthRead  },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersWrite&quot;</span>)  , Case::Ignore, 7}, constOthWrite },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;OthersExecute&quot;</span>), Case::Ignore, 7}, constOthExec  },</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="comment">// initialize the function signature vector</span></div><div class="line">        SIG_INT= { <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>   };</div><div class="line"></div><div class="line">        Functions=</div><div class="line">        {</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Name&quot;</span>)         , Case::Ignore, 0}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getName   ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a>   , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;IsDirectory&quot;</span>)  , Case::Ignore, 3}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(isFolder  ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a9c063c947f3dce589e49866913a7d357">Types::Boolean</a>  , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Size&quot;</span>)         , Case::Ignore, 0}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getSize   ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , ETI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Date&quot;</span>)         , Case::Ignore, 0}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getDate   ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a58c1c61a83c381d1bb9426caa984f727">Types::DateTime</a>, ETI },</div><div class="line"></div><div class="line">          <span class="comment">// change return type to TypePermission</span></div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Permissions&quot;</span>)  , Case::Ignore, 4}, nullptr , <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(getPerm   ), TypePermission  , ETI },</div><div class="line"></div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Kilobytes&quot;</span>)    , Case::Ignore, 4}, &amp;SIG_INT, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(kiloBytes ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , CTI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Megabytes&quot;</span>)    , Case::Ignore, 4}, &amp;SIG_INT, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(megaBytes ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , CTI },</div><div class="line">          { {<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Gigabytes&quot;</span>)    , Case::Ignore, 4}, &amp;SIG_INT, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>(gigaBytes ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>  , CTI },</div><div class="line">        };</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> It is only this single line of code, the definition of identifier <b>Permissions</b> that changes. The constant identifiers anyhow return a constant value of the same type and hence do not need to provide a <em>"sample box"</em>. The constant value is specifying the type already!</p>
<dl class="section note"><dt>Note</dt><dd>The other way round, the definition of object <code>TypePermission</code> could have been omitted and just one of the constant values, e.g. <code>constOwnRead</code> could have been used as the return type sample box in the function table entry.<br />
 We therefore define one unnecessary object of type <code>Box</code>, which resides in the compiled software occupying 24 bytes, in favour to better readable code. Real-life plug-ins could find other solutions, e.g. using a preprocessor macro, to save this small overhead.</dd></dl>
<p>Let's see what happens if we try to compile the previous expression: </p><div class="fragment"><div class="line">E1: &lt;expressions::BinaryOperatorNotDefined&gt;</div><div class="line">    Operator <span class="charliteral">&#39;&amp;&#39;</span> not defined <span class="keywordflow">for</span> types <span class="stringliteral">&quot;&lt;Unknown Type&gt;&quot;</span> and <span class="stringliteral">&quot;&lt;Unknown Type&gt;&quot;</span>.</div><div class="line">E2: &lt;expressions::ExpressionInfo&gt;</div><div class="line">    Expression: {(permissions &amp; OwnerExecute) != 0}</div><div class="line">                              ^-&gt;</div></div><!-- fragment --><p> The compiler throws a runtime exception, noting that operator <code>'&amp;'</code> is not defined. The first thing we want to fix is the output information of this <a class="el" href="classaworx_1_1lib_1_1lang_1_1Exception.html">Exception</a> itself. While in general it is not necessary to announce custom types explicitly, the exclamation is is that the human-readable information collected in exceptions thrown by the library benefits if we do. For just this purpose, method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a92a56e46c780a383d141f105b52176f1">Compiler::AddType</a> is available. Consequently, we add statement </p><div class="fragment"><div class="line">compiler.AddType( TypePermission, <span class="stringliteral">&quot;Permission&quot;</span> );</div></div><!-- fragment --><p> to the constructor of our plug-in.<br />
 With this in place, the exception thrown looks as follows: </p><div class="fragment"><div class="line">E1: &lt;expressions::BinaryOperatorNotDefined&gt;</div><div class="line">    Operator <span class="charliteral">&#39;&amp;&#39;</span> not defined <span class="keywordflow">for</span> types <span class="stringliteral">&quot;Permission&quot;</span> and <span class="stringliteral">&quot;Permission&quot;</span>.</div><div class="line">E2: &lt;expressions::ExpressionInfo&gt;</div><div class="line">    Expression: {(permissions &amp; OwnerExecute) != 0}</div><div class="line">                              ^-&gt;</div></div><!-- fragment --><p> This looks better, but still its an exception. What it tells us is to define the operator. We do this for a bunch of operators at once. Firstly, we need the callbacks for the operators: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> opPermAnd( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span>    argsBegin     -&gt;<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::experimental::filesystem::v1::perms&gt;()</div><div class="line">           &amp; (argsBegin + 1)-&gt;Unbox&lt;std::experimental::filesystem::v1::perms&gt;();</div><div class="line">}</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> opPermOr ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span>    argsBegin     -&gt;<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::experimental::filesystem::v1::perms&gt;()</div><div class="line">           | (argsBegin + 1)-&gt;Unbox&lt;std::experimental::filesystem::v1::perms&gt;();</div><div class="line">}</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> opPermXOr( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span>    argsBegin     -&gt;<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::experimental::filesystem::v1::perms&gt;()</div><div class="line">           ^ (argsBegin + 1)-&gt;Unbox&lt;std::experimental::filesystem::v1::perms&gt;();</div><div class="line">}</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> opPermEq ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span>    argsBegin     -&gt;<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::experimental::filesystem::v1::perms&gt;()</div><div class="line">           ==(argsBegin + 1)-&gt;Unbox&lt;std::experimental::filesystem::v1::perms&gt;();</div><div class="line">}</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> opPermNEq( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span>    argsBegin     -&gt;<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::experimental::filesystem::v1::perms&gt;()</div><div class="line">           !=(argsBegin + 1)-&gt;Unbox&lt;std::experimental::filesystem::v1::perms&gt;();</div><div class="line">}</div></div><!-- fragment --><p> This is the first time that two parameters are read in the callbacks. This is done with simple iterator arithmetics.</p>
<p>Struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a> organizes compilation information on unary and binary operators in nested hash maps. Filling in these maps is rather complicated. Therefore, a convenience function is available that fills the map using a given simple array of information entries. This array is defined in the anonymous namespace of the compilation unit: </p><div class="fragment"><div class="line"><span class="preprocessor">#if !defined(_MSC_VER)</span></div><div class="line">constexpr   <span class="comment">// This leads to a linker error on MSC.</span></div><div class="line">            <span class="comment">// Does not find ALIB_API symbol Types::Boolean when this table is constexpr. Strange!</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><a class="code" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">aworx::lib::expressions::plugins::Calculus::BinaryOpTableEntry</a>  binaryOpTable[] =</div><div class="line">{</div><div class="line">    { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;&amp;&quot;</span>) , TypePermission, TypePermission, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>( opPermAnd ), TypePermission , <a class="code" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">Calculus::CTI</a> },</div><div class="line">    { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;|&quot;</span>) , TypePermission, TypePermission, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>( opPermOr  ), TypePermission , <a class="code" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">Calculus::CTI</a> },</div><div class="line">    { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;^&quot;</span>) , TypePermission, TypePermission, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>( opPermXOr ), TypePermission , <a class="code" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">Calculus::CTI</a> },</div><div class="line">    { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;==&quot;</span>), TypePermission, TypePermission, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>( opPermEq  ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a9c063c947f3dce589e49866913a7d357">Types::Boolean</a> , <a class="code" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">Calculus::CTI</a> },</div><div class="line">    { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;!=&quot;</span>), TypePermission, TypePermission, <a class="code" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a>( opPermNEq ), <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a9c063c947f3dce589e49866913a7d357">Types::Boolean</a> , <a class="code" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">Calculus::CTI</a> },</div><div class="line">};</div></div><!-- fragment --><p> For information about the meaning of the values of the table, consult the documentation of <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">Calculus::BinaryOpTableEntry</a>. But looking at the code, and reflecting what was already presented in this tutorial, the meaning should be is quite self-explanatory. In just should be noted, that also for operators, flags <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">Calculus::CTI</a> or <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9dd3f41961ca66ba27a5c43747458b67">Calculus::ETI</a> may be given. If, like in our case, <b>CTI</b> is specified, then in the moment that both operands are constant, the compiler will optimize and the callbacks are pruned. This means, that for example sub expression: </p><pre class="fragment">   ( OwnerRead | GroupRead | OwnerExecute | GroupExecute )
</pre><p>will be reduced to one single constant in the compiled expression program, because each of the identifier returns a constant value.</p>
<p>Finally, in the constructor of the plug-in we now add the following line of code: </p><div class="fragment"><div class="line">AddBinaryOps( binaryOpTable );</div></div><!-- fragment --><p>With this in place, the expression now compiles in a type-safe way: </p><div class="fragment"><div class="line">--- Filter Expression {(permissions &amp; OwnerExecute) == OwnerExecute}: ---</div><div class="line">detail</div><div class="line">plugins</div><div class="line">details</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The expression got slightly changed from: <pre class="fragment"> (permissions &amp; OwnerExecute) != 0
</pre></dd></dl>
<p>to </p><pre class="fragment"> (permissions &amp; OwnerExecute) == OwnerExecute
</pre><p>which is logically the same. To allow the first version, a replacement identifier for integer value <code>0</code>, e.g. <b>NoPermission</b> had to be inserted to the plug-in.</p>
<p><a class="anchor" id="alib_expressions_tut_ffext_autocasts"></a></p><h2>6.5 Implementing Auto-Casts</h2>
<p>To finalize this tutorial part of the documentation, a last quite powerful feature of <b>ALib Expressions</b> is presented. We re-think again what we did in the previous section:</p><ul>
<li>We changed identifier <b>Permissions</b> to return values of custom type.</li>
<li>This "disabled" the built-in bitwise boolean operators and therefore,</li>
<li>we implemented operators for the custom type.</li>
</ul>
<p>There is a different solution available to solve the problem, called "auto casting". If no compiler plug-in compiles a binary operator for a given pair of operands, then the compiler invokes method <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a87336db1fa6d0310add5cd5c21190783">CompilerPlugin::TryCompilation(CIBinaryAutoCast&amp;)</a> for each plugin. In the case that one of the plug-ins positively responds by providing one or two <em>"cast functions"</em>, then the compiler inserts the cast functions for one or both arguments and performs the search for an operator of this now new pair of types a second time. </p><dl class="section note"><dt>Note</dt><dd>It is a design decision of <b>ALib Expressions</b> that this is not done a third or fourth time.</dd></dl>
<p>This approach obviously has the following consequences:</p><ul>
<li>"Permissions" is a distinguishable type.</li>
<li>Specific functions and operators using the type can be defined.</li>
<li>Existing binary operators for integers become available to the type in addition, but with a lower priority. (Because auto-casting is performed only if no direct match exists.)</li>
<li>The behaviour becomes "type-unsafe" again, the same as in the first implementation, when identifier <b>Permission</b> returned an integer type. For example expression <code>{ Permissions == 0 }</code> is compiled and executed.</li>
</ul>
<p>To implement this, we revert the most recent code changes (the operator callbacks, the binary operator table and the single line of code that feeds the table to parent <b>Calculus</b>).</p>
<p>As a replacement, we add the following callback function which casts a permission type to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> perm2Int ( <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a><span class="keyword">&gt;</span>( argsBegin-&gt;Unbox&lt;fs::perms&gt;() );</div><div class="line">}</div></div><!-- fragment --><p> A cast function takes one parameter of the originating type and returns the converted value. In this sample, this is trivial. Sometimes more complex code is needed. Casting one type to another might even include memory allocation to create a certain custom type "automatically" from a given value. Such allocations, have to be performed using the provided, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a> object, which optionally is of custom type. In the case that casting is done at compile-time (due to optimization) such allocations are then created in the compile-time scope which survives the expression's life cycle.</p>
<p>With this casting callback function in place, we add the following method to the custom plugin: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> TryCompilation( CIBinaryAutoCast&amp; ciAutoCast )<span class="keyword">    override</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="comment">// we don&#39;t cast for conditional operator &quot;Q ? T : F&quot;</span></div><div class="line">    <span class="keywordflow">if</span>( ciAutoCast.BinaryOp.IsNull() )</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// cast LHS</span></div><div class="line">    <span class="keywordflow">if</span>( ciAutoCast.ArgsBegin-&gt;IsType&lt;fs::perms&gt;() )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>( ciAutoCast.LhsIsConst )</div><div class="line">        {</div><div class="line">            <span class="comment">// compile-time invocation</span></div><div class="line">            ciAutoCast.TypeOrValue= perm2Int( ciAutoCast.CompileTimeScope,</div><div class="line">                                              ciAutoCast.ArgsBegin,</div><div class="line">                                              ciAutoCast.ArgsEnd           );</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            ciAutoCast.Callback    = perm2Int;</div><div class="line">            ciAutoCast.TypeOrValue = <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>;</div><div class="line">            <a class="code" href="group__GrpALibMacros.html#ga5f6b7763c5f5722d7f178c04540aba9e">ALIB_DBG</a>( ciAutoCast.DbgCallBackName= <span class="stringliteral">&quot;perm2Int&quot;</span>; )</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// cast RHS</span></div><div class="line">    <span class="keywordflow">if</span>( (ciAutoCast.ArgsBegin + 1)-&gt;IsType&lt;fs::perms&gt;() )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>( ciAutoCast.RhsIsConst )</div><div class="line">        {</div><div class="line">            <span class="comment">// compile-time invocation</span></div><div class="line">            ciAutoCast.TypeOrValueRhs= perm2Int( ciAutoCast.CompileTimeScope,</div><div class="line">                                                 ciAutoCast.ArgsBegin + 1,</div><div class="line">                                                 ciAutoCast.ArgsEnd           );</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            ciAutoCast.CallbackRhs    = perm2Int;</div><div class="line">            ciAutoCast.TypeOrValueRhs = <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Types::Integer</a>;</div><div class="line">            <a class="code" href="group__GrpALibMacros.html#ga5f6b7763c5f5722d7f178c04540aba9e">ALIB_DBG</a>( ciAutoCast.DbgCallBackNameRhs= <span class="stringliteral">&quot;perm2Int&quot;</span>; )</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For auto-cast, struct <b>Calculus</b> does not provide helper tools. The overridden method <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a87336db1fa6d0310add5cd5c21190783">TryCompilation(CIBinaryAutoCast&amp;)</a> therefore originates from grandparent struct <b>CompilerPlugin</b>.</dd></dl>
<p>Likewise with previous solution, our sample expression compiles with the very same result: </p><div class="fragment"><div class="line">--- Filter Expression {(permissions &amp; OwnerExecute) == OwnerExecute}: ---</div><div class="line">detail</div><div class="line">plugins</div><div class="line">details</div></div><!-- fragment --><p> However, unlike the recent implementation, compilation is not type-safe in respect to mixing the type with integer values: </p><div class="fragment"><div class="line">--- Filter Expression {(permissions &amp; 64) != 0}: ---</div><div class="line">detail</div><div class="line">plugins</div><div class="line">details</div></div><!-- fragment --><p> But still, if we had a certain function or operator that uses arguments of type <b>TypePermission</b>, with this solution, again such function or operator would be fully type-safe. It would not accept numbers, because the auto-cast is not defined the other way round.</p>
<p>As a conclusion it can be noted that auto-casting is often a good compromise between adding a lot of custom specific operators and full type-safeness.</p>
<p><a class="anchor" id="alib_expressions_builtin"></a></p><h1>7. Built-In Expression Functionality</h1>
<p>The types, identifiers, functions and operators presented in this manual section are to be named "built-in" in that respect, that they are available by default. But the truth is, that they are implemented using the very same technique of providing compiler plug-ins, that has been explained in the previous section. This way, this built-in logic is fully optional and can be easily switched off, partly or completely.</p>
<p>For doing so, class <b>Compiler</b> offers a set of configurable flags, gathered in member <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#af625946a92a359feef1093b444a5e343">Compiler::CfgBuiltInPlugins</a>. The flags are declared with enumeration <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#adf0fc1394cdd3422862ec0ece2ba9b43">Compiler::BuiltInPlugins</a> and are evaluated in method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a>. Field <b>CfgBuiltInPlugins</b> defaults to <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#adf0fc1394cdd3422862ec0ece2ba9b43a5fb1f955b45e38e31789286a1790398d">Compiler::BuiltInPlugins::ALL</a>. With this information, it is easy to understand that the following code of setting up a compiler: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#af625946a92a359feef1093b444a5e343">CfgBuiltInPlugins</a>= <a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#adf0fc1394cdd3422862ec0ece2ba9b43ab50339a10e1de285ac99d4c3990b8693">Compiler::BuiltInPlugins::NONE</a>;</div><div class="line">compiler.SetupDefaults();</div></div><!-- fragment --><p> leads to a compiler that does not compile anything.</p>
<p>It should be very seldom that disabling of one or more of the built-in compiler plug-ins is needed. Here are some rationals for this statement:</p><ul>
<li>While in a certain domain-specific use case scenario, e.g. string handling or math functions are not needed, it should not impose a negative effect if they are provided.</li>
<li>The compiler plug-ins are invoked by the compiler in an ordered fashion. Custom plug-ins have highest priority. This way, selected functionality can be "overridden" by a custom plug-in by just compiling permutations operators/function names and their arguments, which otherwise would be compiled by a lower-prioritized, built-in plug-in.</li>
<li>The availability of unused functionality provided by unnecessary plug-ins has no effect on the evaluation-time of expressions. There is only a very small downside in compile-time.</li>
</ul>
<p><a class="anchor" id="alib_expressions_builtin_completeness"></a></p><h2>7.1 Completeness Of Built-In Functionality</h2>
<p>In the default setup (all built-in plug-ins are active), <b>ALib Expressions</b> is considered to be <em>"complete"</em> in respect to providing all reasonable operators for permutations of arguments of all built-in types.</p>
<p>This manual does not elaborate about implications in respect to such <b>completeness</b> in the case that selected built-in plug-ins are omitted. It is up to the user of the library to think about such implications and provide alternatives to the built-in functionality that is decided to be left out.<br />
 On the same token, there is no mechanism to disable the compilation of selected built-in compiler plug-ins and with that, their inclusion in the library code. If such is to be achieved in favour to code size, a custom build-process has to be set up.</p>
<p><a class="anchor" id="alib_expressions_builtin_types"></a></p><h2>7.2 Types</h2>
<p>As explained in previous sections of this manual, the introduction of types to <b>ALib Expressions</b> is performed in an implicit fashion: New types are introduced in the moment a callback function chooses to return one and the corresponding compiler plug-in announces this return type of a callback to the compiler. This all happens at compilation-time only.</p>
<p>Therefore, the set of built-in types are resulting from the set of built-in compiler plug-ins. Nevertheless, the library design opted to collect sample boxes for the set in struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html">Types</a>, which is defined right in namespace <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html">aworx::lib::expressions</a>.</p>
<p>It is notable that no built-in support for unsigned integral values is provided. In the unlikely event that this is needed for any reason, such support can quite easily by implemented by a custom plug-in. As a jump-start, the source code of class <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html">Arithmetics</a> might by used.</p>
<p>Furthermore, all possible sizes of C++ integral values are collectively casted to <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html#ae01feb126fdae1ecf8a72a70abb605d2">Boxed Integer</a>, which usually equals a 64-bit signed integer value.</p>
<p>Finally, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#aa813c9126cceb582e44aa5a6f4c8a541">Types::Float</a> is internally implemented using C++ type <code>double</code>. No (built-in!) support for C++ types <code>float</code> and <code>long double</code> is provided.</p>
<p>This reduction of used types simplifies the built-in plug-ins dramatically and reduce the libraries footprint, as it reduces the number of type-permutations to a reasonable minimum.</p>
<p>Due to the type-safe compilation, adding custom types has no impact on evaluation performance of operators and functions that use the built-in types (or other custom types).</p>
<p><a class="anchor" id="alib_expressions_builtin_arithmetics"></a></p><h2>7.3 Arithmetics</h2>
<p>What is called <em>"arithmetics"</em> with this library comprises the implementation of unary and binary operators for permutations of types <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a9c063c947f3dce589e49866913a7d357">Boolean</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Integer</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#aa813c9126cceb582e44aa5a6f4c8a541">Float</a>.</p>
<p>The operators and some few identifiers and functions are collectively implemented and documented with plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html">Arithmetics</a>.</p>
<p><a class="anchor" id="alib_expressions_builtin_math"></a></p><h2>7.4 Math Functions</h2>
<p>Fundamental mathematical functions like trigonometrical, logarithms, etc. are collectively implemented and documented with plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Math.html">Math</a>.</p>
<p><a class="anchor" id="alib_expressions_builtin_string"></a></p><h2>7.5 String Expressions</h2>
<p>Plug-In <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">Strings</a> provides quite powerful string operations. The library here benefits tremendously from underling modules <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">ALib Strings</a> and <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a>.</p>
<p>For example, operator <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325aec211f7c20af43e742bf2570c3cb84f9">Add</a> (<code>'+'</code>) allows to concatenate two strings, but also a string with "any" other built-in or custom type. The way it is achieved that the plug-in is enabled to concatenate even unknown custom types to strings (without the need to define an overloaded expression operator for string and the custom type), is by leveraging boxing interface <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a>. Consult the <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">user manual of ALib Boxing</a> for details on how to implement this interface for your custom types.</p>
<p>A list of all features, including wildcard (using <code>'*'</code> and <code>'</code>?') and regular expression matching, as well as a powerful <b>Format(String, ...)</b> function is given with <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">the plug-ins' documentation</a>.</p>
<p><a class="anchor" id="alib_expressions_builtin_datetime"></a></p><h2>7.6 Date And Time Expressions</h2>
<p>The built-in types <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a58c1c61a83c381d1bb9426caa984f727">Types::DateTime</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a51d5b447dda0a9740c8d207617a86d89">Types::Duration</a> represent <b>ALib</b> classes <a class="el" href="classaworx_1_1lib_1_1time_1_1DateTime.html">DateTime</a> and <a class="el" href="classaworx_1_1lib_1_1time_1_1TimePointBase_1_1Duration.html">TimePointBase::Duration</a> of the same name. The corresponding Expression functionality is implemented with plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1DateAndTime.html">DateAndTime</a>.</p>
<p>If a user of <b>ALib Expressions</b> prefers to use different, own or 3rd-party types, then support for such type needs to be implemented by a custom plug-in. Such implementation may be created by copying the source code of built-in plug-in <b>DateAndTime</b> and replacing all corresponding code lines to work with the desired date and time types. If wanted, some or all identifiers might remain the same and even if the built-in plug-in may be kept active. In the latter case, no clash of identifiers would occur. This is because the custom plug-in would usually be inserted to the compiler with a higher priority than the priority of the built-in plug-in.</p>
<p><a class="anchor" id="alib_expressions_builtin_ternary"></a></p><h2>7.7 Conditional Operator</h2>
<p>The conditional operator <code>Q ? T : F</code> is the only ternary operator, and (for technical reasons) not implemented as a plug-in. In contrast, it is hard-coded in the details of this library's implementation.<br />
 This is not considered a huge limitation, as there is no obvious use case, why this operator should be overloaded: It's meaning is the same for any use of types.</p>
<p>The conditional argument <code>'Q'</code>, which of-course could result in a value of any built-in or custom type, is interpreted as a boolean value using boxing interface <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsTrue.html">IIsTrue</a>. While a default implementation for this boxing interface exists that evaluates any custom type, a provision of this interface for a custom type may be used to override this default implementation.</p>
<p>For result arguments <code>'T'</code> and <code>'F'</code>, the only requirement that needs to be fulfilled is that both are of the same type or that a compilation rule for auto-casting them to a joint type exists.</p>
<p>This means:</p><ul>
<li>Support for custom types is given, if both arguments share the same custom type.</li>
<li>To support a mix of at least one custom types with a different built-in or custom type, corresponding auto-cast mechanics have to be provided.</li>
</ul>
<p>A variant of the conditional operator is the so called "Elvis Operator", <code>A ?: B</code>. This variant is duly supported by this library and compiled as binary operator <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325af4f67bf86b50df1605ff772c9da52c09">DefaultBinaryOperators::Elvis</a> just as any other operator is - including that the compiler tries to perform an auto-cast if no compiler plug-in matches a type combination is defined.</p>
<p>Built-in compiler plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1ElvisOperator.html">ElvisOperator</a> handles this operator for built-in types as well as for custom-types, in the case that <code>'A'</code> and <code>'B'</code> share the same type.</p>
<p>Similar to the conditional operator, the default implementation invokes boxing interface <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsTrue.html">IIsTrue</a> on argument <code>'A'</code> and decides whether <code>'A'</code> or <code>'B'</code> is chosen. This default behaviour can be changed by just implementing the elvis operator, likewise any other operator would be implemented.</p>
<p><a class="anchor" id="alib_expressions_builtin_autocast"></a></p><h2>7.8 Auto Casts</h2>
<p>Built-in compiler plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1AutoCast.html">AutoCast</a> offers casting proposals to the compiler in respect to the built-in types.</p>
<p>For details on the casting facilities, consult the classes' <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1AutoCast.html">documentation</a>.</p>
<p><a class="anchor" id="alib_expressions_scopes"></a></p><h1>8 Scopes</h1>
<p>As it was demonstrated in <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_scope">4.4 Exposing The Directory Entry To ALib Expressions</a>, a customized (derived) version of struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a> is passed to method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a0b4979bb94b656999acc80e148d9da5f">Expression::Evaluate</a>, and the very same object is passed to the callback functions, when the expression program is executed by the built-in virtual machine. As a result, a custom callback function can rely on the fact that it is possible to dynamically cast parameter <code>scope</code> back to the custom type and access <em>"scoped data"</em> which exposes an interface into the application that uses <b>ALib Expressions</b>.</p>
<p>This is the most obvious and also intuitively well understandable role of struct <b>Scope</b>. But there are other important things that this class provides.</p>
<dl class="section note"><dt>Note</dt><dd>Struct <b>Scope</b> is a good (or bad!) sample of this library's design principle discussed in chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_bauhaus">3.4 Bauhaus Code Style</a>.). Remember, that the software that uses <b>ALib Expressions</b> is supposed to hide struct <b>Scope</b> with all it's publicly accessible members, same as all other details of this library.<br />
 In other words: not all members that are accessible should be accessed. Some care has to be taken.</dd></dl>
<p><a class="anchor" id="alib_expressions_scopes_stack"></a></p><h2>8.1 Provision Of The Evaluation Stack</h2>
<p>Struct <b>Scope</b> incorporates field <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#ad2d2c7c0c600054104cfe3da78ea2f8b">Scope::Stack</a>. This vector is used by the built-in virtual stack-machine implementation during evaluation. This way, it was possible to implement the machine's execution method without using any data exposed by the machine (in fact, the machine is a pure static class).</p>
<p>The important consequence is: </p><dl class="section user"><dt></dt><dd><b>A <b>Scope</b> object must not be used in parallel execution threads, for evaluating two different expressions. If two scopes are used, the parallel evaluation of two different expressions is allowed.</b></dd></dl>
<p>It is always a good design principle to pack an instance of a scope for evaluation together with one expression into a containing, encapsulating object. This was demonstrated in section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ff_generic">4.2 Adding Generic Ingredients Needed For Expression Evaluation</a> when sample type <b>FileFilter</b> was introduced.</p>
<p><a class="anchor" id="alib_expressions_scopes_allocations"></a></p><h2>8.2 Scope Allocations</h2>
<p>A next important role that struct <b>Scope</b> fulfills is to provide fields that allow to <b>allocate temporary data</b>. With a simple arithmetic expression like this: </p><pre class="fragment">   1 * 2 + 3
</pre><p>no allocations are needed. The reason is that the intermediate result of the multiplication can be and is stored as a <em>value</em> in the <b>Box</b> object that the operator <code>'*'</code> returned. However, an expression with string operations like this: </p><pre class="fragment">   "Hello " + "beautiful " + "world!"
</pre><p>incorporates intermediate results (in this case <code>"Hello beautiful "</code>). Such intermediate results have to be allocated somewhere, because the <b>Box</b> object stores only a pointer to a character array, together with its length. In fact, the final result string has as well be allocated, because again, the result of the expression is a boxed string which needs allocation.</p>
<p>For this reason, struct <b>Scope</b> incorporates some built-in "facilities" to allocate data. Those are briefly:</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#ad0ebbccbe75ad5e3ea6596fcfd007566">Scope::Memory</a><br />
 This is a simple <b>ALib</b> block memory allocator. It is especially useful to allocate string data. This purpose is furthermore supported by helper class <a class="el" href="classaworx_1_1lib_1_1expressions_1_1plugins_1_1ScopeString.html">ScopeString</a> which uses this allocator internally.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#a03cd5024b536bda674581154079c37da">Scope::Resources</a><br />
 A simple vector of pointers to objects of type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1ScopeResource.html">ScopeResource</a>. This type is an extremely simple container. All it does ist to provide a virtual destructor which deletes data contained in custom derived types.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#a7329c656aba4a8682f7395e63464e217">Scope::NamedResources</a><br />
 A hash map of pointers to objects of type<a class="el" href="structaworx_1_1lib_1_1expressions_1_1ScopeResource.html">ScopeResource</a>. Its purpose and use will be discussed in a later section.</li>
</ul>
<p>All objects allocated are deleted with method <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#aa71d36872f416feaa853788a7a7a7ef8">Scope::Clear</a>, which is internally invoked when appropriate.</p>
<p>Of-course, custom specializations of the class, which anyway have to be created for the purposes discussed before, may provide other fields that can be used to allocate memory resources, tailored to the type of objects needed. But it has to be made sure, that method <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#aa71d36872f416feaa853788a7a7a7ef8">Scope::Clear</a> is overridden to free all resources. And: when overriding this method, it has to be assured that the original virtual function of the base class is invoked as well, because built-in plug-ins allocate resources by using the built-in features of struct <b>Scope</b>.</p>
<p><a class="anchor" id="alib_expressions_scopes_ctscope"></a></p><h2>8.3 Compile-Time Scopes</h2>
<p>So far, we talked only about the instance of struct <b>Scope</b> that is provided to method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a0b4979bb94b656999acc80e148d9da5f">Expression::Evaluate</a>. But there is a second scope object created, that is called the "compile-time scope". If you reconsider the sample expression from the previous section: </p><pre class="fragment">   "Hello " + "beautiful " + "world!"
</pre><p> All three string type arguments are constant string literals. The operator <code>'+'</code> is implemented with built-in compiler plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">Strings</a>, which defines the operator being "compile-time evaluable". As explained in the tutorial section, this means that in the moment all arguments are constant, struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a> (the parent of struct <b>Strings</b>), invoked the operator's callback function at compile time. Callback functions however rely on a scope object, e.g. for memory allocation, as just discussed.</p>
<p>For this reason, a compile-time singleton of type <b>Scope</b> is created and provided to the callback functions during compilation of constant terms. Intermediate results may this way be stored either in the compile-time scope instance or in the evaluation-time instance. The latter is cleared upon each evaluation, the data allocated in the compile-time scope is cleared only with the deletion of the expression.</p>
<p><a class="anchor" id="alib_expressions_scopes_custom_ctscope"></a></p><h2>8.4 Custom Compile-Time Scopes</h2>
<p>If at least one custom callback function that is compile-time invokable uses custom allocation tools which are only provided by a corresponding custom version of the type, then - ooops!</p>
<p>To support this scenario, a derived version of class <b>Compiler</b> has to be created, which re-implements virtual method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a9efcd8697703ecbefa94d59252e4c6cc">getCompileTimeScope</a>. This method is internally called with method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a48950a23ca943cebf76688bc80c0e40b">Compile</a> to allocate the the compile-time scope.</p>
<p>If the conditions described above are met, then this method has to be overwritten to return a heap-allocated custom scope object. This object will internally be deleted with the deletion of the expression.</p>
<p>Custom callback functions can then rely on the fact that the compile-time scope object can be dynamically casted to the custom type and use its custom allocation facilities.</p>
<p><a class="anchor" id="alib_expressions_scopes_ctresources"></a></p><h2>8.5 Using Compile-Time Resources At Evaluation Time</h2>
<p>So far, things had been still quite straight forward. Let us quickly recap what was said about scopes:</p><ul>
<li>Scopes are used to provide evaluation time data from the application.</li>
<li>Scopes are used to allocate data for intermediate and final expression result objects.</li>
<li>Due to the fact that <b>ALib Expressions</b> provides the feature of compile-time optimization, a compile-time scope is created with the compilation of the expression.</li>
<li>Of-course, any evaluation specific field of custom scopes which provide access to the application data are <em>nulled</em> in the compile-time scope and accessing them is unspecified behaviour (usually the program crashes).</li>
<li>The life-cycle of the compile-time scope is bound to the life-cycle of a compiled expression. Its method <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#aa71d36872f416feaa853788a7a7a7ef8">Scope::Clear</a> is only called with destruction.</li>
<li>The life-cycle of the evaluation-time scope is user dependent. It is strongly recommended to create one object and reuse this object for each evaluation (as sampled in the tutorial). Its <b>Clear</b> method is automatically (internally) called at the beginning of method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a0b4979bb94b656999acc80e148d9da5f">Expression::Evaluate</a>. This also means, that the expression result object of the previous call to <b>Evaluate</b> becomes invalid (if it is relies on evaluation-time allocated data.</li>
</ul>
<p>This concept of having two separated scope objects in certain cases is extended. In general terms it could be phrased as follows:</p>
<dl class="section user"><dt>Compiler plug-ins may choose to create resources at compile time, which are not intermediate</dt><dd>constant results, but which are objects used at evaluation time.</dd></dl>
<p>To support this, two further fields are found in class <b>Scope</b>:</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#aed843e776cc359a842b37e5a4491e84a">CTScope</a><br />
 During evaluation, this pointer of the evaluation time scope, provides access to the compile-time scope. In contrast to this, at compilation-time this field equals <code>nullptr</code>, because the given scope object already is the compile-time scope.<br />
 (Consequently, simple inline method <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#ab71ec93e1c7127735d3b6e17dd393ffa">Scope::IsCompileTime</a> just checks this pointer for being <code>nullptr</code>.)</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html#a7329c656aba4a8682f7395e63464e217">NamedResources</a><br />
 This hash-map provides access to "named" resources. It is provided to allow creation and storage of resources at compile time, which are then retrieved during evaluation using a specific resource name.</li>
</ul>
<p>The following sample taken from the built-in compiler plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">Strings</a> nicely demonstrates what can be achieved with this concept.</p>
<p><a class="anchor" id="alib_expressions_scopes_ctrressample"></a></p><h2>8.6 Sample For Using Compile-Time Resources At Evaluation Time</h2>
<p>Built-in compiler plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">Strings</a> provides expression function <b>WildcardMatch</b>, which matches a pattern against a given string. For example, expression </p><pre class="fragment">       WildcardMatch( "MyPhoto.jpg", "*.jpg" )
</pre><p>evaluates to <code>true</code>. </p><dl class="section note"><dt>Note</dt><dd>The function is alternatively available through overloaded binary operator <code>'*'</code>. The sample expression of above can this way also be phrased: <pre class="fragment">    "MyPhoto.jpg" * "*.jpg"
</pre></dd></dl>
<p>To implement this function, internally helper class <a class="el" href="classaworx_1_1lib_1_1strings_1_1util_1_1WildcardMatcherBase.html">WildcardMatcher</a> provided by underlying library module <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">ALib Strings</a> is used. For performance reasons, this class implements a two-phased approach: First, the "pattern" string (here <code>"*.jpg"</code>) is parsed and translated into a set of internal information. Then, for a performing a single match, this internal information is used, which is much faster than if the pattern still had to be parsed.</p>
<p>In the most cases, an expression string given by an end-user would contain a non-constant string to match and a constant pattern string, like in the following expression: </p><pre class="fragment">       filename * "*.jpg"
</pre><p>In this case, it would be most efficient, if the pattern string was passed to an instance of <b>ALib</b> class <b>WildcardMatcher</b> at compile time, while at evaluation time this exact matcher would be used to perform the match.</p>
<p>This setup already explains it all:</p><ul>
<li>The instance of <b>WildcardMatch</b> is to be created at compile time and stored as a named resource in the compile-time scope object. For the name (storage key) of the resource, the pattern string is used.</li>
<li>At evaluation time, the object is retrieved by accessing the named resources of the compile-time scope and the match is performed against the first given function argument, while the second argument is used to search a named resource. If one is found, the already set-up matcher is used.</li>
</ul>
<p>You might not be interested in the details of the implementation and skip the rest of the chapter. The code becomes a little more complex than usual plug-in code. The reason is that helper struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a> does not provide a mechanism to support this.</p>
<p>We start with defining the resource type, derived from struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1ScopeResource.html">ScopeResource</a>. This simply wraps a matcher object and its sole purpose is to have a virtual destructor that later allows internal code to delete the matcher: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ScopeWildcardMatcher : <span class="keyword">public</span> ScopeResource</div><div class="line">{</div><div class="line">    <span class="comment">// the matcher object</span></div><div class="line">    <a class="code" href="namespaceaworx.html#a3199725daade54d17c4e500ba259584e">WildcardMatcher</a> matcher;</div><div class="line"></div><div class="line">    <span class="comment">// virtual destructor, implicitly deletes the matcher.</span></div><div class="line">    <span class="keyword">virtual</span> ~ScopeWildcardMatcher()  {}</div><div class="line">};</div></div><!-- fragment --><p> Next, method <b>TryCompilation</b> needs to be overwritten to be able to fetch the function: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> Strings::TryCompilation( CIFunction&amp; ciFunction )</div><div class="line">{</div><div class="line">    <span class="comment">// invoke parent</span></div><div class="line">    <span class="keywordflow">if</span>( !<a class="code" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a098fc2b68c8d9a17aeaa2dd8dff31e75">Calculus::TryCompilation</a>( ciFunction ) )</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> The methods starts by invoking the original implementation of parent <b>Calculus</b>. Because the wildcard function is compile-time invokable, in the (unlikely) case that both parameters are constant, a constant value would be returned. Only if one of the parameters is non-constant, then the callback is set to callback function <code>wldcrd</code>.<br />
 This <em>if-statement</em> selects this case that we are interested in: </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span>( ciFunction.Callback == wldcrd &amp;&amp; (ciFunction.ArgsBegin + 1)-&gt;Length() &gt; 0)</div><div class="line">    {</div></div><!-- fragment --><p> If the second parameter is not an empty string, obviously a constant value was given!<br />
 Now, we extract the pattern string and combine it with prefix <code>"_wc"</code> to a key string to store the resource: </p><div class="fragment"><div class="line">        <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> pattern= (ciFunction.ArgsBegin + 1)-&gt;Unbox&lt;String&gt;();</div><div class="line">        <a class="code" href="namespaceaworx.html#a025746210fce27b298b209d96e9d2678">String128</a> keyString(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;_wc&quot;</span>));</div><div class="line">        <a class="code" href="assert_8hpp.html#a30e363647f8ea56f0af8e834768548bc">ALIB_WARN_ONCE_PER_INSTANCE_DISABLE</a>( keyString, ReplaceExternalBuffer )</div><div class="line">        keyString &lt;&lt; pattern;</div></div><!-- fragment --><p> It may happen, that an expression uses the same pattern twice. In this case, the same matcher object can be used. Therefore, it has to be checked, if a matcher with that same pattern already exists. If not, it is created: </p><div class="fragment"><div class="line">        <span class="keyword">auto</span> storedMatcher=  ciFunction.CompileTimeScope.NamedResources.find( keyString );</div><div class="line">        <span class="keywordflow">if</span>( storedMatcher == ciFunction.CompileTimeScope.NamedResources.end() )</div><div class="line">        {</div><div class="line">            ScopeWildcardMatcher* matcher= <span class="keyword">new</span> ScopeWildcardMatcher();</div><div class="line">            matcher-&gt;matcher.Compile( pattern );</div><div class="line">            ciFunction.CompileTimeScope.NamedResources[<a class="code" href="namespaceaworx.html#ad7b7d1a2e78da4e5f66f588a6ba52798">ScopeString</a>( ciFunction.CompileTimeScope, keyString, 0 )]= matcher;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div></div><!-- fragment --><p> After that, <b>TryCompilation</b> exits, signaling compilation success. All that is left to do is the implementation of the callback function. At the beginning the function checks if this is an evaluation-time invocation. In this case, it searches a named resource according to the given pattern string. If this is found, the function uses the resourced matcher and exits: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> wldcrd( <a class="code" href="namespaceaworx.html#a7a9bb9d8d2ec21dd9193842b84cbe1f1">Scope</a>&amp; scope, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a>  args, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> <a class="code" href="namespaceaworx_1_1lib_1_1util.html#a7d91cd6fddd41b6f724ce096caab2d67">end</a> )</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> haystack= STR(ARG0);</div><div class="line">    <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> pattern = STR(ARG1);</div><div class="line">    <a class="code" href="namespaceaworx.html#adcd43e032e2fb23c28fb20d22ccd2382">Case</a>   sensitivity= ( <a class="code" href="namespaceaworx_1_1lib_1_1util.html#a7d91cd6fddd41b6f724ce096caab2d67">end</a>-args &gt; 2 &amp;&amp; BOL(ARG2) ) ? Case::Ignore</div><div class="line">                                                      : Case::Sensitive;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>( !scope.IsCompileTime() )</div><div class="line">    {</div><div class="line">        <span class="comment">// Search for resource named &quot;_wc&quot;+ pattern.</span></div><div class="line">        <a class="code" href="namespaceaworx.html#a025746210fce27b298b209d96e9d2678">String128</a> keyString(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;_wc&quot;</span>));</div><div class="line">        <a class="code" href="assert_8hpp.html#a30e363647f8ea56f0af8e834768548bc">ALIB_WARN_ONCE_PER_INSTANCE_DISABLE</a>( keyString, ReplaceExternalBuffer )</div><div class="line">        keyString &lt;&lt; pattern;</div><div class="line">        <span class="keyword">auto</span> storedMatcher=  scope.CTScope-&gt;NamedResources.find( keyString );</div><div class="line">        <span class="keywordflow">if</span>( storedMatcher != scope.CTScope-&gt;NamedResources.end() )</div><div class="line">        {</div><div class="line">            ScopeWildcardMatcher* matcher= <span class="keyword">dynamic_cast&lt;</span>ScopeWildcardMatcher*<span class="keyword">&gt;</span>( storedMatcher-&gt;second );</div><div class="line">            <span class="keywordflow">return</span> matcher-&gt;matcher.Match( haystack, sensitivity );</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> If either this is compile-time or no resource matcher was found (which indicates that the pattern argument is not constant), the match is performed using a local, one-time matcher object. </p><div class="fragment"><div class="line">    <span class="comment">// This is either compile time or the pattern string is not constant</span></div><div class="line">    {</div><div class="line">        <a class="code" href="namespaceaworx.html#a3199725daade54d17c4e500ba259584e">WildcardMatcher</a> matcher( pattern );</div><div class="line">        <span class="keywordflow">return</span> matcher.Match( haystack, sensitivity );</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="alib_expressions_operators"></a></p><h1>9. Operators</h1>
<p><a class="anchor" id="alib_expressions_operators_default"></a></p><h2>9.1 Built-In And Custom Operators And</h2>
<p>In its default configuration, module <b>ALib Expressions</b> parses and compiles an almost complete set of operators known from the C++ language. Not supported by default are for example assignment operators like e.g. <code>'+='</code> or increments <code>'++'</code>. Operators included are:</p>
<p><b>Unary Operators:</b><br />
</p><ul>
<li>Positive, <code>'+'</code></li>
<li>Negative, <code>'-'</code></li>
<li>BoolNot, <code>'!'</code></li>
<li>BitNot, <code>'~'</code></li>
<li>Indirection, <code>'*'</code></li>
</ul>
<p><b>Binary Operators:</b><br />
</p><ul>
<li>Multiply , <code>'*'</code></li>
<li>Divide , <code>'/'</code></li>
<li>Modulo , <code>''</code></li>
<li>Add , <code>'+'</code></li>
<li>Subtract , <code>'-'</code></li>
<li>ShiftLeft , <code>'&lt;&lt;'</code></li>
<li>ShiftRight , <code>'&gt;&gt;'</code></li>
<li>Smaller , <code>'&lt;'</code></li>
<li>SmallerOrEqual , <code>'&lt;='</code></li>
<li>Greater , <code>'&gt;'</code></li>
<li>GreaterOrEqual , <code>'&gt;='</code></li>
<li>Equal , <code>'=='</code></li>
<li>NotEqual , <code>'!='</code></li>
<li>BitAnd , <code>'&amp;'</code></li>
<li>BitXOr , <code>'|'</code></li>
<li>BitOr , <code>'^'</code></li>
<li>BoolAnd , <code>'&amp;&amp;'</code></li>
<li>BoolOr , <code>'||'</code></li>
<li>Assign , <code>'='</code></li>
</ul>
<p><b>Special Operators:</b><br />
</p><ul>
<li>Ternary , <code>'Q ? T : F'</code></li>
<li>Elvis , <code>'A ?: B'</code></li>
<li>Subscript , <code>'[]'</code></li>
</ul>
<p>Not only the operators were taken from C++, but in the case of binary operators, also the definition of their precedence.</p>
<p>The built-in operators are set by method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a> if flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6ae9f3440b954250aa73cdd7b581883aa6">Compilation::DefaultUnaryOperators</a>, respectively <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6ae9f3440b954250aa73cdd7b581883aa6">Compilation::DefaultUnaryOperators</a> is set in bitfield <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ab80df79edf00c08ed5f7b74b48f5f0f6">Compiler::CfgCompilation</a>.</p>
<p>Internally the following approach is taken:</p><ul>
<li>The <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">resourced enum meta data</a> of enumeration class <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4d">DefaultUnaryOperators</a> respectively <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325">DefaultBinaryOperators</a> is loaded.</li>
<li>For each enumeration element, the information is passed to a call to <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#affad3f0d3a8bbb909b7688289a41264e">Compiler::AddUnaryOperator</a>, respectively <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a078d3e53ebb3cff5a15a939a0ae1c6e4">Compiler::AddBinaryOperator</a>.</li>
<li>Dependent on flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6abe80c37b4a47cbebdb18e6e070cc7804">Compilation::AliasEqualsOperatorWithAssignOperator</a> the precedence of the <em>assign-</em>operator is "patched" to the level of the <em>equal-</em>operator.</li>
</ul>
<p>This is a rather simple process, and thus it is similar simple to intervene and customize the operators. While removing what is built-in is seldom necessary, adding an operator might be wanted. This is exercised in the next section.</p>
<p><a class="anchor" id="alib_expressions_operators_custom"></a></p><h2>9.2 Tutorial: Adding A Custom Operator</h2>
<p>With what was described in the previous chapter, the following options of customizing the operators parsed and compiled by module <b>ALib Expressions</b> can be taken:</p><ul>
<li>Built-in operators can be completely disabled by just clearing the flags in field <b>Compiler::CfgCompilation</b>.</li>
<li><a class="el" href="classaworx_1_1lib_1_1lang_1_1Resources.html">Resources</a> of library class <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expressions.html">Expressions</a> can be altered to change operator symbols or precedences.</li>
<li>Methods <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#affad3f0d3a8bbb909b7688289a41264e">Compiler::AddUnaryOperator</a>, respectively <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a078d3e53ebb3cff5a15a939a0ae1c6e4">Compiler::AddBinaryOperator</a> may be called prior or after <b>SetupDefaults</b> to define additional custom operators.</li>
<li>Single built-in operators might be simply removed from public fields <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#aaaf5fcd7289ab59f8ed9bbc3006a70c3">Compiler::UnaryOperators</a> and <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#adcc298e4b798dd0f0af14216d1bfe37d">Compiler::BinaryOperators</a> after the invocation of <b>SetupDefaults</b>.</li>
</ul>
<p>As a sample, the goal is to have a new binary operator <code>'{}'</code> that allows to format the right-hand side operand according to a format provided with the left-hand side operand. Let's first check what happens if we just start and use the operand:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">lib::expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;( &quot;Hexadecimal: 0x{:x}&quot; {} 42&quot;  )&quot;) );</span></div></div><!-- fragment --><p> This produces the following exception which indicates that parsing the exception fails due to a syntax error: </p><div class="fragment"><div class="line">E1: &lt;expressions::SyntaxError&gt;</div><div class="line">    Syntax error parsing expression.</div><div class="line">E2: &lt;expressions::ExpressionInfo&gt;</div><div class="line">    Expression: { <span class="stringliteral">&quot;Hexadecimal: 0x{:x}&quot;</span> {} 42<span class="stringliteral">&quot;  }</span></div><div class="line"><span class="stringliteral">                                        ^-&gt;</span></div></div><!-- fragment --><p> Now we define the operator: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"></div><div class="line">compiler.AddBinaryOperator( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;{}&quot;</span>) , 900);</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">lib::expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;( &quot;Hexadecimal: 0x{:x}&quot; {} 42  )&quot;) );</span></div></div><!-- fragment --><p> We give the operator a high precedence, on the level of operator <code>'*'</code>. The operator precedence values are documented with <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325">DefaultBinaryOperators</a>.<br />
 The exception changes to: </p><div class="fragment"><div class="line">E1: &lt;expressions::BinaryOperatorNotDefined&gt;</div><div class="line">    Operator <span class="stringliteral">&#39;{}&#39;</span> not defined <span class="keywordflow">for</span> types <span class="stringliteral">&quot;String&quot;</span> and <span class="stringliteral">&quot;Integer&quot;</span>.</div><div class="line">E2: &lt;expressions::ExpressionInfo&gt;</div><div class="line">    Expression: { <span class="stringliteral">&quot;Hexadecimal: 0x{:x}&quot;</span> {} 42  }</div><div class="line">                                        ^-&gt;</div></div><!-- fragment --><p> Obviously, now the parser recognized the operator. This single line of code, was all we needed to do to define the operator.</p>
<p>To get a working sample, a compiler plug-in that compiles the operator for left-hand side strings and any right hand side type is needed. Here it is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>FormatOperator : <a class="code" href="namespaceaworx.html#ac9c19c11a742256edba9903a1130b75c">CompilerPlugin</a></div><div class="line">{</div><div class="line">    FormatOperator( <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a>&amp; compiler )</div><div class="line">    : <a class="code" href="namespaceaworx.html#ac9c19c11a742256edba9903a1130b75c">CompilerPlugin</a>( <span class="stringliteral">&quot;Tutorial Plugin&quot;</span>, compiler )</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> TryCompilation( CIBinaryOp&amp;  ciBinaryOp )</div><div class="line">    {</div><div class="line">        <span class="comment">// check if it is not us</span></div><div class="line">        <span class="keywordflow">if</span>(     ciBinaryOp.Operator != <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;{}&quot;</span>)</div><div class="line">            || !ciBinaryOp.ArgsBegin-&gt;IsSameType( <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a> ) )</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// set debug info</span></div><div class="line">        <a class="code" href="group__GrpALibMacros.html#ga5f6b7763c5f5722d7f178c04540aba9e">ALIB_DBG</a>( ciBinaryOp.DbgCallBackName = <span class="stringliteral">&quot;CBFormat&quot;</span>;      )</div><div class="line"></div><div class="line">        <span class="comment">// all is const? We can do it at compile time!</span></div><div class="line">        if( ciBinaryOp.LhsIsConst &amp;&amp; ciBinaryOp.RhsIsConst )</div><div class="line">        {</div><div class="line">            ciBinaryOp.TypeOrValue= <a class="code" href="namespaceaworx_1_1lib_1_1expressions_1_1plugins.html#a128ae57e3f8f0dadfb50e4c4f891aff6">lib::expressions::plugins::CBFormat</a>(ciBinaryOp.CompileTimeScope,</div><div class="line">                                                                        ciBinaryOp.ArgsBegin,</div><div class="line">                                                                        ciBinaryOp.ArgsEnd         );</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// set callback</span></div><div class="line">        ciBinaryOp.Callback     = <a class="code" href="namespaceaworx_1_1lib_1_1expressions_1_1plugins.html#a128ae57e3f8f0dadfb50e4c4f891aff6">lib::expressions::plugins::CBFormat</a>;</div><div class="line">        ciBinaryOp.TypeOrValue  = <a class="code" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">Types::String</a>;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> With the plug-in attached: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line">compiler.AddBinaryOperator( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;{}&quot;</span>) , 900);</div><div class="line"></div><div class="line">FormatOperator plugin( compiler );</div><div class="line">compiler.InsertPlugin( &amp;plugin, <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59a90589c47f06eb971d548591f23c285af">CompilePriorities::Custom</a> );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">lib::expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;( &quot;Hexadecimal: 0x{:x}&quot; {} 42  )&quot;) );</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">cout &lt;&lt; expression-&gt;Evaluate( scope )  &lt;&lt; endl;</span></div></div><!-- fragment --><p> The expression compiles and results in: </p><div class="fragment"><div class="line">Hexadecimal: 0x2a</div></div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>While "verbal" operator names are allowed as aliases of operators (see next section), custom operator symbols must not contain alphanumerical characters and character <code>'_'</code> (underscore).</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Any changes in respect to operator setup has to be made prior to invoking method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a48950a23ca943cebf76688bc80c0e40b">Compiler::Compile</a> for the first time, because with that, the internal parser is created (once) and configured according to these settings. Later changes will have no effect or result in undefined behaviour.</li>
<li>The registration of custom compiler plug-ins may be done before or after modifying the operator setup of the compiler.</li>
</ul>
</dd></dl>
<p><a class="anchor" id="alib_expressions_operators_verbal"></a></p><h2>9.3 Verbal Operator Aliases</h2>
<p>End-users that are not too familiar with programming languages might find it easier to use verbal operators. Instead of writing: </p><div class="fragment"><div class="line">GetYear(Today) == 2017 &amp;&amp; GetDayOfWeek(Today) != Monday</div></div><!-- fragment --><p> they prefer: </p><div class="fragment"><div class="line">GetYear(Today) equals 2017 and GetDayOfWeek(Today) not_equals Monday</div></div><!-- fragment --><p>Such sort of "verbal" expressions are supported and enabled by default, with the concept of <em>"Verbal Operator Aliases"</em>. As the term explains already, verbal operators can not be defined with this library as being full featured "stand-alone" operators, but only as aliases for existing symbolic operators. </p><dl class="section note"><dt>Note</dt><dd>The rational behind this design decision is that usually, verbal operators just in fact are aliases. Now, with restricting verbal aliases to be aliases, the number of "real" operators does not increase by adding verbal aliases. In the case it did, the number of permutations of operators and types that had to be overloaded would drastically increase.</dd></dl>
<p>The default built-in (resourced) verbal operator aliases are: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Verbal Operator  </th><th class="markdownTableHeadNone">Is Alias For   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Not</b>  </td><td class="markdownTableBodyNone">Unary operator <code>'!'</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>And</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&amp;&amp;'</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Or</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'||'</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Sm</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&lt;'</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Smaller</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&lt;'</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Smeq</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&lt;='</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Smaller_or_equal</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&lt;='</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Gt</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&gt;'</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Greater</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&gt;'</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Gteq</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&gt;='</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Greater_or_equal</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'&gt;='</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Eq</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'=='</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Equals</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'=='</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Neq</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'!='</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Not_equals</b>  </td><td class="markdownTableBodyNone">Binary operator <code>'!='</code>   </td></tr>
</table>
<p>Likewise the operators themselves, <b>ALib Expressions</b> defines the names and alias operators using <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">resourced enum meta data</a> assigned to enumeration class <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1">DefaultAlphabeticBinaryOperatorAliases</a>.<br />
 The resource data is processed by method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a> dependent on flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a145a0ec7809a34f20bc66962fac93e1f">DefaultAlphabeticOperatorAliases</a> of bitfield <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ab80df79edf00c08ed5f7b74b48f5f0f6">CfgCompilation</a> (which is set by default).</p>
<p>Additional flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aad457d1ed07ef3f48c5210b3ec9918f5">AlphabeticOperatorsIgnoreCase</a> controls whether the alias names are matched ignoring letter case (which is also set by default).</p>
<p>Class <b>Compiler</b> simply stores the alias information in its public hash tables <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a44067170fd133e94d984d2be82b616dc">AlphabeticUnaryOperatorAliases</a> and <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ac88cf71b2015040cd421aec7f3ec565c">AlphabeticBinaryOperatorAliases</a> which can be altered prior or after the invocation of <b>SetupDefaults</b>, but before a first expression is compiled.</p>
<p><b>Some further notes:</b><br />
</p><ul>
<li>Even with flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aad457d1ed07ef3f48c5210b3ec9918f5">AlphabeticOperatorsIgnoreCase</a> cleared, no two verbal operator aliases that only differ in letter case must be defined (e.g the definition of "or" in parallel to "OR" is forbidden).</li>
<li>There are five possible configuration settings to normalize verbal operator names. See flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3aa5ccfa052b1378e251f2ae5b8d919efa">ReplaceVerbalOperatorsToSymbolic</a> for more information.</li>
<li>If the resources of built-in alias operators are changed (e.g. for translation/localization), it is allowed to set single names of the predefined enum element names to empty strings. These will be ignored with method <b>SetupDefaults</b>. On the same token, when changing the resources, completely different values and meanings may be used, because the enum class <b>DefaultAlphabeticBinaryOperatorAliases</b> is exclusively used for accessing its meta information.</li>
<li>The concept of <em>verbal operator aliases</em> must not be confused with the concept of <em>operator aliases</em> performed with compiler plug-ins (explained in next section). Verbal aliases are defined globally and a compiler plug-in will never "see" the alias names as those get translated to the aliased operator internally before the compilation is performed.</li>
</ul>
<p><a class="anchor" id="alib_expressions_operators_aliases"></a></p><h2>9.4 Operator Aliases</h2>
<p>This library does some effort to support operator aliases, which is about telling the system that an operator used with certain argument types is to be considered equal to another operator using the same argument types.</p>
<p>The only occasion where this is internally used, is with combinations of boolean, integer and float types and bitwise operators <code>'~'</code>, <code>'&amp;'</code> and <code>'|'</code>: Any use of these operators a mix of these types - excluding those permutations that only consist of integers - are optionally aliased to boolean operators <code>'!'</code>, <code>'&amp;&amp;'</code> and <code>'||'</code>. It would have been less effort to just define the bitwise operators for the types to perform boolean calculations! So, why does the library do the effort then?</p>
<p>The motivation for taking the effort comes from normalization. While the library should be configurable to accept the expression: </p><pre class="fragment">   date = today  &amp;  size &gt; 1024
</pre><p>it should at the same time configurable to "normalize" this expression to: </p><pre class="fragment">   date == today  &amp;&amp;  size &gt; 1024
</pre><p>Maybe, custom fields of application identify other operators where such aliasing is reasonable as well.</p>
<p>The following parts of the library's API are involved in operator aliasing:</p><ul>
<li>Inner structs <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a> of class <b>CompilerPlugin</b>:<br />
 Both structs provide field <b>Operator</b> by reference and thus allow to change the operator given.</li>
<li><p class="startli">Helper class <b>Calculus</b> with methods:</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ad8ccbbf281a8ef90c59a549f27bd8e05">AddUnaryOpAlias</a>,</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ae193651ef315f1cf1143e54ecb18b890">AddUnaryOpAliases</a>,</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a49b4c0d3872b1d18018f5b3b508bf625">AddBinaryOpAlias</a> and</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a672ba0d4902b6d18b08b3fbab8ba3f9e">AddBinaryOpAliases</a></li>
</ul>
<p class="startli">which simplify operator alias definitions and avoid to denote the same compilation information twice.</p>
</li>
<li>Normalization flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a7cb98ff4ba877f4c1b9318b25fde4bf8">ReplaceAliasOperators</a> which controls if alias operators are replaced in the normalized expression string.</li>
</ul>
<p><a class="anchor" id="alib_expressions_operators_subscript"></a></p><h2>9.5 Array Subscript Operator</h2>
<p>The "array subscript operator" <code>'[]'</code> is only in so far an exceptional binary operator, as it is parsed differently than other binary operators. While usually the operator is placed between the left-hand side (<em>Lhs</em>) and right-hand side (<em>Rhs</em>) arguments, the subscript operator is expressed in the form </p><pre class="fragment">   Lhs[ Rhs ]
</pre><p>In any other respect it is completely the same! The only built-in use of the operator is with lhs-type <b>String</b> and rhs-type <b>Integers</b>. With it, the sub-string at the given position of length <code>1</code> is returned.</p>
<p>Its use and meaning is of-course not bound to array access. For example, with the right-hand side operands of type <b>String</b>, a mapped access to pairs of keys and values can be realized. To implement this, the left-hand side type would be a custom type returned by an identifier, say <b>Properties</b>. Now, if the subscript operator was defined for this type and strings, expressions like </p><pre class="fragment">   Properties["HOME_PATH"]
</pre><p>are possible. The operator's callback function could catch certain key values and return appropriate results from objects accessible through the custom scope object.</p>
<p><a class="anchor" id="alib_expressions_operators_nested"></a></p><h2>9.6 Unary Operator For Nested Expressions</h2>
<p>It was not talked about <em>nested expressions</em> yet. This is concept is introduced only with the next chapter, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested">10. Nested Expressions</a></p>
<p>Here, we just quickly want to explain that this operator exists, that it has a special meaning and how it can be changed.</p>
<p>The definition of the operator is made with field <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a5f9dfba67b016bea9547a4f18dd72eb6">Compiler::CfgNestedExpressionOperator</a>. Its default value is <code>'*'</code>, which in C/C++ is also called the <em>"indirection operator"</em>. With this default definition, expression: </p><pre class="fragment">       date &lt; today &amp;&amp; *"myNested"
</pre><p>refers to nested expression <code>"myNested"</code>.</p>
<p>Changing the operator needs to be done prior to invoking <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a>. Should operator definitions be changed as explained in the previous chapters, it is important to know that the nested expression operator itself has to be duly defined. In other words: Specifying an operator with field <b>CfgNestedExpressionOperator</b> does not define the operator.</p>
<p>The operator internally works on string arguments which name the nested expression that is addressed. However, to overcome the need of quoting names of nested expressions, a built in mechanism is provided that allows to omit the quotes. This feature is enabled by default and controlled with compilation flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a9887dccddfdbf3fe697c4ff1b66994fb">AllowIdentifiersForNestedExpressions</a>. For this reason, by default, the sample expression given above can be equally stated as: </p><pre class="fragment">        date &lt; today &amp;&amp; *myNested
</pre><p>Note that this does <b>not</b> introduce a conflict with defined identifiers or function named. For example, if a nested expression was named <b>"PI"</b>, just as math constant identifier <b>PI</b>, then still the following works: </p><pre class="fragment">   5.0 * PI    // multiplies 5 with math constant PI
   5.0 * *PI   // multiplies 5 with the result of nested expression named "PI".
</pre><p>When changing the nested expression operator, some thinking about the consequences is advised. Other candidates for nested expression operators may be <code>'$'</code>, <code>''</code> or <code>'@'</code>, which are more commonly used to denote variables or other "scoped" or "nested" entities. But exactly for this reason, module <b>ALib Expressions</b> opted to default the operator to <code>'*'</code>. Often, applications offer to provide expressions via a command line interface, which in turn allows using <b>bash CLI</b> and any scripting language. The asterisk character <code>'*'</code> seems to be least clashing with such external environments.<br />
 Therefore, we recommend to do some careful thinking about potential conflicts in the desired field of application and use case environments, before changing this operator.</p>
<p><a class="anchor" id="alib_expressions_nested"></a></p><h1>10. Nested Expressions</h1>
<p>Often certain "terms" of an expression are to be repeated in more than one expression. Furthermore, it sometimes is valuable to be able to split an expression into two parts, for example parts that have different levels of validity. This latter is often the case when it comes to "filtering" records from a set. A first filter might be a more general, long living expression. A second expression adds to this filter by applying more concrete demands. In the filter sample, there are two ways of achieving this:</p><ol type="1">
<li>First apply a filter using the general term and then apply a second filter.</li>
<li>Apply one filter with both terms concatenated via boolean operator <code>&amp;&amp;</code>.</li>
</ol>
<p>Besides being faster, the second has one huge advantage: it is up to the end user if the single filter refers to a different term - or not. There is no need to hard-code two filters into a software.</p>
<p>These thoughts bring us to the concept of "nested expressions", which is referring to expressions from expressions!</p>
<p>The foundation to achieve such feature, is first to provide a way to store expressions and retrieve them back using a key value.</p>
<p><a class="anchor" id="alib_expressions_nested_named"></a></p><h2>10.1 Named Expressions</h2>
<p>Module <b>ALib Expressions</b> provides a built-in container to store compiled expressions. In the moment an expression is stored, a name has to be given and that is all that makes an expression a named expression.</p>
<p>So far in this manual, we had compiled expressions using method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a48950a23ca943cebf76688bc80c0e40b">Compiler::Compile</a>. What is returned is an <em>anonymous</em> expression. It is not named. To create a named expression, method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a138537b858657d4d9e4e6d9b5cf4a49b">Compiler::AddNamed</a> is used. This method internally compiles the expression and stores it with the given name. The expression itself is not returned, instead information about whether an expression with that name existed (and thus was replaced).</p>
<p>For retrieval of named expressions, method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a64de2d0bc9812fd9b4ab9a469be6626c">GetNamed</a> is offered and for removal method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a9f9a32b69f29fdeee65da34d5e0aeec5">RemoveNamed</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The optional internal storage of expressions are the reason why the library addresses expressions exclusively through type <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> which evaluates to <code>std::shared_ptr&lt;Expression&gt;</code>. With this, a named expression is automatically deleted if it is removed from the storage and not externally referred to.</dd></dl>
<p>By default, <b>letter case is ignored</b> when using the given name as a storage key. Hence adding <code>"MYEXPRESSION"</code> after adding <code>"MyExpression"</code> replaces the previous instance. This behaviour can be changed using compilation flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a84c8262d7f9e1ddf967be19e8fc94445">CaseSensitiveNamedExpressions</a>. Changes of this flag must be done only prior to adding a first named expression. Later changes leads to is undefined behaviour.</p>
<p>Named expressions is not too much of a great thing if viewed as a feature by itself. But it is the important prerequisite for <em>nested expressions</em> explained in the following sections.</p>
<p><a class="anchor" id="alib_expressions_nested_operator"></a></p><h2>10.2 Nested Expressions Identified At Compile-Time</h2>
<p>The simplest form of addressing nested expressions is by using unary operator <code>'*'</code>, which allows to embed a named expression into another expression.</p>
<p>While the operator defaults to being <code>'*'</code>, this can be changed as described in <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_nested">9.6 Unary Operator For Nested Expressions</a>.</p>
<p>The operator expects a string providing the name, but for convenience, this string does not need to be quoted, but may be given like identifiers are.</p>
<dl class="section note"><dt>Note</dt><dd>This behaviour is configurable with compilation flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a9887dccddfdbf3fe697c4ff1b66994fb">AllowIdentifiersForNestedExpressions</a> and enabled by default. If the name of an expression does not conform to the <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_identifiers">11.3 Identifiers/Functions</a>, for example if it begins with a numeric character, then the otherwise optional quotes have to be provided.</dd></dl>
<p>With this operator, expressions: </p><pre class="fragment">     *"MyNestedExpression"
     *MyNestedExpression
</pre><p>both simply "invoke" the expression named <code>"MyNestedExpression"</code> and return its result.</p>
<p>Of-course, this sample was just the shortest possible. Nested expressions can be used just like any other identifier: </p><pre class="fragment">   GetDayOfWeek( Today ) == Monday &amp;&amp;  *MyNestedExpression
</pre><p>This expressions evaluates to <code>true</code> on mondays and if named expression <code>"MyNestedExpression"</code> evaluates to true in parallel.</p>
<p>One might think that this is all that has to be said about nested expressions. But unfortunately this is not. An attentive reader might have noticed some important restriction with nesting expressions like this: Because <b>ALib Expressions</b> is a type-safe library, the compiler can compile operator <code>&amp;&amp;</code> in the above sample only if it knows the result type of <code>"MyNestedExpression"</code>. As a consequence, we have to state the following rule:</p>
<dl class="section attention"><dt>Attention</dt><dd>Expressions addressed with the unary operator have to be existing at a the time the referring expression is compiled.</dd></dl>
<p>Let us simply have a try. The following code: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(  *MyNestedExpression  )&quot;));</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">cout &lt;&lt; </span><span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; expression-&gt;Evaluate( scope );</div></div><!-- fragment --><p> Produces the following exception: </p><div class="fragment"><div class="line">E1: &lt;expressions::NamedExpressionNotFound&gt;</div><div class="line">    Named expression <span class="stringliteral">&quot;MyNestedExpression&quot;</span> not found.</div><div class="line">E2: &lt;expressions::NestedExpressionNotFoundCT&gt;</div><div class="line">    Compile-time defined nested expression <span class="stringliteral">&quot;MyNestedExpression&quot;</span> not found.</div></div><!-- fragment --><p> The exception tells us that this is a "compile-time defined nested expression". This indicates that there will be a way out, what we will see in the next chapter, but for the time being let us fix the sample by adding the named expression upfront:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"></div><div class="line">compiler.AddNamed( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;MyNestedExpression&quot;</span>), <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;6 * 7&quot;</span>) );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(  *MyNestedExpression  )&quot;));</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">cout &lt;&lt; </span><span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; expression-&gt;Evaluate( scope ) &lt;&lt; endl;</div></div><!-- fragment --><p> Now this works: </p><div class="fragment"><div class="line">Result: 42</div></div><!-- fragment --><p> The compiler found the nested expression, identified its return type and is now even able to use it in more complex terms like this:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   2 * *MyNestedExpression    )&quot;));</span></div></div><!-- fragment --><p> This results in: </p><div class="fragment"><div class="line">Result: 84</div></div><!-- fragment --><p> But there is also another restriction that has to be kept in mind with the use of the unary operator for nested expressions.<br />
 While this sample still works well: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   *(&quot;MyNested&quot; + &quot;Expression&quot;)   )&quot;) );</span></div></div><!-- fragment --> <div class="fragment"><div class="line">Result: 42</div></div><!-- fragment --><p> This expression does not work: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(    *(&quot;MyNested&quot; + ( random &gt;= 0.0 ? &quot;Expression&quot; : &quot;&quot; ))     )&quot;) );</span></div></div><!-- fragment --><p> as it throws: </p><div class="fragment"><div class="line">E1: &lt;expressions::NamedExpressionNotConstant&gt;</div><div class="line">    Expression name has to be constant, <span class="keywordflow">if</span> no expression <span class="keywordflow">return</span> type is given.</div><div class="line">E2: &lt;expressions::ExpressionInfo&gt;</div><div class="line">    Expression: {    *(<span class="stringliteral">&quot;MyNested&quot;</span> + ( random &gt;= 0.0 ? <span class="stringliteral">&quot;Expression&quot;</span> : <span class="stringliteral">&quot;&quot;</span> ))     }</div><div class="line">                     ^-&gt;</div></div><!-- fragment --><p> While - due to the compile-time optimization of <b>ALib Expressions</b> - the constant concatenation term <code>"MyNested" + "Expression"</code> is still accepted, the compiler complains if we use the function <code>random</code>. The compiler does not have the information that <code>random&gt;=0</code> evaluates to constant true, and hence the term is not optimized and not constant.<br />
 The exception names the problem, which leads us to a second rule:</p>
<dl class="section attention"><dt>Attention</dt><dd>Expressions names addressed with the unary operator have to be constant at compile time.</dd></dl>
<p>This is obvious, as the expression has to exist and be known. But still, it is a restriction.</p>
<p>There are many use cases, where still this simple operator notation for nested expressions is all that is needed. For example, imagine a set of expressions is defined in an INI-file of a software. If the software loads and compiles these "predefined" expressions at start, a user can use them, for example with expressions given as command line parameters. This way, a user can store "shortcuts" in the INI-file and use those as nested expressions at the command line.</p>
<p>A final note to compile-time nested expressions: After an expression that refers to a named nested expression is compiled, the named nested expression may be removed using <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a9f9a32b69f29fdeee65da34d5e0aeec5">Compiler::RemoveNamed</a>. The program of the outer expression stores the shared pointers to all compile-time nested expressions used. While after the removal from the compiler the nested expression is not addressable for future nesting, the nested expression is only deleted in the moment the last expression that refers to it is deleted!</p>
<p><a class="anchor" id="alib_expressions_nested_function"></a></p><h2>10.3 Nested Expressions Identified At Evaluation-Time</h2>
<p>In the previous section we saw the first samples of nested expressions. The unary operator <code>'*'</code> was used to address nested expressions. These nested expressions suffer from two restrictions:</p><ol type="1">
<li>The nested expression has to be defined prior to using it.</li>
<li>The name of the nested expression must not be an expression itself, but rather a constant string term or an identifier.</li>
</ol>
<p>Let us recall what the reason for this restriction was: The compiler needs to know the result type of the nested exception to continue its type-safe compilation.</p>
<p>The way to overcome this restriction is to use function <b>Expression()</b> instead of unary operator <code>'*'</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Likewise the unary nested expression operator is configurable with member <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a5f9dfba67b016bea9547a4f18dd72eb6">CfgNestedExpressionOperator</a> of class <b>Compiler</b>, the name, letter case sensitivity and abbreviation options of the nested expression function is configurable with member <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a3ef5c1cb148a564ad0746a78c397ed47">CfgNestedExpressionFunction</a>.<br />
 It just defaults to <b>"Expression()"</b></dd></dl>
<p>This function has three overloaded versions. The first is using just one parameter of string type and with that is 100% equivalent to the use of the expression - including its restriction.</p>
<p>The second overload however takes a <em>"replacement expression"</em> as its second value. This is how it may be used: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   Expression( &quot;MyNestedExpression&quot;, -1 )   )&quot;));</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">cout &lt;&lt; </span><span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; expression-&gt;Evaluate( scope ) &lt;&lt; endl;</div></div><!-- fragment --><p> The output of this sample is:</p>
<div class="fragment"><div class="line">Result: -1</div></div><!-- fragment --><p> As you see, although the nested expression is was not defined, this sample now compiles. The compiler uses the result type of the second parameter and assumes that the expression will return the same type. And even more, the expression even evaluates! On evaluation it is noticed that the expression does not exist, hence the result of the "replacement expression" is used. While in this case the replacement is simply value <code>-1</code>, any expression might be stated here. Even one that contains a next nested expression.</p>
<p>We extend the sample by adding the nested expression:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   Expression( &quot;MyNestedExpression&quot;, -1 )   )&quot;));</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">compiler.AddNamed( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(</span><span class="stringliteral">&quot;MyNestedExpression&quot;</span>), <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;3 * 3&quot;</span>) );</div><div class="line"></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; expression-&gt;Evaluate( scope ) &lt;&lt; endl;</div></div><!-- fragment --> <div class="fragment"><div class="line">Result: 9</div></div><!-- fragment --><p> As a "proof" that the nested expression is identified only at evaluation time, the following sample might work: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   Expression( &quot;MyNestedExpression&quot;, -1 )   )&quot;));</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">compiler.AddNamed( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(</span><span class="stringliteral">&quot;MyNestedExpression&quot;</span>), <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;3 * 3&quot;</span>) );</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Result1: &quot;</span> &lt;&lt; expression-&gt;Evaluate( scope ) &lt;&lt; endl;</div><div class="line"></div><div class="line">compiler.AddNamed( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;MyNestedExpression&quot;</span>), <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;4 * 4&quot;</span>) );</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Result2: &quot;</span> &lt;&lt; expression-&gt;Evaluate( scope ) &lt;&lt; endl;</div></div><!-- fragment --> <div class="fragment"><div class="line">Result1: 9</div><div class="line">Result2: 16</div></div><!-- fragment --><p> Above, we said that the compiler "assumes" that the named expression addressed, has the same return type. The following code shows that this was the right verb: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   Expression( &quot;MyNestedExpression&quot;, -1 )   )&quot;));</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">compiler.AddNamed( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(</span><span class="stringliteral">&quot;MyNestedExpression&quot;</span>), <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(  &quot;Hello&quot;   )&quot;));</span></div></div><!-- fragment --><p> No exception is thrown on compilation. The compiler does not check the return type at compile-time. The simple reason is: At the time the expression becomes evaluated, the named expression might have been changed to return the right time. This is why, the return type is only checked at evaluation time. Let's see what happens when we evaluate: </p><div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; expression-&gt;Evaluate( scope ) &lt;&lt; endl;</div></div><!-- fragment --> <div class="fragment"><div class="line">E1: &lt;expressions::NestedExpressionResultTypeError&gt;</div><div class="line">    Nested expression <span class="stringliteral">&quot;MyNestedExpression&quot;</span> returned wrong result type.</div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> expected: <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a></div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> returned: Integer</div><div class="line">E2: &lt;expressions::ExpressionInfo&gt;</div><div class="line">    Expression: {   Expression( <span class="stringliteral">&quot;MyNestedExpression&quot;</span>, -1 )   }</div><div class="line">                    ^-&gt;</div></div><!-- fragment --><p> This shows, that with using function <b>Expression()</b> we are a little leaving the secure terrain of expression evaluation: While the only exceptions that can happen at evaluation-time had been ones that occurred in callback functions (for example in expression <code>"5 / 0"</code>), with nested expressions that are identified only at evaluation-time, we have a first exception that is thrown by the virtual machine that executes the expression program.</p>
<p>At the beginning of this section, a third overload of <b>Expression()</b> was mentioned. We postpone its documentation to the next manual section, and end this chapter with another quick note:</p>
<p>Likewise with unary operator <code>'*'</code> for nested expressions, compilation flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a9887dccddfdbf3fe697c4ff1b66994fb">AllowIdentifiersForNestedExpressions</a> allows to omit the quotes and accept identifier syntax instead. Hence, this expression is compiling fine:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   Expression( MyNestedExpression, -1 )   )&quot;));</span></div></div><!-- fragment --><p> In addition, with this form of embedding nested expressions, also the restriction of expression names being constants, fell. This way, the sample of a random name is now allowed:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   Expression( (&quot;MyNested&quot; + ( random &gt;= 0.0 ? &quot;Expression&quot; : &quot;&quot; )), -1 )   )&quot;));</span></div></div><!-- fragment --><p><a class="anchor" id="alib_expressions_nested_throw"></a></p><h2>10.4 Forcing The Existence Of Nested Expressions</h2>
<p>The previous two chapters explained the differences between nested expressions that are identified at compile-time and those identified at evaluation time.</p>
<p>Compile-time nested expressions are usually expressed with unary operator <code>'*'</code>, but can also be expressed when using only one parameter with nested expression function <b>Expression()</b>.</p>
<p>Evaluation-time nested expressions are expressed by giving a second parameter to function <b>Expression()</b>, which provides the "replacement expression" for the case that a nested expression of the name given with the first parameter does not exist.</p>
<p>In some situations however, a user might not want to provide a "replacement expression". It might be rather in her interest, that an expression just fails to evaluate in the case that the nested expression is not found. For example, if this indicates a configuration error of a software.</p>
<p>Such behaviour can be achieved by adding a third parameter to <b>Expression()</b>. This third parameter is keyword <code>"throw"</code>.</p>
<p>We take the sample of the previous section where the expression was not defined, which resulted in default value <code>-1</code>. The only difference is the use of keyword <code>throw</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a> compiler;</div><div class="line">compiler.<a class="code" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">SetupDefaults</a>();</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">expressions::Scope</a> scope( compiler.CfgFormatter );</div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> expression= compiler.Compile(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(R<span class="stringliteral">&quot;(   Expression( &quot;MyNestedExpression&quot;, -1, throw )   )&quot;));</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">cout &lt;&lt; </span><span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; expression-&gt;Evaluate( scope ) &lt;&lt; endl;</div></div><!-- fragment --><p> The output of this sample is:</p>
<div class="fragment"><div class="line">E1: &lt;expressions::NamedExpressionNotFound&gt;</div><div class="line">    Named expression <span class="stringliteral">&quot;MyNestedExpression&quot;</span> not found.</div><div class="line">E2: &lt;expressions::NestedExpressionNotFoundET&gt;</div><div class="line">    Evaluation-time defined nested expression <span class="stringliteral">&quot;MyNestedExpression&quot;</span> not found.</div></div><!-- fragment --><p> So, why do we need the second parameter which previously gave the "replacement expression" when this is not evaluated? Well, the only purpose of the replacement expression is to determine the nested expression's return type. Otherwise it is ignored. In fact, it is not optimized out and it its result will be calculated with each next evaluation of an expression against a scope. Different to other areas, where the library puts some effort in optimization, here this was omitted. An end-user simply should be noted to put a constanst "sample value" for this parameter. A user that uses this third version of the nested expression function, is supposed to be a "pro" and understand the impacts.</p>
<dl class="section note"><dt>Note</dt><dd>"throw" is the only keyword of <b>ALib Expressions</b>!</dd></dl>
<p><a class="anchor" id="alib_expressions_nested_config"></a></p><h2>10.5 Automated Named Expressions</h2>
<p>As described in a previous section, a prerequisite for nested expression is to have <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested_named">named expressions</a>. Methods <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a138537b858657d4d9e4e6d9b5cf4a49b">AddNamed</a>, <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a64de2d0bc9812fd9b4ab9a469be6626c">GetNamed</a> and <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a9f9a32b69f29fdeee65da34d5e0aeec5">RemoveNamed</a> of class <b>Compiler</b> had been already described briefly.</p>
<p>If we think again of a use case, where a set of nested expressions is stored externally which are allowed to be used used as nested expressions, a problem occurs: As currently described, all predefined expressions have to be compiled and stored, for example in the moment a process is started. But this is not the case, because method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a64de2d0bc9812fd9b4ab9a469be6626c">GetNamed</a> supports a "lazy" approach to this: Lazy here means, that a named expression is loaded and compiled "on the fly" as soon as it becomes used as a nested expression for the first time.</p>
<p>To reach this, virtual protected method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#aea51a8fe71419825d548e3383f03611d">Compiler::getExpressionString</a> was introduced. This method is invoked by <b>GetNamed</b> in the moment no expression with the given name is found. If then, <b>getExpressionString</b> returns an expression string, the expression is compiled and added just on the fly.</p>
<p>If module <b>ALib Expressions</b> is compiled together with module <b>ALib Configuration</b>, then via enabled preprocessor variables, code for leveraging <b>ALib</b> configuration features with <b>ALib</b> expressions is available. This is simply done providing a default implementation of aforementioned virtual method <b>getExpressionString</b>. This default implementation makes use of pointer member <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a2c37015bcce40f74f397f29ea050f251">Compiler::Config</a> and this way enables to retrieve expression strings from command line parameters, environment variables, INI-files or any other custom resource that is attached to this object.</p>
<p>For information about to use class <b>Configuration</b>, which likewise the compiler itself supports "plug-ins" for data sources, see the documentation of module <a class="el" href="namespaceaworx_1_1lib_1_1config.html">ALib Configuration</a>.</p>
<p>Other members of class <b>Compiler</b> that become available with compiling this library together with <b>ALib Configuration</b> are <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ac9d947d167a0c0c0ce042d6f84a5d05f">DefaultCategories</a>, <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ac39afe9fff6d6e1febb44781a33204f6">VariablesLoaded</a> and <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a3fe55a9207d188a341c3b3c108e4b1fc">StoreLoadedExpressions</a>. See its documentations to learn about the details of their use.</p>
<p><a class="anchor" id="alib_expressions_nested_summary"></a></p><h2>10.6 Summary and Final Notes On Nested Expressions</h2>
<p>Nested expressions is a powerful feature of <b>ALib Expressions</b>, but also needs some thoughtful and knowledgeable user because of the different approaches of compile-time and evaluation-time defined nested expressions.<br />
 If a software offers an end-user to "express herself", a certain level of understanding is anyhow required. Often software hides expression syntax behind a graphical user interface with checkboxes and input fields per "attribute", e.g. to define an email filter and creates an expression string unseen by the user in the background. Then, only in a certain "expert mode" an end-user is allowed to freely expressions, which then may be more complex and probably even allow to "address" nested expressions that such end-user had defined in external configuration resources.</p>
<p>So, it is a bit of a task to define the user interface and user experience when it comes to allowing expressions. This library tries to cover the broad spectrum of use cases and this can probably be noticed in the area of nested expressions very well.</p>
<p>To end this chapter about nested expressions, some final hints and notes should be collected here:</p><ul>
<li>To disallow nested expressions, simply fields <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a5f9dfba67b016bea9547a4f18dd72eb6">CfgNestedExpressionOperator</a> and <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a3ef5c1cb148a564ad0746a78c397ed47">CfgNestedExpressionFunction</a> of class <b>Compiler</b> are to be cleared.</li>
<li>It is undefined behaviour if a nested expression that is successfully identified at compile time is deleted</li>
<li>To disallow compile-time nested expressions only, compilation flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a22d7c4c104e9ab16765d1befc54633cf">AllowCompileTimeNestedExpressions</a> is to be cleared.</li>
<li>To disallow evaluation-time nested expressions only, field <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a3ef5c1cb148a564ad0746a78c397ed47">CfgNestedExpressionFunction</a> is to be cleared. In this case nested expressions are available only using the unary operator.</li>
<li>Compile-time nested expressions are kept in memory automatically, even if <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a9f9a32b69f29fdeee65da34d5e0aeec5">removed</a> from the compiler until the last expression using them is deleted.</li>
<li>Evaluation-time nested expressions may be changed (replaced) prior to evaluating an expression that uses them.</li>
<li>As long as only compile-time nested expressions are used, no circular nesting can occur. As soon as evaluation-time nested expressions are used, circular nesting might happen. The library detects such circular nesting an throws <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea4483b3169767a7b512ef3f1a5573df4e">Exception::CircularNestedExpressions</a> during evaluation. The exception includes informational entries of type <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ead1072e0080997fa27c2e9ab366c329ce">Exception::CircularNestedExpressionsInfo</a> that list the "call stack" of named expressions that caused the circle.</li>
</ul>
<p><a class="anchor" id="alib_expressions_details"></a></p><h1>11. Detail Topics</h1>
<p>In the previous chapters of this manual, most features of module <b>ALib Expressions</b> have been touched, either as tutorial sample code or in a more theoretic fashion. This chapter now provides a list of in-depth discussions on different dedicated topics.</p>
<p><a class="anchor" id="alib_expressions_details_types"></a></p><h2>11.1 Types</h2>
<p>It was a lot said about the intermediate or final result types of expressions in various sections of this manual. The use of underlying run-time type information library <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a> with its very "seamless" nature, helped to implement <b>ALib Expressions</b> tremendously.</p>
<p>But being so seamless, it is not so easy to understand all aspects of its use and meaning in this library. Therefore, this quick chapter tries to review various aspects of the library from the angle of types. For simplification of writing and reading this chapter, this is done with a list of bullet points.</p>
<ul>
<li>A prerequisite to fully understand how type information is handled by this library, is to read and understand the documentation of <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a>. </li>
</ul>
<ul>
<li>This library often uses "sample boxes" that just transport type information. This concept is explained in <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">3.2 Type Definitions With "Sample Boxes"</a>. </li>
</ul>
<ul>
<li>While custom types are to be registered with the compiler using <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a92a56e46c780a383d141f105b52176f1">AddType</a>, such registration is purely used for the generation of exception messages or other sorts of end-user information. It is not necessary otherwise. </li>
</ul>
<ul>
<li>This library follows a "type-safe paradigm". This means that during compilation of expressions each of its terms is determined in respect to what exact type it will result to during evaluation. The disadvantages of this approach are not easy to be named: A non-type-safe library would just look a lot different and it could name advantages along that ultimately different design. Hence we rather talk about the consequences of this library's type safe approach:<ul>
<li>Exceptions are as far as possible happening at compile time.</li>
<li>Choice of overloaded operators and functions happens at compile time, which allows a very performant evaluation. In fact, at evaluation time, the run-time type information included in boxed intermediate result values can mostly be completely ignored in that respect that a callback function does not need to perform checks on its input values in respect to their type: Their implementation just unbox values without doing type checking.<br />
 In this matter, it might be hinted to the fact that library <b>ALib Boxing</b> is designed to not throw runtime exceptions. It rather raises assertions in debug-compilation, e.g. if inconsistent types are tried to be unboxed. In non-debug compilation, a software simply has undefined behaviour (crashes).</li>
<li>Overloaded versions of one operator (or function) can be implement in very separated software units, not "knowing" each other and not interfering with each other. </li>
</ul>
</li>
<li>While it may seem to a user of this library, that for each possible permutation of input parameter types, a distinct callback function has to be provided, this is not the case. The concept of quite strict assignment of such permutations to corresponding callbacks is not hard-coded in the depth of this library, but rather "voluntarily suggested" with using high-level helper struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">plugins::Calculus</a>. By using the underlying type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a> directly, it is possible to provide just one callback function that is enabled to process various combinations of input parameters. The disadvantage of doing so however is that this moves the effort of identifying the types to evaluation-time, which implies a drop of evaluation performance. This is why this library "suggests" to use struct <b>Calculus</b> as the foundation for custom plug-ins. </li>
</ul>
<ul>
<li>Likewise to the previous note, the concept of "variadic function parameters" is not something that arises from the depth of the library, but again comes only with the use of helper struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">plugins::Calculus</a>. It may need some time and thinking about the relationship of structs <b>CompilerPlugin</b> and <b>Calculus</b> to fully grasp the differences and benefits of each. And by the use of virtual functions, in some situations it makes very much sense to mix both concepts, by inheriting a custom plug-in from struct <b>Calculus</b> but still overwriting parts of the underlying interface of <b>CompilerPlugin</b>.<br />
 Such mixed approach is also used with some of the built-in compiler plug-ins. </li>
</ul>
<ul>
<li><p class="startli">The concept of auto-casting of types a located somewhere in the middle! Auto-casts can be fully prevented by providing either a dedicated callback function for each permutation of types or by doing "manual" casts just within a callback function that accepts multiple permutations. Still, this library takes the effort of supporting auto-cast in the details of the implementation of the compilation process which assembles the evaluation program. How it is done can be seen a little like "a last call for help" before throwing a compilation exception.</p>
<p class="startli">The compiler does these calls in two occasions: When a binary operator could not be compiled and when terms <code>T</code> and <code>F</code> of ternary conditional operator <code>Q ? T : F</code> are not of the same type. In this moment, the compiler just calls for help by asking each plug-in for an auto-cast of one or both of the types. It does this only once! After a first plug-in provided some conversion, it is retried to compile the actual operator. If this still fails, the exception is thrown, although it might have been possible that a next plug-in provided a different cast that would lead to success.<br />
 This of-course is a design decision of the library. Complexity was traded against effectiveness. At the end of the day, the whole concept of auto-cast could be described as being not really necessary to do any sort of custom type processing. Therefore, auto-cast is being offered as an optional way of reducing the number of necessarily provided callback functions, that has two disadvantages: First, the auto-cast has to be implemented as a compiler plug-in functionality and second auto-casts increase the length of the evaluation program and hence constitute a penalty on execution performance. </p>
</li>
<li><p class="startli">The variety of built-in types has been reduced to a bare minimum needed. While module <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a> (by default!) already drops the distinction of C++ integral type of different size (<code>short</code>, <code>long</code>, <code>int</code>, etc.), module <b>ALib Expressions</b> in addition drops the distinction between <em>signed</em> and <em>unsigned</em> integral types. All integral types are <em>signed</em>. (Given that the "complete" JAVA programming language dropped unsigned integers, we thought it might not be too problematic).</p>
<p class="startli">The good news for users of this library is that it is no problem to implement support for unsigned types, because "dropping" here just means, that just none of the built-in operators and functions "produces" a result value of unsigned integral type. In other words, unsigned integral types are considered just another custom type.</p>
<p class="startli">If - unexpectedly - unsigned integer types and corresponding operations need to be supported, custom operators and function definitions have to be added. </p>
</li>
<li>To make custom types compatible in full with all features of the library, it might be needed to do some side-implementations along the lines of underlying <b>ALib</b> features. For example, to allow nicely formatted string output of custom data using built-in expression function <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">Format(formatString,...)</a>, boxing interface <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a> and/or <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IFormat.html">IFormat</a> have to be implemented for the custom type. </li>
</ul>
<p><a class="anchor" id="alib_expressions_details_literals"></a></p><h2>11.2 Literals</h2>
<p>While it was in some places of this manual indicated that the built-in types listed with <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html">Types</a> are all "inherently introduced" by the built-in compiler plug-ins just as any custom type could be, this is not the full truth. In fact, types <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Integer</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#aa813c9126cceb582e44aa5a6f4c8a541">Float</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">String</a> are in so far "hard-coded" as values of these types are also created (and thus introduced) by expression "literals".</p>
<p>With the current version of the library it is not possible to change the internal "boxed" types which result from "parsing" an expression. The termin "parsing" denotes the first phase of the compilation of an expression string. Changes on how literals are parsed and in what types such parsing results can only be made by touching the library code, which is not further documented here, but with some explanations in chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_appendix_boostspirit">A.3 Using Built-In Alternative Parser Based On boost::spirit</a></p>
<p><br />
</p>
<h3>11.2.1 Numerical Literals</h3>
<p>The parsing of numerical constants found in expression strings is done with the help of member <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterBase.html#ae24e52b221e908cd2b1e9d689f1ffff4">Formatter::DefaultNumberFormat</a> which in turn is found in member <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a2a8ce7737f852a400bd8c2a366a4d74b">Compiler::CfgFormatter</a>.</p>
<p>The use of this helper type, allows to influence how numerical literals are parsed. For example, integral types can be parsed in decimal, hexadecimal, octal and binary formats. For this a set of prefix symbols, which default to <code>"0x"</code>, <code>"0o"</code> and <code>"0b"</code>, can be customized. The support for one or some of the formats can also be dropped, if this is wanted for whatever reason.</p>
<p>Likewise, the format of floating point numbers and its scientific variants can be defined. In respect to the topic of localization (see also <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_localization">11.6 Localization</a>), this is especially of interest if a different floating-point separation character than <code>'.'</code> is to be supported. It is supported and tested in the unit tests of this library to allow the use of character <code>','</code> as it is standard with many countries. In this case, an end-user has to be only aware of the fact that the two expressions: </p><pre class="fragment">       MyFunc(1,2)
       MyFunc(1 , 2)
</pre><p>have a different meaning: The first is a call to an unary function providing floating point argument <code>1.2</code>, the second is a call to a binary function providing integral values <code>1</code> and <code>2</code>.</p>
<p>Even worse: </p><pre class="fragment">       MyFunc(1,2,3)
</pre><p>is parsed as two arguments, the first being float value <code>1.2</code> and the second integral value <code>3</code>. This means, the end-user has to insert spaces to separate function parameters.</p>
<p>As this is a source of ambiguity, applications that address end-users with a high degree of professionalism, should rather <b>not</b> localize number formats but instead document with their software that english standards are to be used.</p>
<p>In general, all flags and options in respect to parsing and formatting (normalizing) number literals that are available through class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormat</a> are compatible with <b>ALib Expressions</b>. This includes even to set character <code>' '</code> (space) as a grouping character for any number format! This might be used to allow quite nicely readable numbers in expression strings.</p>
<p>Finally, normalization flags <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a26e6c9e720259c80e64083c45921940d">KeepScientificFormat</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a819669ffbb57d51fb0da33d60659520a">ForceHexadecimal</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a6f8a914e5eb5e462278ce1068b1c5318">ForceOctal</a> and <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3ac726a5db3f167dd200d776985a67fb7a">ForceBinary</a> may be used to further tweak how numbers are converted in normalized strings.</p>
<p><br />
</p>
<h3>11.2.2 String Literals</h3>
<p>String literals are to be enclosed in quote characters <code>'"'</code>. If a string literal should contain, the quote character itself, this needs to be "escaped" using backslash character <code>'\'</code>. Some further escape characters are supported, by the internal use of <b>ALib</b> string feature documented with <a class="el" href="structaworx_1_1lib_1_1strings_1_1FormatBase_1_1Escape.html">Format::Escape</a>.</p>
<p>For the output of string literals in the normalized version of expression string, the reverse functions are used. This allows to change the output standards of literals in various ways. For example to output all floating point values given in an expression string in scientific format, flag <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a4abcf6e13582e3d8c9d0dbf893f831f9">NumberFormat::ForceScientific</a> might be set.</p>
<p><br />
</p>
<h3>11.2.3 Boxing Interface IToLiteral</h3>
<p>Ultimately, boxing interface <a class="el" href="structaworx_1_1lib_1_1expressions_1_1IToLiteral.html">IToLiteral</a> might be implemented for one of the types (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#ab1a8ec377690a0cecfd0f3c70e1b970a">Integer</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#aa813c9126cceb582e44aa5a6f4c8a541">Float</a> or <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a99e3e062a37dd9eae9b06b1f2a8ffb14">String</a>) to do any imaginable custom conversions, other than possible with the standards provided by the mechanics of the <b>ALib</b> types used. But this should be seldom needed. The main purpose of this boxing interface is described with <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_optimizations">11.5 Optimizations</a>.</p>
<p><a class="anchor" id="alib_expressions_details_identifiers"></a></p><h2>11.3 Identifiers/Functions</h2>
<p>Identifier (parameterless functions) and function names are recognized (parsed) in expression strings at appropriate places only if the following rules apply:</p><ul>
<li>The name starts with an letter, <code>'a'</code> to <code>'z'</code> or <code>'A'</code> to <code>'Z'</code>.</li>
<li>The rest of the name consits of letters, underscore character <code>'_'</code> and numbers <code>'0'</code> to <code>'9'</code>.</li>
</ul>
<p>In the current version of module <b>ALib Expressions</b>, this is hard-coded and not configurable.</p>
<p><a class="anchor" id="alib_expressions_details_localization"></a></p><h2>11.4 Localization</h2>
<p>In the previous section, information about localizing number formats in respect to parsing expression strings and their output as a normalized expression, was already given.</p>
<p>A second area, where localization may become an obvious requirement is the naming of built-in and custom expression functions. The built-in compiler plug-in use mechanics provided by <b>ALib</b> classes <a class="el" href="classaworx_1_1lib_1_1lang_1_1Resources.html">Resources</a> and <a class="el" href="classaworx_1_1lib_1_1lang_1_1Library.html">Library</a> to externalize the names, letter case sensitivity and optional minimum abbreviation length of identifiers and functions.</p>
<p>These mechanics allow to replace such resources using an arbitrary custom "string/data resource system". With this, it is possible for example to translate certain identifiers (e.g. <b>Minutes</b> or <b>True</b>) to different locales and languages.</p>
<p>Please consult the documentation of these two classes for further information. Furthermore consult the source code of library class <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expressions.html">Expressions</a>, the implementation of struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1FunctionNameDescriptor.html">FunctionNameDescriptor</a> and corresponding namespace function <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#ac54b4e06c01bedff2d6fb8edc9954d22">LoadResourcedFunctionDescriptors</a>.</p>
<p>While there is no detailed documentation or step-by-step sample on how to perform such localization in detail is given, investigating to the source code and documentation of the entities named above, should enable a user of this library to quite quickly succeed in integrating any custom localization mechanics used otherwise with her software.</p>
<p>A third area where localization might become a need are callback functions processing expression data. Again, for formatting and parsing, an instance of <b>ALib</b> class <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterBase.html">Formatter</a>, which has (as was explained above) an instance of <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormat</a> attached.<br />
 A compile-time scope (used with optimizations) is created with virtual method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a9efcd8697703ecbefa94d59252e4c6cc">getCompileTimeScope</a> which in its default implementation attaches the same formatter to the compile-time scope that is used with parsing, namely the one found in <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a2a8ce7737f852a400bd8c2a366a4d74b">CfgFormatter</a>.<br />
 The scope object used for evaluation should be constructed passing again the very same formatter. This way, formatting and number formats remain the same throughout the whole chain of processing an exception and can collectively tweaked through this one instance <b>CfgFormatter</b>.</p>
<p>Finally a fourth area where localization might be applied is when it comes to exceptions during compilation or evaluation of expressions. All exceptions used in this library provide human readable information, which is built from resourced strings and hence can be localized. See chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_exceptions">11.6 Exceptions</a> for details.</p>
<p><a class="anchor" id="alib_expressions_details_optimizations"></a></p><h2>11.5 Optimizations</h2>
<h3>11.5.1 Goals</h3>
<p>The most important design goal of this library is to favour evaluation-time performance over compile-time performance. This way, library is optimized for use cases where a single expression that is compiled only once, is evaluated against many different scopes. The higher the ratio of number of evaluations per expression term is, the more increases the overall process performance when this design principle is applied. This design goal caused a greatest deal of effort and its implications were far reaching.</p>
<p>Also, the concept of "expression optimization", that was touched in this manual various times already, is all about optimizing the evaluation-time performance. The library volunteers to have some efforts at compile-time to shorten the compiled expression program that is run on the built-in virtual machine as much as possible.</p>
<p>A simple sample for optimization might be an expression that calculates the circumference for a given radius. In case the radius is received from the scope with a custom expression identifier <b>Radius</b>, then the expression would be: </p><pre class="fragment">       2 * PI * Radius
</pre><p>If no optimization was applied, each time this expression was evaluated, four callback functions had to be invoked: Two for receiving the values <b>PI</b> and <b>Radius</b> and two for the multiplications. Now, we know that <b>PI</b> is constant and so is the term <b>"2 * PI"</b>. The goal of optimization consequently is to reduce the expression program to just do two callback invocations: one for retrieving the radius from the scope and a second for multiplying the radius with the constant <b>2 * PI</b>.</p>
<p>To express this goal the other way round: An end-user should be allowed to provide operations that introduce some redundancy, but are easier readable and understandable for human beings, without impacting evaluation performance.</p>
<p><br />
</p>
<h3>11.5.2 Optimization Mechanics</h3>
<p>The foundation of compile-time optimization of this library is implemented with the assembly of the expression program: During the assembly, the compiler keeps track of previous results being constant or not. Each time a compiler plug-in is asked to provide compilation information, this information about whether the arguments are all or partly constant is provided. Then it is up to the plug-ins to decide whether the expression term is a constant in turn or implies a callback function call.</p>
<p>In the simple case of identifiers (parameterless functions), no arguments exist and hence all arguments are constant. Nevertheless, custom identifiers are usually not constant, because they return data received from the (custom) scope object. Therefore, the compiler does not "know" if identifier <b>"PI"</b> is a constant, only the plug-in that compiles the identifier knows that. While in the case of <b>PI</b> it is, in the custom case of <b>FileDate</b> it is not: It depends on the currently examined scope data.</p>
<p>This way, the compiler and its plug-ins have to work hand in hand: The compiler provides information about arguments being constant and the plug-ins can return either a callback function or leave the callback function <code>nullptr</code> and return a constant value instead. The compiler then either assembles a callback function or the use of the constant value, which is an internal program command of the virtual machine's "assembly language".</p>
<p>With binary operators, a further option is available: In the case that one operator is constant, while the other is not, some operators might inform the compiler to either optimize out the complete term or at least to optimize out the constant argument. Again, this information has to be encoded in the result data provided by the compiler plug-ins. The compiler will then modify the existing program and remove the program code for one or both arguments. (Further samples of binary operator optimizations are given in documentation of struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CompilerPlugin::CIBinaryOp</a>.)</p>
<p><br />
</p>
<h3>11.5.3 Optimizations Of The Built-In Compiler Plug-ins</h3>
<p>As explained earlier, the built-in compiler plug-ins mostly rely on helper struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">plugins::Calculus</a> instead of deriving directly from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a>. <b>Calculus</b> provides very convenient ways to assure that every operation that can be optimized at compile-time truly is optimized.</p>
<p>For example, callback functions can be denoted "compile-time invokable". If so, helper struct <b>Calculus</b> automatically invokes them at compile-time if all arguments provided are constant (or no arguments are given) and returns the calculated result to the compiler instead of the callback function itself.</p>
<p>Furthermore, struct <b>Calculus</b> provides a special sort of optimization applied to binary operators that may be applied when only one of the two arguments is constant. For example, an arithmetic multiplication with constant <code>0</code> results in <code>0</code> and with constant <code>1</code> it results to the other argument's value. These kind of rules can be encoded using quite simple static data tables.</p>
<p>Overall, the use of struct <b>Calculus</b> makes the implementation of optimization features of custom plug-ins as easy as possible. Consult the struct's <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">documentation</a> for further details.</p>
<p><br />
</p>
<p><a class="anchor" id="alib_expressions_details_optimizations_conditional"></a></p><h3>11.5.4 Compile- And Evaluation-Time Optimization Of The Conditional Operator</h3>
<p>In the current version of <b>ALib Expressions</b> there is only one evaluation-time optimization performed. This considers built-in ternary operator <code>Q ? T : F</code> (conditional operator).</p>
<p>Likewise a C/C++ compiler, depending on the the evaluation-time value of <code>Q</code> only the program code to calculate <code>T</code> or <code>F</code> is executed by the virtual machine.</p>
<dl class="section note"><dt>Note</dt><dd>This is important to be known by end-users: The "side effect" of this optimization is that it does <b>not</b> produce "side effects" that the left-out term might be expected to produce in the case that this optimization was not performed and thus custom callbacks had been invoked for both terms <code>T</code> and <code>F</code> in parallel.</dd></dl>
<p>The optimization of the conditional operator is as well performed at compile-time: In the case that <code>Q</code> is a compile-time constant, the code for either <code>T</code> or <code>F</code> is not even included in the program.</p>
<p><br />
</p>
<h3>11.5.5 Limits Of Optimization</h3>
<p>The current version of this library has an important limit in respect to optimizations. While - as we saw - expression: </p><pre class="fragment">        2 * PI * Radius
</pre><p>is optimized to perform only two callbacks instead of four, the mathematically equivalent expression: </p><pre class="fragment">        2 * Radius * PI
</pre><p>is only optimized by one callback, hence still includes three.</p>
<p>The reason is that there is no built-in mechanics to tell the compiler that for the two multiplications, the associative and commutative laws apply, which would allow to transform the latter expression back to the first one.</p>
<p>Instead, the compiler "sees" two multiplications that both are not performed on constant operands and hence can not be optimized. Only the callback of constant identifier <b>PI</b> is removed.</p>
<p>Consequently, if performance is key, it might be documented to an end-user that she is good to write: </p><pre class="fragment">   HoursPassed  * 60 * 60 * 1000
</pre><p>because this expression is optimized to: </p><pre class="fragment">   HoursPassed * 3600000
</pre><p>but that she should "sort" constants to constants, because expression </p><pre class="fragment">   60 * HoursPassed * 60 * 1000
</pre><p>is less effectively optimized to </p><pre class="fragment">   60 * HoursPassed * 60000
</pre><p>In a more abstract way, it could be stated that a C++ compiler does such optimization, because it "knows" about the rules of the multiply operator of integer values. The compiler of this library does not know about that and hence can not perform these kind of operations. If in the case of C++, the operands were custom types with overloaded operator <code>'*'</code>, the C++ code would also not be optimized, because in this case, the compiler does not know the mathematical "traits" of the operator. The C++ language has no syntax to express operator traits.</p>
<p>From the "point of view" of the expression compiler provided with this library, the built-in operators are just "built-in custom operators". This leads to the inability of optimizing such rather simple mathematics.</p>
<p>With this understood, a next limitation of optimization becomes obvious. Unlike a C++ compiler that surly optimizes expression: </p><pre class="fragment">   IsDirectory &amp;&amp; true
</pre><p>to </p><pre class="fragment">   IsDirectory
</pre><p>and even more at evaluation-time omits the evaluation of right hand operand of expression: </p><pre class="fragment">   IsDirectory &amp;&amp; ( name == "..")
</pre><p>in the case that <b>IsDirectory</b> returned false, this library does not perform such optimization, neither at compile-time nor during evaluation.</p>
<p><br />
</p>
<p><a class="anchor" id="alib_expressions_details_optimizations_norm"></a></p><h3>11.5.6 Optimized Expression Strings</h3>
<p>In the case that professional, experienced end-users are the addressees of a software, it might be wanted to tell such end-users about the result of optimizations. To stay with the sample of the previous sections, this means to be able to show an end-user that the expression: </p><pre class="fragment">   2 * PI * Radius
</pre><p>was optimized to </p><pre class="fragment">   6.283185307179586 * Radius.
</pre><p>To be able to do this, a normalized expression string of the optimized expression has to be generated. This way, the interface of class expressions allows access to three strings with methods</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a2cb8f699abbc3f4878743a66b71d89cc">Expression::GetOriginalString</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a9e5bd8d42c1eba7541d4cc615c366844">Expression::GetNormalizedString</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#af308bc5925a29b75df5cf67a07dc2745">Expression::GetOptimizedString</a></li>
</ul>
<p>The generation of the normalized string during compilation can not be disabled and hence is available in zero time, the same as the original string. However, the first invocation of method <b>GetOptimizedString</b> is all but a constant task! With this, the library <em>"decompiles"</em> the expression program with the result being an abstract syntax tree (AST). This AST is then compiled into an new program and with this compilation a "normalized" expression string is generated.</p>
<p>Consequently, this normalized string is the optimized version of the original expression string! Once done, the AST and the compiled (second) program are disposed, while the optimized string is stored.</p>
<p>It is really questionable if this effort worth the effort! The decision if a software using library <b>ALib Expressions</b> presents "optimized normalized expression strings" to the end-user is highly use-case dependent. In case of doubt our recommendation is to <em>not</em> do it.</p>
<p>In any case, to receive correct optimized expression strings, a last hurdle might have to be taken. In the sample above, the optimized term <code>2 * PI</code> results in floating point value <code>6.283185307179586</code>. This value can easily be written out and - if wanted - later be even parsed back to a correct expression. But this is only the case, because the type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#aa813c9126cceb582e44aa5a6f4c8a541">Float</a> is expressible as a literal. Imagine the following sample: </p><pre class="fragment">   Seconds(1) * 60
</pre><p>Built-in identifier <b>Seconds</b> returns an object of type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html#a51d5b447dda0a9740c8d207617a86d89">Duration</a>. The multiplication operator is overloaded an in turn results in a value of type <b>Duration</b>. And yes, it is a constant value. The challenge now is to produce an expression string that creates a constant time span value representing <code>60</code> seconds. The result needs to be </p><pre class="fragment">   Seconds(60)
</pre><p>or even better: </p><pre class="fragment">   Minutes(1)
</pre><p>To achieve this, this library introduces <b>ALib</b> boxing interface <a class="el" href="structaworx_1_1lib_1_1expressions_1_1IToLiteral.html">IToLiteral</a>. This interface has to be implemented for all custom types that might occur as results of constant expression terms. Only if this is assured, the optimized normalized expression string is correct, meaningful and re-compilable.</p>
<p>For details and a source code sample consult the documentation of the boxing interface class <a class="el" href="structaworx_1_1lib_1_1expressions_1_1IToLiteral.html">IToLiteral</a>.</p>
<p>Besides this boxing interface to create constant expression terms for custom types, a next prerequisite might have to be met to receive compilable expression strings. This is in the area of auto-cast functionality. If custom auto-casts are in place, such auto-casts if decompiled have to be replaced by a function call which takes the original value and returns the casted value. The names of the function has to be provided with members <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html#ab108137efd1032aa1e04d1d4b7ddb5d9">CastExpressionFunctionNameLhs</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html#aa2cda098e262a579b3217b879b48e412">CastExpressionFunctionNameRhs</a> of the auto-cast information struct in the moment an auto-cast is compiled. These fields are not necessary to be set and much more - and corresponding expression functions not to be available - if no optimized, normalized expression strings are generated.</p>
<dl class="section note"><dt>Note</dt><dd>All built-in identifiers, functions, operators and aut-casts are fully compatible with optimized expression strings. Most unit tests provided with this <a class="el" href="alib_man_intro.html">ALib Module</a> perform the "full circle" of compilation and evaluation, which is:<ul>
<li>compile the given expression string and check the evaluation result.</li>
<li>compile the normalized version of the expression string and check the evaluation result.</li>
<li>create the optimized version of the expression string, recompile it and check the evaluation result.</li>
<li>switch off optimization (see next section), compile the original expression string and check the evaluation result.</li>
</ul>
</dd></dl>
<p><br />
</p>
<h3>11.5.7 Disabling Optimization</h3>
<p>While there is no reason to switch off optimization, the library offers compilation flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aa650796c535d9b89b91b1d42f62356eb">Compilation::NoOptimization</a> for completeness.</p>
<p><a class="anchor" id="alib_expressions_details_concurrency"></a></p><h2>11.6 Shared Resources And Concurrent Use</h2>
<p>This library does not make use of <em>semaphores</em> (aka "thread locks") to protect resources against violating concurrent access. Consequently, it is up to the user of the library to assure some rules and potentially implement semaphores if needed.</p>
<p>Therefore, this chapter lists the rules of allowed and denied parallel actions:</p>
<ul>
<li>Changes of compiler properties, for example the use of method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a92a56e46c780a383d141f105b52176f1">Compiler::AddType</a> is forbidden as a parallel task of compilation (with the same compiler object). </li>
</ul>
<ul>
<li>Addition and removal of named expressions must not be performed in parallel and during parallel compilation of expressions that use nested expressions. </li>
</ul>
<ul>
<li>The parallel compilation of one or more expressions using the same compiler object is allowed, as long custom compiler-plugins allow concurrent use. (All built-in compiler plug-ins do allow this.) </li>
</ul>
<ul>
<li><p class="startli">The parallel evaluation of a set of different expressions originating from the same compiler is allowed, if:</p><ul>
<li>different evaluation scope objects are used.</li>
<li>custom callback functions allow parallel invocation (the built-in callbacks do allow this).</li>
</ul>
<p class="startli">The parallel evaluation of one single expression is allowed, if besides the previous conditions, it is assured that:</p><ul>
<li><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_scopes_ctresources">Compile-time resources used at evaluation time</a> allow such use.</li>
</ul>
</li>
</ul>
<p><a class="anchor" id="alib_expressions_details_exceptions"></a></p><h2>11.7 Exceptions</h2>
<h3>11.7.2 Catching Exceptions</h3>
<p>In the moment end-users are allowed to provide expression strings, some error handling due to malformed strings are unavoidable. Module <b>ALib Expressions</b> chooses to implement error handling using C++ exceptions.</p>
<p>One of the design goals of this library is to allow to recognize erroneous expressions at compile-time if possible. The advantage of this is that this is a point in time where the consequences of exception are usually far more "harmless". Of-course, a software can not continue its tasks if exceptions occur, but the implicated effort of performing a "rollback" should be much lower.</p>
<p>For this, the following general approach should be taken:</p><ol type="1">
<li>Compile expressions</li>
<li>On exceptions inform the end user (e.g. stop program)</li>
<li>Allocate resources (scope) needed.</li>
<li>Evaluate expressions</li>
<li>On exceptions rollback resource allocations and inform the end user (e.g. stop program)</li>
</ol>
<p>As evaluation-time exceptions anyhow can occur, in simple cases step 2 might be left and step 1-4 be wrapped in one <code>try</code> statement.</p>
<p>The exception object thrown by any <a class="el" href="alib_man_intro.html">ALib Module</a> is <a class="el" href="classaworx_1_1lib_1_1lang_1_1Exception.html">aworx::lib::lang::Exception</a>. This class combines the advantages of two paradigms frequently discussed as alternative approaches to exception handling. For more information consult the classes' <a class="el" href="classaworx_1_1lib_1_1lang_1_1Exception.html">documentation</a>.</p>
<p>With the use of this class, the exceptions thrown by the library could be conveniently gathered in a C++ enumeration class equipped with <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">resourced enum meta data</a>. Hence, the default exception descriptions can be evenly translated to other languages like other resourced, localizable strings.</p>
<p>This enum classes' documentation consequently provides the <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06e">reference documentation</a> to exceptions thrown by this library.</p>
<h3>11.7.2 Exceptions In <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> Plug-Ins</h3>
<p>A compiler plug-in of-course may throw an exception during compilation. Helper struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a> for example throws exceptions <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea57654071c3e481cb5feaf7df3ed76e28">MissingFunctionParentheses</a> and <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eaa0aa3add0d452711cd2015bbafa46be1">IdentifierWithFunctionParentheses</a>. Furthermore, a callback function may throw an exception during the compile-time evaluation of a constant expression term.</p>
<p>In any of the two cases, exceptions of type of type <code>std::exception</code> as well as those of type <b>aworx::Exception</b> that are not of type <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06e">expressions::Exceptions</a>, by default are "wrapped" into <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea62b023dd547d643d9814a476902bf7e2">ExceptionInPlugin</a>. This wrapping can be disabled by setting flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a138ad7df5ea6b2421f8e49afa0eda153">Compilation::PluginExceptionFallThrough</a>.</p>
<p>In any case, plug-in exceptions of type <b>aworx::Exception</b> are extended by an informational entry of type <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea3f91d67ae8180182f841199841119f14">ExpressionInfo</a>.</p>
<p>Other exception types are never caught and wrapped and therefore have to be caught in a custom way.<br />
</p>
<h3>11.7.3 Evaluation-Time Exceptions In Callback Functions</h3>
<p>In the case that a callback function throws an exception during the evaluation of an expression, such exception by default are "wrapped" into <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea8a2a0e7d8ec919b71accc1e0ecaf141c">ExceptionInCallback</a>. Wrapping is performed with exceptions of type <code>std::exception</code> and <b>ALib</b> <b>Exception</b>. Other exception types are never caught and wrapped and therefore have to be caught in a custom way.</p>
<p>The optional wrapping of evaluation-time exceptions can be disabled by setting flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aa4b0631c4c1945fdaf86a32a0e357615">Compilation::CallbackExceptionFallThrough</a>. Note, that while this is collected together with the other flags in member <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ab80df79edf00c08ed5f7b74b48f5f0f6">Compiler::CfgCompilation</a>, in fact, this flag is tested only at evaluation time, right in the moment an exception arises!</p>
<p><a class="anchor" id="alib_expressions_appendix"></a></p><h1>A. Appendix</h1>
<p><a class="anchor" id="alib_expressions_appendix_vm"></a></p><h2>A.1 The Built-In Virtual Machine</h2>
<p>Talking about a virtual machine, most people today would consider the JAVA Virtual Machine as good sample. While this is true and comparable, the machine that is included in this library is one million times simpler. In fact, the current implementation that executes an expression program consists of less than <code>300</code> lines of code.</p>
<p>The machine is really a very simple stack machine and implements only just <b>five commands</b>!</p>
<p>For those who are interested in how the machine works, besides investigating into its source code a quick look at the program code it consumes leads to a quick understanding.</p>
<p>In debug compilation of the software, static method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1VirtualMachine.html#a8ea31517f6995455a2e5a3cc4e698cb8">VirtualMachine::DbgList</a> may be invoked to generate a listing of a given expression's program. With the listing, the expression string is given. Therefore, in this chapter, we just sample the listing output, without sampling the expressions explicitily.</p>
<p>Let's have an easy start with a simple expression of a constant value: </p><div class="fragment"><div class="line">-------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">-------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {42}</div><div class="line"></div><div class="line">PC | ResultType | Command  | Param | Stack | Description      | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>} | 42</div><div class="line">-------------------------------------------------------------------------------------------</div><div class="line">00 | Integer    | Constant | <span class="stringliteral">&#39;42&#39;</span>  |     1 | Literal constant |                   |_^_</div></div><!-- fragment --><p> This shows the first command <code>"Constant"</code>, which pushes a constant value (given with the command) to the stack.</p>
<p>Lets do some multiplication: </p><div class="fragment"><div class="line">---------------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">---------------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {42 * 2}</div><div class="line"></div><div class="line">PC | ResultType | Command  | Param | Stack | Description           | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>} | 42 * 2</div><div class="line">---------------------------------------------------------------------------------------------------</div><div class="line">00 | Integer    | Constant | <span class="stringliteral">&#39;84&#39;</span>  |     1 | Optimization constant |                   |   _^_</div></div><!-- fragment --><p> Ooops, it is still one command, which includes the result. This is due to the optimizing compiler that detected two constants and thus we have still a constant expression program.<br />
 We now have two options: Use non-constant functions like built-in math function <em>Random</em>, or just <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aa650796c535d9b89b91b1d42f62356eb">switch off optimization</a>. The latter is what we do: </p><div class="fragment"><div class="line">-----------------------------------------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">-----------------------------------------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {42 * 2}</div><div class="line"></div><div class="line">PC | ResultType | Command  | Param      | Stack | Description                                | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>} | 42 * 2</div><div class="line">-----------------------------------------------------------------------------------------------------------------------------</div><div class="line">00 | Integer    | Constant | <span class="stringliteral">&#39;42&#39;</span>       |     1 | Literal constant                           |                   |_^_</div><div class="line">01 | Integer    | Constant | <span class="charliteral">&#39;2&#39;</span>        |     2 | Literal constant                           |                   |     _^_</div><div class="line">02 | Integer    | Function | mul_II(#2) |     1 | Binary <span class="keyword">operator</span> <span class="charliteral">&#39;*&#39;</span>, CP=<span class="stringliteral">&quot;ALib Arithmetics&quot;</span> | 0{0..0}, 1{1..1}  |   _^_</div></div><!-- fragment --><p> We now see two pushes and then an invocation of the callback function. VM-commmand <code>"Function"</code> invokes callbacks. In this case one named "mul_II", which implements operator <code>'*'</code> consuming two integer arguments. Those arguments will be taken from the current execution stack. The result of the callback will be pushed to the stack.</p>
<dl class="section note"><dt>Note</dt><dd>A correct expression program leaves one value at the stack when finished. This value is the result value of the expression.</dd></dl>
<p>In column "Description" the listing tells us that the callback "mul_II" in the third and final program command was compiled by plug-in "ALib Arithmetics" with operator <code>'*'</code>. Such information is debug-information and not available in release compilations of the library.</p>
<p>We now know two out of five virtual machine commands and already quite complex expressions can be compiled: </p><div class="fragment"><div class="line">---------------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">---------------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {(42 * 2 / 5) * (2 + 3) * 7}</div><div class="line"></div><div class="line">PC | ResultType | Command  | Param      | Stack | Description                                | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>} | (42 * 2 / 5) * (2 + 3) * 7</div><div class="line">---------------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line">00 | Integer    | Constant | <span class="stringliteral">&#39;42&#39;</span>       |     1 | Literal constant                           |                   | _^_</div><div class="line">01 | Integer    | Constant | <span class="charliteral">&#39;2&#39;</span>        |     2 | Literal constant                           |                   |      _^_</div><div class="line">02 | Integer    | Function | mul_II(#2) |     1 | Binary <span class="keyword">operator</span> <span class="charliteral">&#39;*&#39;</span>, CP=<span class="stringliteral">&quot;ALib Arithmetics&quot;</span> | 0{0..0}, 1{1..1}  |    _^_</div><div class="line">03 | Integer    | Constant | <span class="charliteral">&#39;5&#39;</span>        |     2 | Literal constant                           |                   |          _^_</div><div class="line">04 | Integer    | Function | div_II(#2) |     1 | Binary <span class="keyword">operator</span> <span class="charliteral">&#39;/&#39;</span>, CP=<span class="stringliteral">&quot;ALib Arithmetics&quot;</span> | 0{0..2}, 1{3..3}  |        _^_</div><div class="line">05 | Integer    | Constant | <span class="charliteral">&#39;2&#39;</span>        |     2 | Literal constant                           |                   |                _^_</div><div class="line">06 | Integer    | Constant | <span class="charliteral">&#39;3&#39;</span>        |     3 | Literal constant                           |                   |                    _^_</div><div class="line">07 | Integer    | Function | add_II(#2) |     2 | Binary <span class="keyword">operator</span> <span class="charliteral">&#39;+&#39;</span>, CP=<span class="stringliteral">&quot;ALib Arithmetics&quot;</span> | 0{5..5}, 1{6..6}  |                  _^_</div><div class="line">08 | Integer    | Function | mul_II(#2) |     1 | Binary <span class="keyword">operator</span> <span class="charliteral">&#39;*&#39;</span>, CP=<span class="stringliteral">&quot;ALib Arithmetics&quot;</span> | 0{0..4}, 1{5..7}  |             _^_</div><div class="line">09 | Integer    | Constant | <span class="charliteral">&#39;7&#39;</span>        |     2 | Literal constant                           |                   |                         _^_</div><div class="line">10 | Integer    | Function | mul_II(#2) |     1 | Binary <span class="keyword">operator</span> <span class="charliteral">&#39;*&#39;</span>, CP=<span class="stringliteral">&quot;ALib Arithmetics&quot;</span> | 0{0..8}, 1{9..9}  |                       _^_</div></div><!-- fragment --><p> Column "ArgNo" denotes for each argument the program code lines which are responsible for calculating it on the stack. In other words: each block of code <b>"x..y"</b> noted in this column produces exactly one result value on the stack, just as the whole expression produces one.</p>
<p>The following sample uses a function that consumes three arguments: </p><div class="fragment"><div class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {<a class="code" href="namespaceaworx.html#a1560a557676f73ac8ce95f0f192a6957">Format</a>( <span class="stringliteral">&quot;Result of: {}&quot;</span>, <span class="stringliteral">&quot;2 * 3&quot;</span>, 2 * 3 )}</div><div class="line"></div><div class="line">PC | ResultType | Command  | Param           | Stack | Description                                | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>}         | <a class="code" href="namespaceaworx.html#a1560a557676f73ac8ce95f0f192a6957">Format</a>( <span class="stringliteral">&quot;Result of: {}&quot;</span>, <span class="stringliteral">&quot;2 * 3&quot;</span>, 2</div><div class="line">* 3 )</div><div class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line">00 | <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>     | Constant | <span class="stringliteral">&quot;Result of: {}&quot;</span> |     1 | Literal constant                           |                           |        _^_</div><div class="line">01 | <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>     | Constant | <span class="stringliteral">&quot;2 * 3&quot;</span>         |     2 | Literal constant                           |                           |                         _^_</div><div class="line">02 | Integer    | Constant | <span class="charliteral">&#39;2&#39;</span>             |     3 | Literal constant                           |                           |                                 </div><div class="line">_^_</div><div class="line">03 | Integer    | Constant | <span class="charliteral">&#39;3&#39;</span>             |     4 | Literal constant                           |                           |                                    </div><div class="line"> _^_</div><div class="line">04 | Integer    | Function | mul_II(#2)      |     3 | Binary <span class="keyword">operator</span> <span class="charliteral">&#39;*&#39;</span>, CP=<span class="stringliteral">&quot;ALib Arithmetics&quot;</span> | 0{2..2}, 1{3..3}          |                                   </div><div class="line">_^_</div><div class="line">05 | <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>     | Function | <a class="code" href="namespaceaworx_1_1lib_1_1expressions_1_1plugins.html#a128ae57e3f8f0dadfb50e4c4f891aff6">CBFormat</a>(#3)    |     1 | Function <span class="stringliteral">&quot;Format(#3)&quot;</span>, CP=<span class="stringliteral">&quot;ALib Strings&quot;</span>   | 0{0..0}, 1{1..1}, 2{2..4} |_^_</div></div><!-- fragment --><p> Now, as these two VM-commands are understood, lets proceed with two further ones. For implementing the ternary conditional operator <code>Q ? T : B</code> we need two types of jumps. A conditional jump and an unconditioned one: </p><div class="fragment"><div class="line">--------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">--------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {<span class="keyword">true</span> ? 1 : 2}</div><div class="line"></div><div class="line">PC | ResultType | Command     | Param        | Stack | Description                                  | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>} | <span class="keyword">true</span> ? 1 : 2</div><div class="line">--------------------------------------------------------------------------------------------------------------------------------------------</div><div class="line">00 | Boolean    | Constant    | <span class="stringliteral">&#39;true&#39;</span>       |     1 | Optimization constant, CP=<span class="stringliteral">&quot;ALib Arithmetics&quot;</span> |                   |_^_</div><div class="line">01 | <a class="code" href="namespaceaworx_1_1lib_1_1config.html#a4f738b6463e8c773284e5173741814ddab50339a10e1de285ac99d4c3990b8693">NONE</a>       | JumpIfFalse | 4 (absolute) |     1 | <span class="charliteral">&#39;?&#39;</span>                                          | 0{0..0}           |     _^_</div><div class="line">02 | Integer    | Constant    | <span class="charliteral">&#39;1&#39;</span>          |     2 | Literal constant                             |                   |       _^_</div><div class="line">03 | <a class="code" href="namespaceaworx_1_1lib_1_1config.html#a4f738b6463e8c773284e5173741814ddab50339a10e1de285ac99d4c3990b8693">NONE</a>       | Jump        | 5 (absolute) |     2 | <span class="charliteral">&#39;:&#39;</span>                                          | 0{2..2}           |         _^_</div><div class="line">04 | Integer    | Constant    | <span class="charliteral">&#39;2&#39;</span>          |     3 | Literal constant                             |                   |           _^_</div></div><!-- fragment --><p> Note that while the program listing for convenience presents the destination address using the absolute program counter (first column "PC") number, internally relative addressing is used. The insertion of the two jump commands explains what is said in <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_optimizations_conditional">11.5.4 Compile- And Evaluation-Time Optimization Of The Conditional Operator</a>.<br />
 Just for fun, we enable compile-time optimization and check the output: </p><div class="fragment"><div class="line">--------------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">--------------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {<span class="keyword">true</span> ? 1 : 2}</div><div class="line"></div><div class="line">PC | ResultType | Command  | Param | Stack | Description      | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>} | <span class="keyword">true</span> ? 1 : 2</div><div class="line">--------------------------------------------------------------------------------------------------</div><div class="line">00 | Integer    | Constant | <span class="charliteral">&#39;1&#39;</span>   |     1 | Literal constant |                   |       _^_</div></div><!-- fragment --><p>The fifth and final command <code>"Subroutine"</code> is needed to allow <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested">Nested Expressions</a>. We add an expression named "nested" and refer to it: </p><div class="fragment"><div class="line">----------------------------------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">----------------------------------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {*nested}</div><div class="line"></div><div class="line">PC | ResultType | Command    | Param     | Stack | Description                           | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>} | *nested</div><div class="line">----------------------------------------------------------------------------------------------------------------------</div><div class="line">00 | Integer    | Subroutine | *<span class="stringliteral">&quot;nested&quot;</span> |     1 | Nested expr. searched at compile-time |                   |_^_</div></div><!-- fragment --><p> Using the alternative version that locates nested expressions at evaluation-time only, the program looks like this: </p><div class="fragment"><div class="line">---------------------------------------------------------------------------------------------------------------------------------------</div><div class="line"><a class="code" href="namespaceaworx.html#a64f75e0bd4cad92e475ad9a92812ecf9">ALib</a> Expression <a class="code" href="namespaceaworx.html#a3858cc3d05be0523516c84fd5cb97bc0">Compiler</a></div><div class="line">(c) 2018 AWorx GmbH. Published under MIT License (Open Source).</div><div class="line">More <a class="code" href="namespaceaworx_1_1lib_1_1lox.html#abf3be10d03894afb391f3a2935e3b313a4059b0251f66a18cb56f544728796875">Info</a>: https:<span class="comment">//github.com/AlexWorx/ALib-Class-Library.</span></div><div class="line">---------------------------------------------------------------------------------------------------------------------------------------</div><div class="line">Expression name: ANONYMOUS</div><div class="line">     Normalized: {Expression( nested, -1, <span class="keywordflow">throw</span> )}</div><div class="line"></div><div class="line">PC | ResultType | Command    | Param                   | Stack | Description                              | ArgNo{Start..<a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a>} |</div><div class="line">Expression( nested, -1, <span class="keywordflow">throw</span> )</div><div class="line">---------------------------------------------------------------------------------------------------------------------------------------</div><div class="line">00 | <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>     | Constant   | <span class="stringliteral">&quot;nested&quot;</span>                |     1 | Literal constant                         |                   |        </div><div class="line">   _^_</div><div class="line">01 | Integer    | Constant   | <span class="stringliteral">&#39;-1&#39;</span>                    |     2 | Literal constant                         |                   |        </div><div class="line">           _^_</div><div class="line">02 | Integer    | Subroutine | Expr(name, type, <span class="keywordflow">throw</span>) |     1 | Nested expr. searched at evaluation-time |                   |_^_</div></div><!-- fragment --><p> With these few simple samples, all five commands of class <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1VirtualMachine.html">VirtualMachine</a> are covered.</p>
<p>Being a debug-feature only, no other documentation about program listings and the virtual machine is given in this manual, apart from this appendix chapter.</p>
<p><a class="anchor" id="alib_expressions_appendix_architecture"></a></p><h2>A.2 Notes On The Architecture Of The Library</h2>
<p>This quick chapter is not needed to be read. We just felt to write it quickly for those people who want to take the source code and understand how module <b>ALib Expressions</b> was implemented, and maybe want to extend it or add internal features.</p>
<p>Often, there are two different perspectives needed when you think about the architecture of a software library. The first is from the viewpoint of the user of the library. This may be called the "API perspective". It basically asks: What types do I need to create and which methods do I need to invoke? The second is from the implementer's perspective. Here, it is more about what types implement which functionality and how do they interact internally.<br />
 With the development of this small library, these two perspectives had been in a constant internal fight. The decision was taken to follow the needs of the API perspective.</p>
<p>A user of the library just needs to "see":</p><ul>
<li>Type <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a>, which she extends with custom derivates of</li>
<li>type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a> . Together, these create objects of</li>
<li>type <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html">Expression</a>, which, under provision of an object of</li>
<li>type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a> become evaluated. That's roughly it. Very simple.</li>
</ul>
<p>From an implementation perspective there is some more things:</p><ul>
<li>Expression strings need to be parsed into an abstract syntax tree (AST),</li>
<li>ASTs need to be compiled into a program,</li>
<li>Programs need to be executed by a virtual machine,</li>
<li>Optimized programs need to be decompiled back into ASTs to create normalized, optimized expression strings.</li>
</ul>
<p>To keep the types that are needed from the API-perspective clean and lean, responsibilities had been moved into maybe "unnatural" places. Some more quick bullets and we have said what this quick chapter aimed to say:</p><ul>
<li>All types not unnecessary for the user are abstract and show only a minimum set of interface methods. Corresponding implementations have been shifted to sub-namespace <b>detail</b>. The differentiation between the abstract base and the implementation is a pure design decision. It even costs some nanoseconds of overhead, by invoking virtual functions, where no such abstract concept is technically needed. (It also reduces compile time for a user's software)</li>
<li>To keep class <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> clean, it just contains configuration options and holds the plug-ins, while</li>
<li>the compilation itself is implemented in class <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1Program.html">detail::Program</a>! From the implementers perspective (that we willingly ignored) a class named "Program" should please not compile and assemble itself. Well, but it does. If it didn't, the class would probably not exist: It would be just a <code>std::vector</code> of virtual machine commands residing in the expression. Therefore, it just was a nice empty thing that we put the assembly stuff in to keep class Compiler free of that.</li>
<li>Well, and we admit: to keep the program concentrating on just assembly, the virtual machine has besides its duty to run programs, two other responsibilities: The first can be almost considered "OK": In debug-compilations of the library, it creates program listings. But then:</li>
<li>The virtual machine decompiles programs back to ASTs!</li>
</ul>
<p>Have you ever seen a virtual machine that does decompilation? And that therefore knows about ASTs, which otherwise constitute the intermediate data layer between a parser and a compiler? Please do not blame us. We do not foresee bigger feature updates of this library. If such were needed, this code design certainly would quickly fail and needed due refactoring. But as we did it, its a compromise strongly towards simplicity of the API as well of internal code. Again, we love "Bauhaus Code Style".</p>
<p><a class="anchor" id="alib_expressions_appendix_boostspirit"></a></p><h2>A.3 Using Built-In Alternative Parser Based On boost::spirit</h2>
<p>With the first implementation of this library, we relied on third-party library <a href="http://www.boost.org/doc/libs/1_66_0/libs/spirit/doc/html/index.html">boost::spirit</a> to do the job of parsing the expression string into an abstract syntax tree.</p>
<p>However, there were two some downsides involved using the spirit parser, those are:</p><ul>
<li>High compilation time of the library code.</li>
<li>Huge increase of code size of the library (x 10 in debug, x 3 in release mode).</li>
<li>Strong exponential growth rate of parsing time of expressions according to their length and complexity, which quite quickly is in the range of seconds and minutes.</li>
</ul>
<p>While the first two points might be acceptable in most cases, the third is definitely not for production systems. The following sample expression of the unit tests: </p><div class="fragment"><div class="line">    EXPRESSION(    GetDayOfWeek(<a class="code" href="namespaceaworx.html#af0dfbf0475dcf617b7eae4218b3277c0">DateTime</a>(2018, 2, 12)) == Monday</div><div class="line">                &amp;&amp; GetDayOfWeek(<a class="code" href="namespaceaworx.html#af0dfbf0475dcf617b7eae4218b3277c0">DateTime</a>(2018, 2, 13)) == Tue</div><div class="line">                &amp;&amp; GetDayOfWeek(<a class="code" href="namespaceaworx.html#af0dfbf0475dcf617b7eae4218b3277c0">DateTime</a>(2018, 2, 14)) == Wed</div><div class="line">                &amp;&amp; GetDayOfWeek(<a class="code" href="namespaceaworx.html#af0dfbf0475dcf617b7eae4218b3277c0">DateTime</a>(2018, 2, 15)) == thu</div><div class="line">                &amp;&amp; GetDayOfWeek(<a class="code" href="namespaceaworx.html#af0dfbf0475dcf617b7eae4218b3277c0">DateTime</a>(2018, 2, 16)) == fri</div><div class="line">                &amp;&amp; GetDayOfWeek(<a class="code" href="namespaceaworx.html#af0dfbf0475dcf617b7eae4218b3277c0">DateTime</a>(2018, 2, 17)) == sat</div><div class="line">                &amp;&amp; GetDayOfWeek(<a class="code" href="namespaceaworx.html#af0dfbf0475dcf617b7eae4218b3277c0">DateTime</a>(2018, 2, 18)) == sun    , <span class="keyword">true</span> , 1);</div></div><!-- fragment --><p> takes already several minutes to be parsed in debug compilations and still 23 seconds with optimized release code. On the same machine, the hand-written parser does the job in around 70 micro seconds in debug version and just 20 micro seconds with optimized release code (which is one millionth of the time!).</p>
<dl class="section note"><dt>Note</dt><dd>This should not diminish the value of that library. Especially, we think it is a master piece of art-work in respect what can be achieved using C++ template meta programming.<br />
 We love that library and we adore the mind-boggling programming skills of its creators. We just were not able to use it in a performant way. Maybe we did something wrong?</dd></dl>
<p>Therefore, we dropped the code and replaced it by a hand written parser that is dedicated to this single job and this way is much smaller in code this and performs very well. The effort was around two days of work, while it took us probably six or seven days to understand the syntax and make the boost version work.</p>
<p>But we have kept the <b>boost::spirit</b> code inside. It is switchable using compiler symbol <a class="el" href="group__GrpALibCompilerSymbols.html#gaf136626b99cf399b2378f156f7394fad">ALIB_FEAT_EXPRESSIONS_SPIRIT_PARSER_ON</a>.</p>
<p>Nevertheless, not all features of this library have been updated, which means with the activation of the alternative <code>boost::spirit</code> parser, some features silently (!) disappear. Those are among others:</p><ul>
<li>Changes of literal number format (localization)</li>
<li>String escape sequences</li>
<li>Less accurate and verbose exception messages with incorrect expression strings.</li>
</ul>
<p>Even more, the support for built-in boost::spirit parser might be completely dropped with a future version of this library.</p>
<p>The main reason for providing the alternative implementation is to allow people to play around with it. It could well be the case that we just not used <code>boost::spirit</code> in the way it is meant to be. There is quite some contrary discussion going on in the internet and some people say that performance it is all about intelligent rule design. However - we just gave up!</p>
<p>The activation and use of <code>boost::spirit</code> is therefore considered <b>experimental!</b> </p>
<p><a class="anchor" id="alib_expressions_referencedox"></a></p><h1>Namespace Reference Documentation</h1>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Nested namespaces</h2></td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1expressions_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1expressions_1_1plugins"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions_1_1plugins.html">plugins</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html">Expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expressions.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1FunctionNameDescriptor.html">FunctionNameDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1IToLiteral.html">IToLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1ScopeResource.html">ScopeResource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1Types.html">Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2a7531e7fd496a49e09cb73b15883e5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> = std::vector&lt; <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> &gt;::iterator</td></tr>
<tr class="separator:a2a7531e7fd496a49e09cb73b15883e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84930fc6785d99ed8a3240026868e3a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a> = <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>(*)(<a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a> &amp;scope, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd)</td></tr>
<tr class="separator:a84930fc6785d99ed8a3240026868e3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acf6b6bfac7fa43e11ddb36084e9270"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> = std::shared_ptr&lt; <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html">Expression</a> &gt;</td></tr>
<tr class="separator:a0acf6b6bfac7fa43e11ddb36084e9270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6440e699eaabf1d1353221727a656a91"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> = const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::lib::boxing::Box</a> &amp;</td></tr>
<tr class="separator:a6440e699eaabf1d1353221727a656a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a54935d405a62c0faf5bea2a1bde5f5e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6">Compilation</a> { <br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6ae9f3440b954250aa73cdd7b581883aa6">DefaultUnaryOperators</a> = (1 &lt;&lt; 1), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a144ad6ed8ecb79321f451c63c28d5682">DefaultBinaryOperators</a> = (1 &lt;&lt; 2), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a145a0ec7809a34f20bc66962fac93e1f">DefaultAlphabeticOperatorAliases</a> = (1 &lt;&lt; 3), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aad457d1ed07ef3f48c5210b3ec9918f5">AlphabeticOperatorsIgnoreCase</a> = (1 &lt;&lt; 4), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6acbaabe778a87cc0fd64af374e094f5e5">AllowSubscriptOperator</a> = (1 &lt;&lt; 5), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6abe80c37b4a47cbebdb18e6e070cc7804">AliasEqualsOperatorWithAssignOperator</a> = (1 &lt;&lt; 6), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a88c96a668631a41aeda561bb21a0a8f3">AllowBitwiseBooleanOperations</a> = (1 &lt;&lt; 7), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6af99be5385d3007b8067845d16b783d95">AllowOmittingParenthesesOfParameterlessFunctions</a> = (1 &lt;&lt; 8), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a4bc38069ae187399f7ee2aae7675c502">AllowEmptyParenthesesForIdentifierFunctions</a> = (1 &lt;&lt; 9), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a22d7c4c104e9ab16765d1befc54633cf">AllowCompileTimeNestedExpressions</a> = (1 &lt;&lt; 10), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a9887dccddfdbf3fe697c4ff1b66994fb">AllowIdentifiersForNestedExpressions</a> = (1 &lt;&lt; 11), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a84c8262d7f9e1ddf967be19e8fc94445">CaseSensitiveNamedExpressions</a> = (1 &lt;&lt; 12), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a138ad7df5ea6b2421f8e49afa0eda153">PluginExceptionFallThrough</a> = (1 &lt;&lt; 13), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aa4b0631c4c1945fdaf86a32a0e357615">CallbackExceptionFallThrough</a> = (1 &lt;&lt; 14), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aa650796c535d9b89b91b1d42f62356eb">NoOptimization</a> = (1 &lt;&lt; 20), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6ad7e9527bddfdd1624933e7dfe3f2a145">UseSpiritParser</a> = (1 &lt;&lt; 21), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a>
<br />
 }</td></tr>
<tr class="separator:a54935d405a62c0faf5bea2a1bde5f5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d77f919179e44f6147a0ef9352e59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59">CompilePriorities</a> { <br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59ab50339a10e1de285ac99d4c3990b8693">NONE</a> = 0, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59afd2a10e79262f97f1a1bc6cd9674080d">ElvisOperator</a> = 100, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59a1a7f2767d842b1a20a65ae37dfc78031">AutoCast</a> = 200, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59a89be9433646f5939040a78971a5d103a">Strings</a> = 300, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59a719f9a005b2305b85fd3af7c81e8df83">Arithmetics</a> = 400, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59aa49950aa047c2292e989e368a97a3aae">Math</a> = 500, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59a56ca15e0327fcb7a7f71e883d5c3c62a">DateAndTime</a> = 600, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59a90589c47f06eb971d548591f23c285af">Custom</a> = 1000
<br />
 }</td></tr>
<tr class="separator:add6d77f919179e44f6147a0ef9352e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0ed589fdc639cb09d1513b11814fd1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1">DefaultAlphabeticBinaryOperatorAliases</a> { <br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1ac33315685a0cba3ce53be378b3c7874b">And</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a3a2d5fe857d8f9541136a124c2edec6c">Or</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a20c4c6104a283ee7383776e722439342">Sm</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1aafc493b6574d5529ed0ffa6f18f05b20">Smaller</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a50a6512f6f88d29531af72e44b7d4425">SmEq</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a0b34de228330eaf78458a0949acb3aa6">SmallerOrEqual</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a8768a6821cd735aea4f5b0df88c1fc6a">Greater</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1ab73291c688b4e09541e686213c2332da">GtEq</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a6f2f0aefb3d22da0f3839453add5f937">GreaterOrEqual</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a0ccb67e7eaae09d9e4078d161eeca100">Equals</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1af27cd6656e2a46007ddac7452d9b04c9">NEq</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1a19bb0af2c3c530538cb41aff7f235b96">NotEqual</a>
<br />
 }</td></tr>
<tr class="separator:a4e0ed589fdc639cb09d1513b11814fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f95def0989e9693f2b804f05918c81"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a97f95def0989e9693f2b804f05918c81">DefaultAlphabeticUnaryOperatorAliases</a> { <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a97f95def0989e9693f2b804f05918c81aa74c05d080620f087c4e523977230666">Not</a>
 }</td></tr>
<tr class="separator:a97f95def0989e9693f2b804f05918c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595a79d00daf9c4d4b1f603600471325"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325">DefaultBinaryOperators</a> { <br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325ab50339a10e1de285ac99d4c3990b8693">NONE</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a928558e2f9712e38d447d674f2672200">Subscript</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325ae257376d913f3b53cbb4a9b19d770648">Multiply</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a0b914e196182d02615487e9793ecff3d">Divide</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a4cde2424cf960a70b7fc5fda1119143d">Modulo</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325aec211f7c20af43e742bf2570c3cb84f9">Add</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a1d9baf077ee87921f57a8fe42d510b65">Subtract</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325ad9382145a142cc7df5f733332c9cb812">ShiftLeft</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325af17de5e0ea7a357b755aa9deeaf38f86">ShiftRight</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325aafc493b6574d5529ed0ffa6f18f05b20">Smaller</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a0b34de228330eaf78458a0949acb3aa6">SmallerOrEqual</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a8768a6821cd735aea4f5b0df88c1fc6a">Greater</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a6f2f0aefb3d22da0f3839453add5f937">GreaterOrEqual</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325af5f286e73bda105e538310b3190f75c5">Equal</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a19bb0af2c3c530538cb41aff7f235b96">NotEqual</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325ae5c7b3dc6fa17e0c1d0586d1a169c77d">BitAnd</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a710384afa7bbbef1ec4956730c792af8">BitXOr</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a04306ca0b4b3ed9a5cedc16d4acbc2b8">BitOr</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a261878dd037f1da40e3e4e0c4d9f082e">BoolAnd</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a515faed08882212df5018a3eacd002b6">BoolOr</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a185b7133db22230701a857c059360cc2">Assign</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325af4f67bf86b50df1605ff772c9da52c09">Elvis</a>
<br />
 }</td></tr>
<tr class="separator:a595a79d00daf9c4d4b1f603600471325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420a3f6ea0cec87492bd0dd5781dfd4d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4d">DefaultUnaryOperators</a> { <br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4dab50339a10e1de285ac99d4c3990b8693">NONE</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4da3289297424e01eda5b788c083bbf3147">Positive</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4daffb9356ff2b7da85c75c92fa7ea03b8b">Negative</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4dacc419d34f700a71755be69512c782e1a">BoolNot</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4da63fdae580c8a3012c60caacddcde30c3">BitNot</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4da99694081dbdd24f640c3623e8a582819">Indirection</a>
<br />
 }</td></tr>
<tr class="separator:a420a3f6ea0cec87492bd0dd5781dfd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d828d7f6e0c02a7815c7e1308d3b06e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06e">Exceptions</a> { <br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eaece592fd242f4ba674cc9da539a625a7">SyntaxError</a> =1, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea3f91d67ae8180182f841199841119f14">ExpressionInfo</a> = -1, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eae82887439cd9cec62f06f7b57d5c67b8">StdExceptionInfo</a> =-2, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea8142ee26383df96998b89a64f5ada68a">EmptyExpressionString</a> =2, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eac638233e39a874e1a18cc4a0037fd393">SyntaxErrorExpectation</a> =5, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea5f6573d53543805b782d7713d487aacc">UnknownUnaryOperatorSymbol</a> =6, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea58886e9443f9c78661f01333524dfde9">UnknownBinaryOperatorSymbol</a> =7, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea31692dda5d891bbe17e885bed37c556a">UnknownIdentifier</a> =14, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea4d9910d717abf2123c1934d2e4ffa909">UnknownFunction</a> =15, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea34719a73ce8b9602d15c79266291a507">FunctionHint</a> =-15, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea4af1247eb58452a321535fa7f9370e78">UnaryOperatorNotDefined</a> =16, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eade8b780090c978363f160802856eced3">BinaryOperatorNotDefined</a> =17, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea57654071c3e481cb5feaf7df3ed76e28">MissingFunctionParentheses</a> =22, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eaa0aa3add0d452711cd2015bbafa46be1">IdentifierWithFunctionParentheses</a> =23, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea61b8860ff717baeab446775ec5827ed7">IncompatibleTypesInConditional</a> =25, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea62b023dd547d643d9814a476902bf7e2">ExceptionInPlugin</a> =30, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea8a2a0e7d8ec919b71accc1e0ecaf141c">ExceptionInCallback</a> =40, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea8dddd0579e302dd1c9b158311731e685">NamedExpressionNotConstant</a> =50, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea53efd3f012749fb7f13b32e9b20fd5d4">NamedExpressionNotFound</a> =51, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eaa55122803c63358f00c7454e9089e037">NestedExpressionNotFoundCT</a> =52, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea2e209a8a0fd2422172d298cfc60ed031">NestedExpressionCallArgumentMismatch</a> =53, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea67e6fcc3226ca9842a5d0a26768d269d">NestedExpressionNotFoundET</a> =54, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eac569ba0c348a248965b24fd819c4d3a1">WhenEvaluatingNestedExpression</a> =-54, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea0fb7f9c64ef7935034cf684030ff1b88">NestedExpressionResultTypeError</a> = 55, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea4483b3169767a7b512ef3f1a5573df4e">CircularNestedExpressions</a> = 56, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ead1072e0080997fa27c2e9ab366c329ce">CircularNestedExpressionsInfo</a> =-56
<br />
 }</td></tr>
<tr class="separator:a8d828d7f6e0c02a7815c7e1308d3b06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff21ac37397b09f1e9ab0b4bfcd99a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3">Normalization</a> : uint64_t { <br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a7c2bd4bd8f395c98c342e0e7912cb9a5">ReplaceFunctionNames</a> = (1LLU &lt;&lt; 1), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a7cb98ff4ba877f4c1b9318b25fde4bf8">ReplaceAliasOperators</a> = (1LLU &lt;&lt; 2), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3aa5ccfa052b1378e251f2ae5b8d919efa">ReplaceVerbalOperatorsToSymbolic</a> = (1LLU &lt;&lt; 3), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a22ae3749c0bfa6c4a341b4965c7ede12">ReplaceVerbalOperatorsToLowerCase</a> = (1LLU &lt;&lt; 4), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3af4dca7c0f8ee87f937c2c4523fd26511">ReplaceVerbalOperatorsToUpperCase</a> = (1LLU &lt;&lt; 5), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a637ae6d06c55c979bce1d70b40da4040">ReplaceVerbalOperatorsToDefinedLetterCase</a> = (1LLU &lt;&lt; 6), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a1e574989a63529ad9229929a7f632100">QuoteUnaryNestedExpressionOperatorArgument</a> = (1LLU &lt;&lt; 7), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3ac247e722a191c11f9568b943f0e8cb94">RemoveRedundantUnaryOpsOnNumberLiterals</a> = (1LLU &lt;&lt; 8), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3ad0580638e9258d4d858e3e237c9e9069">UnaryOpSpace</a> = (1LLU &lt;&lt; 9), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a3e59d379c381ad03d4fc739b6b5b0c32">UnaryOpSpaceIfUnaryFollows</a> = (1LLU &lt;&lt; 10), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a5c591ec070fda85a4a2a0c7489eafc9b">UnaryOpSpaceIfBracketFollows</a> = (1LLU &lt;&lt; 11), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a68178e86cf39a25358eee75c8941236d">UnaryOpInnerBracketSpace</a> = (1LLU &lt;&lt; 12), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a86e31ec846bf356d412152e0f9afd2ab">RedundantBracketsBetweenTwoUnaryOps</a> = (1LLU &lt;&lt; 13), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a1d088548ef41c7b452eed703035ac985">RedundantUnaryOpBrackets</a> = (1LLU &lt;&lt; 14), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3ab5c29672825f495960425d04dbfc0e94">BinaryOpSpaces</a> = (1LLU &lt;&lt; 15), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a365d2b261b98b22ec7b2492c9101f5d6">InnerBracketSpace</a> = (1LLU &lt;&lt; 16), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a0bf0ea303f8c40126d49f031fa983fd6">OuterBracketSpace</a> = (1LLU &lt;&lt; 17), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a41a9f83aa5d81e30f73c61280d359baa">RedundantRhsBracketsIfRhsIsStrongerBinaryOp</a> = (1LLU &lt;&lt; 18), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a900dd5a32b467b48b9cd078cfa1abc15">RedundantBracketsIfLhsAndRhsAreBinaryOps</a> = (1LLU &lt;&lt; 19), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3abc8d0388dd434d7956837750d90976ac">RedundantBinaryOpBrackets</a> = (1LLU &lt;&lt; 20), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a0b6c2a3e5a90fb3e2844c213b0c18d27">ConditionalOpSpaceBeforeQM</a> = (1LLU &lt;&lt; 21), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a4c23475609830a26f04cd0d0fd5292dd">ConditionalOpSpaceAfterQM</a> = (1LLU &lt;&lt; 22), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a7336da88ad37f88a276e67b6c47fadb3">ConditionalOpSpaceBeforeColon</a> = (1LLU &lt;&lt; 23), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3af87c7438061be9c4b24c32c5ff6c13c3">ConditionalOpSpaceAfterColon</a> = (1LLU &lt;&lt; 24), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3aa5bfd03ff11d36d9a1bd30165dd8565c">RedundantConditionalOpBrackets</a> = (1LLU &lt;&lt; 25), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a2632b0eaaa27ad2a4ce812411e64735a">FunctionSpaceBeforeOpeningBracket</a> = (1LLU &lt;&lt; 26), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a0b2d43edaee942b34cb90e4d300bdbd1">FunctionInnerBracketSpace</a> = (1LLU &lt;&lt; 27), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a954080604d5566ea47cb9da1eb7b3cd0">FunctionInnerBracketSpaceIfNoArguments</a> = (1LLU &lt;&lt; 28), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a364841c45737d7469b3384128a34b5f3">FunctionSpaceBeforeComma</a> = (1LLU &lt;&lt; 29), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a63a752276f9eafefc8bc38e7769e4e51">FunctionSpaceAfterComma</a> = (1LLU &lt;&lt; 30), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a86027ee6908e1d8082e54b359a3f0259">SubscriptSpaceBeforeBrackets</a> = (1LLU &lt;&lt; 31), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a93d07b66e4093ff8c96edaae1a1ce100">SubscriptInnerBracketSpace</a> = (1LLU &lt;&lt; 32), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a26e6c9e720259c80e64083c45921940d">KeepScientificFormat</a> = (1LLU &lt;&lt; 33 ), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a819669ffbb57d51fb0da33d60659520a">ForceHexadecimal</a> = (1LLU &lt;&lt; 34 ), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a6f8a914e5eb5e462278ce1068b1c5318">ForceOctal</a> = (1LLU &lt;&lt; 35 ), 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3ac726a5db3f167dd200d776985a67fb7a">ForceBinary</a> = (1LLU &lt;&lt; 36 ), 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3ab50339a10e1de285ac99d4c3990b8693">NONE</a> = 0L, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3abbd53c25a2b976c1757ce1f9dbe8bd1f">COMPACT</a> = 0L, 
<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a>
<br />
 }</td></tr>
<tr class="separator:a5ff21ac37397b09f1e9ab0b4bfcd99a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac54b4e06c01bedff2d6fb8edc9954d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#ac54b4e06c01bedff2d6fb8edc9954d22">LoadResourcedFunctionDescriptors</a> (<a class="el" href="namespaceaworx.html#ad80f5a35cfcaa40fcf9bb8a33c5e10ff">Library</a> &amp;library, const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;resourceName, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1FunctionNameDescriptor.html">FunctionNameDescriptor</a> *target)</td></tr>
<tr class="separator:ac54b4e06c01bedff2d6fb8edc9954d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67583454451f88f1daf85f1dba292e4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a67583454451f88f1daf85f1dba292e4e">MatchFunctionName</a> (const <a class="el" href="structaworx_1_1lib_1_1expressions_1_1FunctionNameDescriptor.html">FunctionNameDescriptor</a> &amp;haystack, const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;needle)</td></tr>
<tr class="separator:a67583454451f88f1daf85f1dba292e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2a7531e7fd496a49e09cb73b15883e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7531e7fd496a49e09cb73b15883e5d">&#9670;&nbsp;</a></span>ArgIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> =  std::vector&lt;<a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type definition for passing boxed constant expression values.</p>
<dl class="section see"><dt>See also</dt><dd>For more information, see <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">3.2 Type definitions With Sample Boxes</a>. </dd></dl>

</div>
</div>
<a id="a84930fc6785d99ed8a3240026868e3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84930fc6785d99ed8a3240026868e3a1">&#9670;&nbsp;</a></span>CallbackDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a> =  <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> (*)( <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a>&amp; scope, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsBegin, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a2a7531e7fd496a49e09cb73b15883e5d">ArgIterator</a> argsEnd )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer implementing native callback functions, for expression functions and operators. The implementations are are defined and selected by the compiler plugins. They are called (executed) when an expression is evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scope</td><td>The expression's evaluation scope. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">argsBegin</td><td>An iterator that returns <b>Box</b> objects. The first entry takes also the result. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">argsEnd</td><td>The end-iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0acf6b6bfac7fa43e11ddb36084e9270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acf6b6bfac7fa43e11ddb36084e9270">&#9670;&nbsp;</a></span>SPExpression</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a0acf6b6bfac7fa43e11ddb36084e9270">SPExpression</a> =  std::shared_ptr&lt;<a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html">Expression</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As expressions are usually named and cached to enable nested expressions, but also shared as root expressions, and often encapsulated in more or less volatile custom objects, this shared pointer type is used to pass expression trees around. This manages their lifecycle automatically. </p>

</div>
</div>
<a id="a6440e699eaabf1d1353221727a656a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6440e699eaabf1d1353221727a656a91">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> =  const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::lib::boxing::Box</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type definition for passing boxes as sample types.</p>
<dl class="section see"><dt>See also</dt><dd>For more information, see <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">3.2 Type definitions With Sample Boxes</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a54935d405a62c0faf5bea2a1bde5f5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54935d405a62c0faf5bea2a1bde5f5e6">&#9670;&nbsp;</a></span>Compilation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6">Compilation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">Bitwise</a> enum class defining options of expression compilation. Flags defined with this type are set in field <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ab80df79edf00c08ed5f7b74b48f5f0f6">Compiler::CfgCompilation</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6ae9f3440b954250aa73cdd7b581883aa6"></a>DefaultUnaryOperators&#160;</td><td class="fielddoc"><p>If this flag is set, all unary operators given in <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4d">DefaultUnaryOperators</a> are defined with method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a>.</p>
<p>Note that the enumeration class is equipped with <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">resourced enum meta data</a>, which might be changed as an alternative to clearing this flag and provide own definitions.</p>
<p>This flag is set by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a144ad6ed8ecb79321f451c63c28d5682"></a>DefaultBinaryOperators&#160;</td><td class="fielddoc"><p>If this flag is set, all binary operators given in <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325">DefaultBinaryOperators</a> are defined with method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a>.</p>
<p>Note that the enumeration class is equipped with <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">resourced enum meta data</a>, which might be changed as an alternative to clearing this flag and provide own definitions.</p>
<p>This flag is set by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a145a0ec7809a34f20bc66962fac93e1f"></a>DefaultAlphabeticOperatorAliases&#160;</td><td class="fielddoc"><p>If this flag is set, all alphabetic operator aliases given in enumerations <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a97f95def0989e9693f2b804f05918c81">DefaultAlphabeticUnaryOperatorAliases</a> and <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1">DefaultAlphabeticBinaryOperatorAliases</a> are defined with method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a>.</p>
<p>Note that both enumeration classes are equipped with <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">resourced enum meta data</a>, which might be changed as an alternative to clearing this flag and provide own definitions.</p>
<p>This flag is set by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6aad457d1ed07ef3f48c5210b3ec9918f5"></a>AlphabeticOperatorsIgnoreCase&#160;</td><td class="fielddoc"><p>If this flag is set, alphabetic operator aliases defined in <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a44067170fd133e94d984d2be82b616dc">Compiler::AlphabeticUnaryOperatorAliases</a> and <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ac88cf71b2015040cd421aec7f3ec565c">Compiler::AlphabeticBinaryOperatorAliases</a> are parsed ignoring letter case.</p>
<dl class="section note"><dt>Note</dt><dd>Even when this flag is cleared, no two verbal operator aliases that are equal when case is ignored must be defined (e.g "or" and "OR" ).</dd></dl>
<p>This flag is set by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6acbaabe778a87cc0fd64af374e094f5e5"></a>AllowSubscriptOperator&#160;</td><td class="fielddoc"><p>If not set, array subscript operator <code>[]</code> is not supported and its use will cause parse errors errors.</p>
<p>Note that compiler plug-ins get the array subscript operator presented for compilation as a usual binary operator given as <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325a928558e2f9712e38d447d674f2672200">DefaultBinaryOperators::Subscript</a>. This makes its support with custom types quite simple.</p>
<dl class="section attention"><dt>Attention</dt><dd>This flag has to be changed to a custom state prior to performing the first compilation of an expression with a dedicated <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a>. The rationale behind this is, that the compiler creates the parser system at its first use, which in turn does not check the flag after creation.</dd></dl>
<p>This flag is set by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6abe80c37b4a47cbebdb18e6e070cc7804"></a>AliasEqualsOperatorWithAssignOperator&#160;</td><td class="fielddoc"><p>Used with constructor of compiler plug-ins <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html">plugins::Arithmetics</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html">plugins::Strings</a>. (If they are activated in <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#af625946a92a359feef1093b444a5e343">Compiler::CfgBuiltInPlugins</a> or "manually" added.)</p>
<p>Denotes if the assignment operator <code>=</code> is an alias for equal operator <code>==</code>. If set to <code>false</code>, the use of the <code>=</code> operator with several any argument type, throws a compilation exception, unless it is compiled by a custom plug-in.</p>
<dl class="section attention"><dt>Attention</dt><dd>In addition to aliasing the <code>==</code> with <code>=</code>, the latter also receives a higher precedence of parsing! If this flag is not set, the precedence of <em>assign</em> <code>=</code>,follows the the C++ standards and thus is below the group of <code>&amp;</code>, <code>^</code>, <code>|</code>, <code>&amp;&amp;</code>, <code>||</code> and <code>? :</code>. If the alias setting is activated, then the precedence is raised to be on the same level as boolean equal <code>==</code> and thus higher than the aforementioned operators! </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a88c96a668631a41aeda561bb21a0a8f3"></a>AllowBitwiseBooleanOperations&#160;</td><td class="fielddoc"><p>Used with constructor of compiler plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html">plugins::Arithmetics</a>. (If it is activated in <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#af625946a92a359feef1093b444a5e343">Compiler::CfgBuiltInPlugins</a> or "manually" added.)</p>
<p>Denotes if the unary bitwise operator <code>~</code> and binary bitwise operators <code>&amp;</code>, <code>|</code> and <code>^</code> should be allowed for boolean values. If set to <code>false</code>, the use of the bitwise operators with boolean arguments, throws a compilation exception, unless the bitwise operators are compiled by a custom plug-in. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6af99be5385d3007b8067845d16b783d95"></a>AllowOmittingParenthesesOfParameterlessFunctions&#160;</td><td class="fielddoc"><p>If <code>false</code>, compile-time exception <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea57654071c3e481cb5feaf7df3ed76e28">Exception::MissingFunctionParentheses</a> is thrown if a parameterless function is stated without (otherwise redundant) parentheses <code>'()'</code>.</p>
<p>If <code>true</code>, this is tolerated.</p>
<dl class="section note"><dt>Note</dt><dd>This flag is not tested, and the exception is not thrown, by the compiler itself, but by class <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a>.<br />
 Even if this flag is <code>false</code>, still functions without parentheses may be allowed by setting <code>nullptr</code> to field <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus_1_1FunctionEntry.html#af4500e7b48d17a55a1a0032a0983d4f1">Calculus::FunctionEntry::ArgTypes</a> when registering a function. In this case the function is considered rather being an "identifier" than a function. (Still it is the very same as a function, it is just a matter of wording here.)<br />
</dd></dl>
<p>The other way round, if a function is registered as an identifier, flag <b>AllowEmptyParenthesesForIdentifierFunctions</b>, controls if exception <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eaa0aa3add0d452711cd2015bbafa46be1">Exception::IdentifierWithFunctionParentheses</a> is to be thrown if empty parentheses are given on functions that are registered as identifier-style functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a4bc38069ae187399f7ee2aae7675c502"></a>AllowEmptyParenthesesForIdentifierFunctions&#160;</td><td class="fielddoc"><p>If <code>false</code>, compile-time exception <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06eaa0aa3add0d452711cd2015bbafa46be1">Exception::IdentifierWithFunctionParentheses</a> is thrown if a parameterless function, declared as 'identifier style' is used with parentheses <code>'()'</code>.</p>
<p>If <code>true</code>, this is tolerated.</p>
<dl class="section see"><dt>See also</dt><dd>For more information, see the note in documentation of flag <b>AllowOmittingParenthesesOfParameterlessFunctions</b>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a22d7c4c104e9ab16765d1befc54633cf"></a>AllowCompileTimeNestedExpressions&#160;</td><td class="fielddoc"><p>If this flag is set (the default), the <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a5f9dfba67b016bea9547a4f18dd72eb6">unary nested expression operator</a> is activated, as well as the single-parameter overload of the <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a3ef5c1cb148a564ad0746a78c397ed47">nested expression function</a>. If the field is cleared, then only evaluation-time nested expressions are allowed, which is the two- and three-parameter version of the expression function. Other uses are then causing compilation exception <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea4af1247eb58452a321535fa7f9370e78">Exceptions::UnaryOperatorNotDefined</a>, respectively <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea2e209a8a0fd2422172d298cfc60ed031">Exceptions::NestedExpressionCallArgumentMismatch</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a9887dccddfdbf3fe697c4ff1b66994fb"></a>AllowIdentifiersForNestedExpressions&#160;</td><td class="fielddoc"><p>If this flag is set (the default), then identifiers that follow the unary nested expression operator (defaults to <code>'*'</code>), are internally converted to corresponding string literals - just as if they were given as a quoted string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3">Normalization</a> flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a1e574989a63529ad9229929a7f632100">QuoteUnaryNestedExpressionOperatorArgument</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a84c8262d7f9e1ddf967be19e8fc94445"></a>CaseSensitiveNamedExpressions&#160;</td><td class="fielddoc"><p>If not set (the default), then names of named expressions are not distinguished by letter case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a138ad7df5ea6b2421f8e49afa0eda153"></a>PluginExceptionFallThrough&#160;</td><td class="fielddoc"><p>Controls whether exceptions of type <code>std::exception</code> thrown in plug-ins during compilation are caught by the compiler and transformed to <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea62b023dd547d643d9814a476902bf7e2">Exceptions::ExceptionInPlugin</a></p>
<p>Note that exceptions thrown in callback functions which are evaluated at compile-time against constant parameters, are considered plug-in exceptions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6aa4b0631c4c1945fdaf86a32a0e357615"></a>CallbackExceptionFallThrough&#160;</td><td class="fielddoc"><p>This is an "evaluation-time compiler flag". If not set (the default) exceptions of type <a class="el" href="classaworx_1_1lib_1_1lang_1_1Exception.html">Exception</a> and <code>std::exception</code> thrown in callback functions during expression evaluation are caught and transformed to <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06ea8a2a0e7d8ec919b71accc1e0ecaf141c">Exceptions::ExceptionInCallback</a> letter case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6aa650796c535d9b89b91b1d42f62356eb"></a>NoOptimization&#160;</td><td class="fielddoc"><p>If this flag is set, no optimizations are performed when assembling the program.</p>
<dl class="section note"><dt>Note</dt><dd>There is absolutely no reason for setting this flag, other than for running the unit tests. Or for playing with the little virtual machine implemented with this library and having fun understanding the non-optimized program listings generated. The assembly language is easy, it has only four virtual assembly commands - plus a fifth for invoking programs of nested expressions. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6ad7e9527bddfdd1624933e7dfe3f2a145"></a>UseSpiritParser&#160;</td><td class="fielddoc"><p>If set, instead of the built-in hand-crafted parser, an alternative parser implementation based on <a href="http://www.boost.org/doc/libs/1_66_0/libs/spirit/doc/html/index.html">boost::spirit</a> is used.</p>
<p>This flag is available only with compilations that specify preprocessor macro <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gacdb87a2f058167fdff2abd09c94f583d">ALIB_FEAT_EXPRESSIONS_SPIRIT_PARSER</a>. In this case the flag is on by default.</p>
<dl class="section note"><dt>Note</dt><dd>The flag is tested only once with the first compilation of an expression by an expression compiler instance. Subsequent compilations with the same compiler object will re-use the parser created once. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a54935d405a62c0faf5bea2a1bde5f5e6a5b39c8b553c821e7cddc6da64b5bd2ee"></a>DEFAULT&#160;</td><td class="fielddoc"><p>Default value. Evaluates to:<br />
 <code> DefaultUnaryOperators + </code><br />
 <code> DefaultBinaryOperators + </code><br />
 <code> DefaultAlphabeticOperatorAliases + </code><br />
 <code> AlphabeticOperatorsIgnoreCase + </code><br />
 <code> AliasEqualsOperatorWithAssignOperator + </code><br />
 <code> AllowBitwiseBooleanOperations + </code><br />
 <code> AllowSubscriptOperator + </code><br />
 <code> AllowOmittingParenthesesOfParameterlessFunctions + </code><br />
 <code> AllowEmptyParenthesesForIdentifierFunctions + </code><br />
 <code> AllowCompileTimeNestedExpressions + </code><br />
 <code> AllowIdentifiersForNestedExpressions + </code><br />
 </p>
</td></tr>
</table>

</div>
</div>
<a id="add6d77f919179e44f6147a0ef9352e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6d77f919179e44f6147a0ef9352e59">&#9670;&nbsp;</a></span>CompilePriorities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59">CompilePriorities</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">Arithmetical enumeration</a> of slots used to prioritize <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a> instances attached to instances of class <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> at runtime. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add6d77f919179e44f6147a0ef9352e59ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>Used to denote that no variable or plug-in was found. </p>
</td></tr>
<tr><td class="fieldname"><a id="add6d77f919179e44f6147a0ef9352e59afd2a10e79262f97f1a1bc6cd9674080d"></a>ElvisOperator&#160;</td><td class="fielddoc"><p>Built-in operator <code>?:</code> (like conditional, but no 'true'-expression). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1ElvisOperator.html">plugins::ElvisOperator</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="add6d77f919179e44f6147a0ef9352e59a1a7f2767d842b1a20a65ae37dfc78031"></a>AutoCast&#160;</td><td class="fielddoc"><p>Auto-cast plug-in. </p>
</td></tr>
<tr><td class="fieldname"><a id="add6d77f919179e44f6147a0ef9352e59a89be9433646f5939040a78971a5d103a"></a>Strings&#160;</td><td class="fielddoc"><p>Built-in String comparison and manipulation. </p>
</td></tr>
<tr><td class="fieldname"><a id="add6d77f919179e44f6147a0ef9352e59a719f9a005b2305b85fd3af7c81e8df83"></a>Arithmetics&#160;</td><td class="fielddoc"><p>Collection of built-in unary and binary operators for boolean, integer and floating point values. </p>
</td></tr>
<tr><td class="fieldname"><a id="add6d77f919179e44f6147a0ef9352e59aa49950aa047c2292e989e368a97a3aae"></a>Math&#160;</td><td class="fielddoc"><p>Collection of built-in unary and binary operators for boolean, integer and floating point values. </p>
</td></tr>
<tr><td class="fieldname"><a id="add6d77f919179e44f6147a0ef9352e59a56ca15e0327fcb7a7f71e883d5c3c62a"></a>DateAndTime&#160;</td><td class="fielddoc"><p>Collection of date and time functions based on <a class="el" href="namespaceaworx_1_1lib_1_1time.html">aworx::lib::time</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="add6d77f919179e44f6147a0ef9352e59a90589c47f06eb971d548591f23c285af"></a>Custom&#160;</td><td class="fielddoc"><p>This is where custom plug-ins usually should be placed. It gives them a higher priority than all built-in plug-ins have.<br />
 If more than one plug-in should be installed, add 1, 2, ... to the enum element. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4e0ed589fdc639cb09d1513b11814fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0ed589fdc639cb09d1513b11814fd1">&#9670;&nbsp;</a></span>DefaultAlphabeticBinaryOperatorAliases</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a4e0ed589fdc639cb09d1513b11814fd1">DefaultAlphabeticBinaryOperatorAliases</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This enumeration lists the built-in verbal alias names for binary operators.</p>
<p>The associated <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">enum meta data</a> provides the operator verbs as well as the replacement operator.</p>
<p>Flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a145a0ec7809a34f20bc66962fac93e1f">Compilation::DefaultAlphabeticOperatorAliases</a> controls if method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a> adds the aliases to the compiler. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1ac33315685a0cba3ce53be378b3c7874b"></a>And&#160;</td><td class="fielddoc"><p>Verbal alias <code>"And"</code> to boolean and operator <code>'&amp;&amp;'</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a3a2d5fe857d8f9541136a124c2edec6c"></a>Or&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Or"</code> to boolean or operator <code>'||'</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a20c4c6104a283ee7383776e722439342"></a>Sm&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Sm"</code> to operator <code>'&lt;'</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1aafc493b6574d5529ed0ffa6f18f05b20"></a>Smaller&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Smaller"</code> to operator <code>'&lt;'</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a50a6512f6f88d29531af72e44b7d4425"></a>SmEq&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Smeq"</code> to operator <code>'&lt;='</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a0b34de228330eaf78458a0949acb3aa6"></a>SmallerOrEqual&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Smaller_or_equal"</code> to operator <code>'&lt;='</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a086cb8308e5a36e7c4ed1f8873ad801f"></a>Gt&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Gt"</code> to operator <code>'&gt;'</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a8768a6821cd735aea4f5b0df88c1fc6a"></a>Greater&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Greater"</code> to operator <code>'&gt;'</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1ab73291c688b4e09541e686213c2332da"></a>GtEq&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Gteq"</code> to operator <code>'&gt;='</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a6f2f0aefb3d22da0f3839453add5f937"></a>GreaterOrEqual&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Greater_or_equal"</code> to operator <code>'&gt;='</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a3718b5ecf60aa0dba49e150e96cb1fc3"></a>Eq&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Eq"</code> to operator <code>'=='</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a0ccb67e7eaae09d9e4078d161eeca100"></a>Equals&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Equals"</code> to operator <code>'=='</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1af27cd6656e2a46007ddac7452d9b04c9"></a>NEq&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Neq"</code> to operator <code>'!='</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e0ed589fdc639cb09d1513b11814fd1a19bb0af2c3c530538cb41aff7f235b96"></a>NotEqual&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Not_equals"</code> to operator <code>'!='</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a97f95def0989e9693f2b804f05918c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f95def0989e9693f2b804f05918c81">&#9670;&nbsp;</a></span>DefaultAlphabeticUnaryOperatorAliases</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a97f95def0989e9693f2b804f05918c81">DefaultAlphabeticUnaryOperatorAliases</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This enumeration lists the built-in verbal alias names for unary operators.</p>
<p>The associated <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">enum meta data</a> provides the operator verbs as well as the replacement operator.</p>
<p>Flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a145a0ec7809a34f20bc66962fac93e1f">Compilation::DefaultAlphabeticOperatorAliases</a> controls if method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#acd53b2f255a2b75ffabca5227c926a97">Compiler::SetupDefaults</a> adds the aliases to the compiler. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a97f95def0989e9693f2b804f05918c81aa74c05d080620f087c4e523977230666"></a>Not&#160;</td><td class="fielddoc"><p>Verbal alias <code>"Not"</code> to operator <code>'!'</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a595a79d00daf9c4d4b1f603600471325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595a79d00daf9c4d4b1f603600471325">&#9670;&nbsp;</a></span>DefaultBinaryOperators</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a595a79d00daf9c4d4b1f603600471325">DefaultBinaryOperators</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This enumeration lists the built-in binary operators. The associated <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">enum meta data</a> provides the operator symbols, as well as the precedence value of the operator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>Not an operator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a928558e2f9712e38d447d674f2672200"></a>Subscript&#160;</td><td class="fielddoc"><p>Array subscripting (<code>'[]'</code>). Precedence hardcoded with parser. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325ae257376d913f3b53cbb4a9b19d770648"></a>Multiply&#160;</td><td class="fielddoc"><p>Arithmetic multiplication (<code>'*'</code>). Precedence <code>900</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a0b914e196182d02615487e9793ecff3d"></a>Divide&#160;</td><td class="fielddoc"><p>Arithmetic division (<code>'/'</code>). Precedence <code>900</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a4cde2424cf960a70b7fc5fda1119143d"></a>Modulo&#160;</td><td class="fielddoc"><p>Arithmetic modulo (<code>'%'</code>). Precedence <code>900</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"><p>Arithmetic addition (<code>'+'</code>). Precedence <code>800</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a1d9baf077ee87921f57a8fe42d510b65"></a>Subtract&#160;</td><td class="fielddoc"><p>Arithmetic subtraction (<code>'-'</code>). Precedence <code>800</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325ad9382145a142cc7df5f733332c9cb812"></a>ShiftLeft&#160;</td><td class="fielddoc"><p>Bitwise shifting of integer values (<code>'&lt;&lt;'</code>). Precedence <code>700</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325af17de5e0ea7a357b755aa9deeaf38f86"></a>ShiftRight&#160;</td><td class="fielddoc"><p>Bitwise shifting of integer values (<code>'&gt;&gt;'</code>). Precedence <code>700</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325aafc493b6574d5529ed0ffa6f18f05b20"></a>Smaller&#160;</td><td class="fielddoc"><p>Smaller operator (<code>'&lt;'</code>). Precedence <code>600</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a0b34de228330eaf78458a0949acb3aa6"></a>SmallerOrEqual&#160;</td><td class="fielddoc"><p>Smaller or equal operator (<code>'&lt;='</code>). Precedence <code>600</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a8768a6821cd735aea4f5b0df88c1fc6a"></a>Greater&#160;</td><td class="fielddoc"><p>Greater operator (<code>'&gt;'</code>). Precedence <code>600</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a6f2f0aefb3d22da0f3839453add5f937"></a>GreaterOrEqual&#160;</td><td class="fielddoc"><p>Greater or equal operator (<code>'&gt;='</code>). Precedence <code>600</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325af5f286e73bda105e538310b3190f75c5"></a>Equal&#160;</td><td class="fielddoc"><p>Equal operator (<code>'=='</code>). Precedence <code>500</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a19bb0af2c3c530538cb41aff7f235b96"></a>NotEqual&#160;</td><td class="fielddoc"><p>Not equal operator (<code>'!='</code>). Precedence <code>500</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325ae5c7b3dc6fa17e0c1d0586d1a169c77d"></a>BitAnd&#160;</td><td class="fielddoc"><p>Binary and (<code>'&amp;'</code>). "and"s all bits of two integer values. Precedence <code>470</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a710384afa7bbbef1ec4956730c792af8"></a>BitXOr&#160;</td><td class="fielddoc"><p>Binary xor (<code>'^'</code>). "xor"s all bits of two integer values. Precedence <code>460</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a04306ca0b4b3ed9a5cedc16d4acbc2b8"></a>BitOr&#160;</td><td class="fielddoc"><p>Binary or (<code>'|'</code>). "or"s all bits of two integer values. Precedence <code>450</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a261878dd037f1da40e3e4e0c4d9f082e"></a>BoolAnd&#160;</td><td class="fielddoc"><p>Boolean and (<code>'&amp;&amp;'</code>). Result is boolean. Precedence <code>440</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a515faed08882212df5018a3eacd002b6"></a>BoolOr&#160;</td><td class="fielddoc"><p>Boolean or (<code>'||'</code>). Result is boolean. Precedence <code>430</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325a185b7133db22230701a857c059360cc2"></a>Assign&#160;</td><td class="fielddoc"><p>Assignment. By default, this is used as alias operator for operator <b>Equal</b> by the built-in compiler plug-ins. See <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6abe80c37b4a47cbebdb18e6e070cc7804">AliasEqualsOperatorWithAssignOperator</a> for more information.<br />
 Precedence <code>300</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a595a79d00daf9c4d4b1f603600471325af4f67bf86b50df1605ff772c9da52c09"></a>Elvis&#160;</td><td class="fielddoc"><p>Binary version of ternary operator <code>Q ? T : F</code> with second operand (<code>T</code>) not given. Whitespaces are allowed between '?' and ':'.<br />
 Precedence <code>200</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a420a3f6ea0cec87492bd0dd5781dfd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420a3f6ea0cec87492bd0dd5781dfd4d">&#9670;&nbsp;</a></span>DefaultUnaryOperators</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4d">DefaultUnaryOperators</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This enumeration lists the built-in unary operators. The associated <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">enum meta data</a> provides the operator symbols. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a420a3f6ea0cec87492bd0dd5781dfd4dab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>Not an operator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a420a3f6ea0cec87492bd0dd5781dfd4da3289297424e01eda5b788c083bbf3147"></a>Positive&#160;</td><td class="fielddoc"><p><code>'+'</code> operator (usually returns identity value). </p>
</td></tr>
<tr><td class="fieldname"><a id="a420a3f6ea0cec87492bd0dd5781dfd4daffb9356ff2b7da85c75c92fa7ea03b8b"></a>Negative&#160;</td><td class="fielddoc"><p><code>'-'</code> operator, negates a value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a420a3f6ea0cec87492bd0dd5781dfd4dacc419d34f700a71755be69512c782e1a"></a>BoolNot&#160;</td><td class="fielddoc"><p>Boolean not (<code>'!'</code>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a420a3f6ea0cec87492bd0dd5781dfd4da63fdae580c8a3012c60caacddcde30c3"></a>BitNot&#160;</td><td class="fielddoc"><p>Bitwise not (<code>'~'</code>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a420a3f6ea0cec87492bd0dd5781dfd4da99694081dbdd24f640c3623e8a582819"></a>Indirection&#160;</td><td class="fielddoc"><p>Unary <code>'*'</code> operator. Similar to the C++ indirection operator, this is the default operator uses with nested expressions, which is defined with <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a5f9dfba67b016bea9547a4f18dd72eb6">Compiler::CfgNestedExpressionOperator</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8d828d7f6e0c02a7815c7e1308d3b06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d828d7f6e0c02a7815c7e1308d3b06e">&#9670;&nbsp;</a></span>Exceptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a8d828d7f6e0c02a7815c7e1308d3b06e">Exceptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Exceptions thrown by module <b>ALib Expressions</b>.</p>
<dl class="section note"><dt>Note</dt><dd>This enum <a class="el" href="group__GrpALibMacros.html#ga1fc9d72399e5c3d3fe003f3e8070aa6d">is equipped with</a> meta information according to class <a class="el" href="classaworx_1_1lib_1_1lang_1_1Exception.html">Exception</a>. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06eaece592fd242f4ba674cc9da539a625a7"></a>SyntaxError&#160;</td><td class="fielddoc"><p>General error thrown by the parser. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea3f91d67ae8180182f841199841119f14"></a>ExpressionInfo&#160;</td><td class="fielddoc"><p>Detail entry (negative element value) used with various exceptions. Shows the expression in a first line and a marker of the syntax error position in a second. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06eae82887439cd9cec62f06f7b57d5c67b8"></a>StdExceptionInfo&#160;</td><td class="fielddoc"><p>This is added to exceptions when when a <code>std::exception</code> is wrapped. The 'what()' string is included as entry parameter. (This is a detail entry with negative element value). </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea8142ee26383df96998b89a64f5ada68a"></a>EmptyExpressionString&#160;</td><td class="fielddoc"><p>Thrown when an empty string is tried to be compiled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06eac638233e39a874e1a18cc4a0037fd393"></a>SyntaxErrorExpectation&#160;</td><td class="fielddoc"><p>Syntax error with concrete information about what the parser expected at given position. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea5f6573d53543805b782d7713d487aacc"></a>UnknownUnaryOperatorSymbol&#160;</td><td class="fielddoc"><p>Unknown unary operator symbol found when parsing expression string. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea58886e9443f9c78661f01333524dfde9"></a>UnknownBinaryOperatorSymbol&#160;</td><td class="fielddoc"><p>Unknown binary operator symbol found when parsing expression string. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea31692dda5d891bbe17e885bed37c556a"></a>UnknownIdentifier&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when an expression uses an unknown identifier name. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea4d9910d717abf2123c1934d2e4ffa909"></a>UnknownFunction&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when an expression uses an unknown function name. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea34719a73ce8b9602d15c79266291a507"></a>FunctionHint&#160;</td><td class="fielddoc"><p>Optional info entry (negative element value) on a function with matching name but non-matching arguments found. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea4af1247eb58452a321535fa7f9370e78"></a>UnaryOperatorNotDefined&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when an unary operator is not applicable to the given argument type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06eade8b780090c978363f160802856eced3"></a>BinaryOperatorNotDefined&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when a binary operator is not applicable to the combination of left-hand and right-and argument type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea57654071c3e481cb5feaf7df3ed76e28"></a>MissingFunctionParentheses&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when function parentheses are missing with parameterless functions, while flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6af99be5385d3007b8067845d16b783d95">AllowOmittingParenthesesOfParameterlessFunctions</a> is not set in <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ab80df79edf00c08ed5f7b74b48f5f0f6">Compiler::CfgCompilation</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06eaa0aa3add0d452711cd2015bbafa46be1"></a>IdentifierWithFunctionParentheses&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when empty function parentheses are given with identifiers (parameterless functions), while flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a4bc38069ae187399f7ee2aae7675c502">AllowEmptyParenthesesForIdentifierFunctions</a> is not set in <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ab80df79edf00c08ed5f7b74b48f5f0f6">Compiler::CfgCompilation</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea61b8860ff717baeab446775ec5827ed7"></a>IncompatibleTypesInConditional&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when incompatible types are given with conditional term <code>Q ? T : F</code>. Note that before throwing this exception, the compiler tries to insert auto-cast callback functions, and if found, performs one second try to compile the operator for the new pair of operatnd types. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea62b023dd547d643d9814a476902bf7e2"></a>ExceptionInPlugin&#160;</td><td class="fielddoc"><p>This is a "wrapper" exception thrown when a plug-in or a compile-time invoked callback function throws an exception of type <code>std::exception</code> or of type <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8d828d7f6e0c02a7815c7e1308d3b06e">Exceptions</a> with a code that is not of this enumeration type.<br />
 Used only if compilation <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a138ad7df5ea6b2421f8e49afa0eda153">Compilation::PluginExceptionFallThrough</a> is not set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea8a2a0e7d8ec919b71accc1e0ecaf141c"></a>ExceptionInCallback&#160;</td><td class="fielddoc"><p>This is a "wrapper" exception thrown when callback functions throws an exception of type <code>std::exception</code> or of type <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8d828d7f6e0c02a7815c7e1308d3b06e">Exceptions</a>. Used only if compilation <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6aa4b0631c4c1945fdaf86a32a0e357615">Compilation::CallbackExceptionFallThrough</a> is not set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea8dddd0579e302dd1c9b158311731e685"></a>NamedExpressionNotConstant&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when unary expression operator is used with a non-constant nested expression name. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea53efd3f012749fb7f13b32e9b20fd5d4"></a>NamedExpressionNotFound&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when an expression refers to an unknown named nested expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06eaa55122803c63358f00c7454e9089e037"></a>NestedExpressionNotFoundCT&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when a named nested expression which is searched an inserted at compile-time could not be found.<br />
 Overwrites exception <b>NamedExpressionNotFound</b>.</p>
<dl class="section see"><dt>See also</dt><dd>Manual chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested">10. Nested Expressions</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea2e209a8a0fd2422172d298cfc60ed031"></a>NestedExpressionCallArgumentMismatch&#160;</td><td class="fielddoc"><p>Compile-time exception thrown when when wrong arguments were passed to function <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a3ef5c1cb148a564ad0746a78c397ed47">Compiler::CfgNestedExpressionFunction</a>.</p>
<dl class="section see"><dt>See also</dt><dd>Manual chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested">10. Nested Expressions</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea67e6fcc3226ca9842a5d0a26768d269d"></a>NestedExpressionNotFoundET&#160;</td><td class="fielddoc"><p>Evaluation-time exception thrown when a named nested expression which is searched only at evaluation-time could not be found.<br />
 Overwrites exception <b>NamedExpressionNotFound</b>. </p><dl class="section see"><dt>See also</dt><dd>Manual chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested">10. Nested Expressions</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06eac569ba0c348a248965b24fd819c4d3a1"></a>WhenEvaluatingNestedExpression&#160;</td><td class="fielddoc"><p>Informational exception entry (negative element value) providing the name of the expression that caused any other exception than <code>NamedExpressionNotFound</code> during evaluation of a nested expression.</p>
<p>Note that entries of this type might be repeated when expressions are recursively nested. The number of entries in the exception corresponds to the depth of nesting. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea0fb7f9c64ef7935034cf684030ff1b88"></a>NestedExpressionResultTypeError&#160;</td><td class="fielddoc"><p>Evaluation-time exception thrown when a named nested expression which was searched and found only at evaluation-time, returned a different result type than specified.<br />
</p>
<dl class="section see"><dt>See also</dt><dd>Manual chapter <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_nested">10. Nested Expressions</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea4483b3169767a7b512ef3f1a5573df4e"></a>CircularNestedExpressions&#160;</td><td class="fielddoc"><p>Evaluation-time exception thrown when a circular relationship of nested expressions is detected, which comprises an infinite loop. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ead1072e0080997fa27c2e9ab366c329ce"></a>CircularNestedExpressionsInfo&#160;</td><td class="fielddoc"><p>A list of informational entries of this type is given with exception <b>CircularNestedExpressions</b>. Each entry provides the name of the expression that was evaluated and the name of the nested expression that it called. Hence, the list of entries of this type comprise the "call stack" that leaded to the circular call that caused the exception. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff21ac37397b09f1e9ab0b4bfcd99a3">&#9670;&nbsp;</a></span>Normalization</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3">Normalization</a> : uint64_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">Bitwise</a> enum class defining options for formatting parsed expressions. The normalized conversion of the expression input string is available with method <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a9e5bd8d42c1eba7541d4cc615c366844">Expression::GetNormalizedString</a>, after an expression was successfully <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a3493831cad915284240d6d6b67251a6a">compiled</a>.</p>
<p>The normalization flags are stored per compiler instance, consequently using a public compiler field namely <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ac2b0822b970754be8993e1a8071aea96">Compiler::CfgNormalization</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a7c2bd4bd8f395c98c342e0e7912cb9a5"></a>ReplaceFunctionNames&#160;</td><td class="fielddoc"><p>Replace given shortened and letter case mismatched identifier and function names with completed versions.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a7cb98ff4ba877f4c1b9318b25fde4bf8"></a>ReplaceAliasOperators&#160;</td><td class="fielddoc"><p>Replace alias operators with effective operators.<br />
 This flag is not set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3aa5ccfa052b1378e251f2ae5b8d919efa"></a>ReplaceVerbalOperatorsToSymbolic&#160;</td><td class="fielddoc"><p>This is one of four flags that together allow five possible normalization options for <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_verbal">verbal alias operators</a>. If more than one flag is set, the one with the highest precedence is used.</p>
<p>The following table lists the flags, their precedence and the type of normalization:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Precedence  </th><th class="markdownTableHeadNone">Flag  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">&lt;none set&gt;  </td><td class="markdownTableBodyNone">A verbal operator is normalized as given in original expression string.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">ReplaceVerbalOperatorsToSymbolic  </td><td class="markdownTableBodyNone">Replaces verbal operators with the symbolic operator that they represent.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">ReplaceVerbalOperatorsToLowerCase  </td><td class="markdownTableBodyNone">Converts verbal operators to lower case letters.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">ReplaceVerbalOperatorsToUpperCase  </td><td class="markdownTableBodyNone">Converts verbal operators to upper case letters.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">ReplaceVerbalOperatorsToDefinedLetterCase  </td><td class="markdownTableBodyNone">Uses the writing specified with the definition of the verbal operator.   </td></tr>
</table>
<p>With configuration <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a>, flag <b>ReplaceVerbalOperatorsToUpperCase</b> is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a22ae3749c0bfa6c4a341b4965c7ede12"></a>ReplaceVerbalOperatorsToLowerCase&#160;</td><td class="fielddoc"><p>See sibling flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3aa5ccfa052b1378e251f2ae5b8d919efa">ReplaceVerbalOperatorsToSymbolic</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3af4dca7c0f8ee87f937c2c4523fd26511"></a>ReplaceVerbalOperatorsToUpperCase&#160;</td><td class="fielddoc"><p>See sibling flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3aa5ccfa052b1378e251f2ae5b8d919efa">ReplaceVerbalOperatorsToSymbolic</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a637ae6d06c55c979bce1d70b40da4040"></a>ReplaceVerbalOperatorsToDefinedLetterCase&#160;</td><td class="fielddoc"><p>See sibling flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3aa5ccfa052b1378e251f2ae5b8d919efa">ReplaceVerbalOperatorsToSymbolic</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a1e574989a63529ad9229929a7f632100"></a>QuoteUnaryNestedExpressionOperatorArgument&#160;</td><td class="fielddoc"><p>Converts nested expression names that have been given unquoted to a quoted string literal. If this is not set, the quotation remains as given in original expression string. This flag is <em>not</em> set with <b>DEFAULT</b>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6">Compilation</a> flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a9887dccddfdbf3fe697c4ff1b66994fb">AllowIdentifiersForNestedExpressions</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3ac247e722a191c11f9568b943f0e8cb94"></a>RemoveRedundantUnaryOpsOnNumberLiterals&#160;</td><td class="fielddoc"><p>Remove redundant provisions unary operators <code>'+'</code> and <code>'-'</code> from number literals.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3ad0580638e9258d4d858e3e237c9e9069"></a>UnaryOpSpace&#160;</td><td class="fielddoc"><p>Write a space after an unary operator (if no brackets around arguments and no unary operator follows).<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a3e59d379c381ad03d4fc739b6b5b0c32"></a>UnaryOpSpaceIfUnaryFollows&#160;</td><td class="fielddoc"><p>Write a space between two unary operators.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a5c591ec070fda85a4a2a0c7489eafc9b"></a>UnaryOpSpaceIfBracketFollows&#160;</td><td class="fielddoc"><p>Write a space before opening bracket of bracketed arguments of unary operators.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a68178e86cf39a25358eee75c8941236d"></a>UnaryOpInnerBracketSpace&#160;</td><td class="fielddoc"><p>Write a space after an opening and before a closing bracket of arguments of unary operators.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a86e31ec846bf356d412152e0f9afd2ab"></a>RedundantBracketsBetweenTwoUnaryOps&#160;</td><td class="fielddoc"><p>If this flag is set, normalization inserts redundant brackets to to the argument of an unary operation, if that argument is an unary operation itself.</p>
<p>This flag is superseded by <b>RedundantUnaryOpBrackets</b>.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a1d088548ef41c7b452eed703035ac985"></a>RedundantUnaryOpBrackets&#160;</td><td class="fielddoc"><p>If this flag is set, normalization inserts redundant brackets to arguments of unary operators.</p>
<p>This flag supersedes by <b>RedundantBracketsBetweenTwoUnaryOps</b>.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3ab5c29672825f495960425d04dbfc0e94"></a>BinaryOpSpaces&#160;</td><td class="fielddoc"><p>Write a space before and after binary operator symbol.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a365d2b261b98b22ec7b2492c9101f5d6"></a>InnerBracketSpace&#160;</td><td class="fielddoc"><p>Write a space after an opening and before a closing bracket of arguments of binary operators and around a conditional expression.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a0bf0ea303f8c40126d49f031fa983fd6"></a>OuterBracketSpace&#160;</td><td class="fielddoc"><p>Write a space before opening and after closing bracket of arguments of binary operators and around a conditional expression.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a41a9f83aa5d81e30f73c61280d359baa"></a>RedundantRhsBracketsIfRhsIsStrongerBinaryOp&#160;</td><td class="fielddoc"><p>If this flag is set, normalization inserts redundant brackets to the right-hand side operand of binary operators if that operand is a binary operator itself and has a higher precedence.</p>
<p>The following samples demonstrate why this is useful if normalization targets humans:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Without flag set  </th><th class="markdownTableHeadNone">With flag set &mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 - 2 - 3  </td><td class="markdownTableBodyNone"><em>no change</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1 - 2 * 3  </td><td class="markdownTableBodyNone">1 - (2 * 3)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 * 2 - 3  </td><td class="markdownTableBodyNone"><em>no change</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1 - 2 * 3 - 4 - 5 * 6 - 7  </td><td class="markdownTableBodyNone">1 - (2 * 3) - 4 - (5 * 6) - 7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">true == false &amp;&amp; true  </td><td class="markdownTableBodyNone"><em>no change</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">true &amp;&amp; false == true  </td><td class="markdownTableBodyNone">true &amp;&amp; (false == true)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">true &amp;&amp; false == false &amp;&amp; true  </td><td class="markdownTableBodyNone">true &amp;&amp; (false == false) &amp;&amp; true   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">true &amp;&amp; false == (false &amp;&amp; true)  </td><td class="markdownTableBodyNone">true &amp;&amp; (false == (false &amp;&amp; true))   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">true &amp;&amp; false == true &lt; false  </td><td class="markdownTableBodyNone">true &amp;&amp; (false == (true &lt; false))   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">true &amp;&amp; false == false == true  </td><td class="markdownTableBodyNone">true &amp;&amp; (false == false == true)   </td></tr>
</table>
<p>This flag is superseded by <b>RedundantBinaryOpBrackets</b>.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a900dd5a32b467b48b9cd078cfa1abc15"></a>RedundantBracketsIfLhsAndRhsAreBinaryOps&#160;</td><td class="fielddoc"><p>If this flag is set, normalization inserts redundant brackets to both operands of binary operators if both are binary operators themselves.</p>
<p>The following samples demonstrate why this is useful if normalization strings target humans:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Without flag set  </th><th class="markdownTableHeadNone">With flag set &mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 - 2 - 3  </td><td class="markdownTableBodyNone"><em>no change</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1 - 2 - 3 - 4  </td><td class="markdownTableBodyNone"><em>no change</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 - 2 - (3 - 4)  </td><td class="markdownTableBodyNone">(1 - 2) - (3 - 4)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1 - 2 - 3 - (4 - 5)  </td><td class="markdownTableBodyNone">(1 - 2 - 3) - (4 - 5)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 - 2 - (3 - 4) - 5  </td><td class="markdownTableBodyNone">(1 - 2) - (3 - 4) - 5   </td></tr>
</table>
<p>This flag is superseded by <b>RedundantBinaryOpBrackets</b>.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3abc8d0388dd434d7956837750d90976ac"></a>RedundantBinaryOpBrackets&#160;</td><td class="fielddoc"><p>If this flag is set, normalization inserts redundant brackets around each binary operator sub-expression. This flag supersedes flags <b>RedundantRhsBracketsIfRhsIsStrongerBinaryOp</b> and <b>RedundantBracketsIfLhsAndRhsAreBinaryOps</b>.</p>
<p>It is not recommended to set this flag. It is only useful to debug expressions and understand exactly what precedences operators have.</p>
<p>This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a0b6c2a3e5a90fb3e2844c213b0c18d27"></a>ConditionalOpSpaceBeforeQM&#160;</td><td class="fielddoc"><p>Write a space before character <code>?</code> of ternary conditional operator.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a4c23475609830a26f04cd0d0fd5292dd"></a>ConditionalOpSpaceAfterQM&#160;</td><td class="fielddoc"><p>Write a space after character <code>?</code> of a ternary conditional operator.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a7336da88ad37f88a276e67b6c47fadb3"></a>ConditionalOpSpaceBeforeColon&#160;</td><td class="fielddoc"><p>Write a space before character <code>:</code> of ternary conditional operator.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3af87c7438061be9c4b24c32c5ff6c13c3"></a>ConditionalOpSpaceAfterColon&#160;</td><td class="fielddoc"><p>Write a space after character <code>:</code> of ternary conditional operator.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3aa5bfd03ff11d36d9a1bd30165dd8565c"></a>RedundantConditionalOpBrackets&#160;</td><td class="fielddoc"><p>If this flag is set, normalization inserts redundant brackets around the conditional operator expressions <code>Q ? T : F</code>, if it is not the root node.</p>
<p>This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a2632b0eaaa27ad2a4ce812411e64735a"></a>FunctionSpaceBeforeOpeningBracket&#160;</td><td class="fielddoc"><p>Write a space before between the function identifier name and the opening bracket of the argument list.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a0b2d43edaee942b34cb90e4d300bdbd1"></a>FunctionInnerBracketSpace&#160;</td><td class="fielddoc"><p>Write a space after the opening and before the closing bracket of argument list of a function.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a954080604d5566ea47cb9da1eb7b3cd0"></a>FunctionInnerBracketSpaceIfNoArguments&#160;</td><td class="fielddoc"><p>Write a space between the opening and the closing bracket of an empty argument list of a function.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a364841c45737d7469b3384128a34b5f3"></a>FunctionSpaceBeforeComma&#160;</td><td class="fielddoc"><p>Write a space before a comma of an argument separator of an function's argument list.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a63a752276f9eafefc8bc38e7769e4e51"></a>FunctionSpaceAfterComma&#160;</td><td class="fielddoc"><p>Write a space after a comma of an argument separator of a function's argument list.<br />
 This flag is set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a86027ee6908e1d8082e54b359a3f0259"></a>SubscriptSpaceBeforeBrackets&#160;</td><td class="fielddoc"><p>Write a space before array subscript operator <code>'[]'</code>.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a93d07b66e4093ff8c96edaae1a1ce100"></a>SubscriptInnerBracketSpace&#160;</td><td class="fielddoc"><p>Write a space after the opening and before the closing bracket of array subscript operator <code>'[]'</code>.<br />
 This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a26e6c9e720259c80e64083c45921940d"></a>KeepScientificFormat&#160;</td><td class="fielddoc"><p>If this flag is set, floating point literals are normalized in scientific format when given in scientific format. If it is not set, then numbers given in scientific format might be written as usual floating point values, dependent on their value. E.g. a given <code>1.0e1</code> would be converted to <code>10.0</code>.</p>
<p>Note that scientific format can be forced for all floating point number output by setting flag <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a4abcf6e13582e3d8c9d0dbf893f831f9">NumberFormat::ForceScientific</a> of member member <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterBase.html#ae24e52b221e908cd2b1e9d689f1ffff4">Formatter::DefaultNumberFormat</a> which in turn is found in member <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#a2a8ce7737f852a400bd8c2a366a4d74b">Compiler::CfgFormatter</a>. Such setting would supersede this flag.</p>
<p>This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a819669ffbb57d51fb0da33d60659520a"></a>ForceHexadecimal&#160;</td><td class="fielddoc"><p>If this flag is set, integral literals will be normalized to hexadecimal format. If this flag is not set, then integrals will be normalized in the number system that they had been provided in.</p>
<p>This flags supersedes flags <b>ForceOctal</b> and <b>ForceBinary</b>.</p>
<p>This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a6f8a914e5eb5e462278ce1068b1c5318"></a>ForceOctal&#160;</td><td class="fielddoc"><p>If this flag is set, integral literals will be normalized to octal format. If this flag is not set, then integrals will be normalized in the number system that they had been provided in.</p>
<p>This flags is superseded by flag <b>ForceHexadecimal</b> and supersedes flag <b>ForceBinary</b>.</p>
<p>This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3ac726a5db3f167dd200d776985a67fb7a"></a>ForceBinary&#160;</td><td class="fielddoc"><p>If this flag is set, integral literals will be normalized to binary format. If this flag is not set, then integrals will be normalized in the number system that they had been provided in.</p>
<p>This flags is superseded by flags <b>ForceHexadecimal</b> and <b>ForceOctal</b>.</p>
<p>This flag is <em>not</em> set with <b>DEFAULT</b>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>All flags are cleared, may be used for testing bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3abbd53c25a2b976c1757ce1f9dbe8bd1f"></a>COMPACT&#160;</td><td class="fielddoc"><p>All flags are cleared, hence no whitespaces and unnecessary brackets are written and identifiers as they have been given (potentially abbreviated and ignoring letter case). </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ff21ac37397b09f1e9ab0b4bfcd99a3a5b39c8b553c821e7cddc6da64b5bd2ee"></a>DEFAULT&#160;</td><td class="fielddoc"><p>Default value. Evaluates to:<br />
 <code>ReplaceFunctionNames + </code><br />
 <code>ReplaceVerbalOperatorsToUpperCase + </code><br />
 <br />
 <code>RemoveRedundantUnaryOpsOnNumberLiterals + </code><br />
 <code>BinaryOpSpaces + </code><br />
 <code>RedundantRhsBracketsIfRhsIsStrongerBinaryOp + </code><br />
 <code>RedundantBracketsIfLhsAndRhsAreBinaryOps + </code><br />
 <br />
 <code>ConditionalOpSpaceBeforeQM + </code><br />
 <code>ConditionalOpSpaceBeforeColon + </code><br />
 <code>ConditionalOpSpaceAfterQM + </code><br />
 <code>ConditionalOpSpaceAfterColon + </code><br />
 <code>RedundantConditionalOpBrackets + </code><br />
 <br />
 <code>FunctionInnerBracketSpace + </code><br />
 <code>FunctionSpaceAfterComma + </code><br />
 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac54b4e06c01bedff2d6fb8edc9954d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54b4e06c01bedff2d6fb8edc9954d22">&#9670;&nbsp;</a></span>LoadResourcedFunctionDescriptors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> void LoadResourcedFunctionDescriptors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#ad80f5a35cfcaa40fcf9bb8a33c5e10ff">Library</a> &amp;&#160;</td>
          <td class="paramname"><em>library</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;&#160;</td>
          <td class="paramname"><em>resourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1FunctionNameDescriptor.html">FunctionNameDescriptor</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Loads function name descriptors from resources. This method is static and receives the library as a parameter. This way, it might be used by custom compiler plug-ins in the same fashion as it is used by the built-in ones.</p>
<p>Parses from the resourced string entries of the form</p><ul>
<li>1. The identifier/function name.</li>
<li>2. A comma <code>'</code>,'.</li>
<li>3. Character <code>'I'</code> or <code>'S'</code> to denotes case sensitivity.</li>
<li>4. An integer denoting the minimum length of the function name (abbreviation).</li>
</ul>
<p>(No comma between the entries).</p>
<dl class="section attention"><dt>Attention</dt><dd>The length of the given table has to fit to number of entries found in the resources.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">library</td><td>The resource library to load the resource from. </td></tr>
    <tr><td class="paramname">resourceName</td><td>The resource string to parse. </td></tr>
    <tr><td class="paramname">target</td><td>The table to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67583454451f88f1daf85f1dba292e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67583454451f88f1daf85f1dba292e4e">&#9670;&nbsp;</a></span>MatchFunctionName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MatchFunctionName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structaworx_1_1lib_1_1expressions_1_1FunctionNameDescriptor.html">FunctionNameDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Utility class used to match optionally abbreviated and case insensitive function names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The correct function name, minimum length and letter case sensitivity. </td></tr>
    <tr><td class="paramname">needle</td><td>The potentially abbreviated name to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <span>needle</span> matches <span>haystack</span>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 12 2018 15:57:47 for ALib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
