<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALib: StringBase&lt; TChar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALib
   &#160;<span id="projectnumber">V. 1805 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html">strings</a></li><li class="navelem"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Inner Classes</a> &#124;
<a href="#pro-attribs">Protected Fields</a> &#124;
<a href="classaworx_1_1lib_1_1strings_1_1StringBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StringBase&lt; TChar &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="string_8hpp_source.html">string.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for StringBase&lt; TChar &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1StringBase__inherit__graph.svg" width="832" height="114"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for StringBase&lt; TChar &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1StringBase__coll__graph.svg" width="148" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><h3>template&lt;typename TChar&gt;<br />
class aworx::lib::strings::StringBase&lt; TChar &gt;</h3>

<hr/>
<p> This class is the base class of all <b>ALib</b> string classes. It represents a character string whose data is allocated outside the scope of objects of this class.</p>
<p>Once constructed, objects of this class are immutable. This means, there is no interface to change their buffer or length during their lifetime, which normally is rather volatile.</p>
<p>The buffer represented might be zero-terminated or not. This is dependent on the data it was constructed from. The buffer must not be changed and might even reside in read-only memory.</p>
<p><b>Templated Construction</b><br />
 What makes this class very flexible, is the constructor variant <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a1fb89f1194ce11503120d97aca0f8ad6">StringBase::StringBase(const TStringLike&amp;)</a>. This template method internally uses <em>template meta programming</em> to detect known types and, and to convert them to constant references of those. They are then passed to template methods <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a> that simply return a pointer to the external types' buffer and length. This way, objects of this class can be implicitly constructed from just anything that 'smells' like a string.<br />
 For more information on how to make String support to implicitly construct from user defined types, see namespace template function <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a>.</p>
<p>This class provides compiler defined copy and move constructors and assignment operators. Once and object is constructed, methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aa84b2d544b50b9e3a50e89952bc61c19">Buffer</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> allow read access to the contents.</p>
<p><b>Null-State</b><br />
<a class="anchor" id="CPP_STRINGS_AS_NULLSTATE"></a>Objects of this class can be <em>nulled</em> which means that it is a difference whether they are representing an empty string or a <code>nullptr</code>. As objects are immutable, this is decided on construction: once a String is nulled, it will remain nulled. In other words, it makes a difference if an String is constructed using</p><ul>
<li><em>String()</em>, which creates a <em>nulled</em> object, method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a> will give <code>true</code>, or</li>
<li><em>String("")</em>, which creates an empty object. Method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a> will give <code>false</code> while method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a> will give <code>true</code> </li>
</ul>
<p><b>Non-checking Method Variants</b><br />
<a class="anchor" id="CPP_STRINGS_AS_NC"></a>Some of the provided methods are templated with boolean parameter <em>TCheck</em> which allow to invoke a faster and shorter version of the same method. For more information see <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_details_nonchecking">alib_strings_details_nonchecking</a> in the namespace documentation.</p>
<dl class="section note"><dt>Note</dt><dd>Almost all methods of this class are declared <em>inline</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The immutable nature of String is lifted by derived types. While class <a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">Substring</a> allows to change the start and length of the string represented, class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">AString</a> holds a copy of the data and allows to modify the contents. Field <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a> of this class is declared as an anonymous union of a <em>const char*</em> and a <em>char*</em> but the latter is not exposed. It might be exposed by derived classes (and is by class <span>AString</span>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For an introduction into the <b>ALib</b> string classes see <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">namespace strings</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TChar</td><td>The character type. Implementations for <code>char</code> and <code>wchar_t</code> are provided with type definitions <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">aworx::NString</a> and <a class="el" href="namespaceaworx.html#a4e2054049ab1c56bb65a50c2ccd046d5">aworx::WString</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Inner Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase_1_1RandomAccessIteratorBase.html">RandomAccessIteratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:ab4c98745f668b50cb05de83be4f8880a"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ab4c98745f668b50cb05de83be4f8880a">StringBase</a> ()</td></tr>
<tr class="separator:ab4c98745f668b50cb05de83be4f8880a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6295005ac5c23795d382fc90a284ea20"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a6295005ac5c23795d382fc90a284ea20">StringBase</a> (const TChar *<a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a>, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> contentLength)</td></tr>
<tr class="separator:a6295005ac5c23795d382fc90a284ea20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb89f1194ce11503120d97aca0f8ad6"><td class="memTemplParams" colspan="2">template&lt;typename TStringLike &gt; </td></tr>
<tr class="memitem:a1fb89f1194ce11503120d97aca0f8ad6"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a1fb89f1194ce11503120d97aca0f8ad6">StringBase</a> (const TStringLike &amp;src)</td></tr>
<tr class="separator:a1fb89f1194ce11503120d97aca0f8ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d88db63363ba01226cc1bbf9378da26"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a6d88db63363ba01226cc1bbf9378da26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a6d88db63363ba01226cc1bbf9378da26">Substring</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength=<a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a>) const</td></tr>
<tr class="separator:a6d88db63363ba01226cc1bbf9378da26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Buffer Access, Length and State</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:aa84b2d544b50b9e3a50e89952bc61c19"><td class="memItemLeft" align="right" valign="top">const TChar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aa84b2d544b50b9e3a50e89952bc61c19">Buffer</a> () const</td></tr>
<tr class="separator:aa84b2d544b50b9e3a50e89952bc61c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a515bdd031a8d3b713bb05edcf126c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> () const</td></tr>
<tr class="separator:a78a515bdd031a8d3b713bb05edcf126c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af797d8a0c58407810576860f553e25d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af797d8a0c58407810576860f553e25d3">WStringLength</a> () const</td></tr>
<tr class="separator:af797d8a0c58407810576860f553e25d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d637a0dec45d546495c1660c9f6047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a> () const</td></tr>
<tr class="separator:ac4d637a0dec45d546495c1660c9f6047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1975261f9100a453259d7df75ad4080d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a1975261f9100a453259d7df75ad4080d">IsNotNull</a> () const</td></tr>
<tr class="separator:a1975261f9100a453259d7df75ad4080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12342fc420701fbffd97025421575a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a> () const</td></tr>
<tr class="separator:a8e12342fc420701fbffd97025421575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c546c3e5ed2e243ae839807fe633140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a6c546c3e5ed2e243ae839807fe633140">IsNotEmpty</a> () const</td></tr>
<tr class="separator:a6c546c3e5ed2e243ae839807fe633140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Character access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a3a8ae5b43c650ce179280c511afeec30"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a3a8ae5b43c650ce179280c511afeec30"><td class="memTemplItemLeft" align="right" valign="top">TChar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a3a8ae5b43c650ce179280c511afeec30">CharAt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx) const</td></tr>
<tr class="separator:a3a8ae5b43c650ce179280c511afeec30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f28f01d1597b6155ce16b0f37553f72"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a7f28f01d1597b6155ce16b0f37553f72"><td class="memTemplItemLeft" align="right" valign="top">TChar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a7f28f01d1597b6155ce16b0f37553f72">CharAtStart</a> () const</td></tr>
<tr class="separator:a7f28f01d1597b6155ce16b0f37553f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bee18b76ce1db4bb98c7cc55100f09"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ad7bee18b76ce1db4bb98c7cc55100f09"><td class="memTemplItemLeft" align="right" valign="top">TChar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ad7bee18b76ce1db4bb98c7cc55100f09">CharAtEnd</a> () const</td></tr>
<tr class="separator:ad7bee18b76ce1db4bb98c7cc55100f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb7a5c77149422bdd4b6cf186f68408"><td class="memItemLeft" align="right" valign="top">TChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a7fb7a5c77149422bdd4b6cf186f68408">operator[]</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx) const</td></tr>
<tr class="separator:a7fb7a5c77149422bdd4b6cf186f68408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a77e806163516e9161d77a9e64030d2ac"><td class="memTemplParams" colspan="2">template&lt;lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a77e806163516e9161d77a9e64030d2ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a77e806163516e9161d77a9e64030d2ac">Equals</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle) const</td></tr>
<tr class="separator:a77e806163516e9161d77a9e64030d2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba246a73e13d354258f8c4b669c7f20"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a1ba246a73e13d354258f8c4b669c7f20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a1ba246a73e13d354258f8c4b669c7f20">ContainsAt</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> pos) const</td></tr>
<tr class="separator:a1ba246a73e13d354258f8c4b669c7f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123e6feae7d2fc943941458bfcbdcffa"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a123e6feae7d2fc943941458bfcbdcffa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a123e6feae7d2fc943941458bfcbdcffa">StartsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle) const</td></tr>
<tr class="separator:a123e6feae7d2fc943941458bfcbdcffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1791ab596ba005471ed1d472ccf65335"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a1791ab596ba005471ed1d472ccf65335"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a1791ab596ba005471ed1d472ccf65335">EndsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle) const</td></tr>
<tr class="separator:a1791ab596ba005471ed1d472ccf65335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf79607d9f0720255fd795ad639f0d0d"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, Case TSensitivity = Case::Sensitive&gt; </td></tr>
<tr class="memitem:acf79607d9f0720255fd795ad639f0d0d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#acf79607d9f0720255fd795ad639f0d0d">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle) const</td></tr>
<tr class="separator:acf79607d9f0720255fd795ad639f0d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af791b47bf062f4de21687bb1db2c0ec6"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, Case TSensitivity = Case::Sensitive&gt; </td></tr>
<tr class="memitem:af791b47bf062f4de21687bb1db2c0ec6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af791b47bf062f4de21687bb1db2c0ec6">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> needleRegionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> needleRegionLength=<a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a>) const</td></tr>
<tr class="separator:af791b47bf062f4de21687bb1db2c0ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9881a4940b82d5d0750699fae4bdaa2"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, Case TSensitivity = Case::Sensitive&gt; </td></tr>
<tr class="memitem:ac9881a4940b82d5d0750699fae4bdaa2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ac9881a4940b82d5d0750699fae4bdaa2">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> cmpRegionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> cmpRegionLength, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength=<a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a>) const</td></tr>
<tr class="separator:ac9881a4940b82d5d0750699fae4bdaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f2658f00a1091fdd0e1979a7ca2309"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a47f2658f00a1091fdd0e1979a7ca2309">operator&lt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;op) const</td></tr>
<tr class="separator:a47f2658f00a1091fdd0e1979a7ca2309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b85950d4ef038f5b5784ddf533548b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a8b85950d4ef038f5b5784ddf533548b4">operator&lt;=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;op) const</td></tr>
<tr class="separator:a8b85950d4ef038f5b5784ddf533548b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778f491ab6849fa74efea7144833c754"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a778f491ab6849fa74efea7144833c754">operator&gt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;op) const</td></tr>
<tr class="separator:a778f491ab6849fa74efea7144833c754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a149591ab34ea9129f278855a22bc37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a2a149591ab34ea9129f278855a22bc37">operator&gt;=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;op) const</td></tr>
<tr class="separator:a2a149591ab34ea9129f278855a22bc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2314adbed14db4878e2eeda25e6d8f66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a2314adbed14db4878e2eeda25e6d8f66">operator==</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;op) const</td></tr>
<tr class="separator:a2314adbed14db4878e2eeda25e6d8f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd4452c9f8b70477346f0e65f5d5904"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a0bd4452c9f8b70477346f0e65f5d5904">operator!=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;op) const</td></tr>
<tr class="separator:a0bd4452c9f8b70477346f0e65f5d5904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Search</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a212bf8ac1fbd26ee2740a61335afbf46"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a212bf8ac1fbd26ee2740a61335afbf46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a212bf8ac1fbd26ee2740a61335afbf46">IndexOf</a> (TChar needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0) const</td></tr>
<tr class="separator:a212bf8ac1fbd26ee2740a61335afbf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b228a837e78783bdcfc26e63174ea7"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ac1b228a837e78783bdcfc26e63174ea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ac1b228a837e78783bdcfc26e63174ea7">IndexOf</a> (TChar needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength) const</td></tr>
<tr class="separator:ac1b228a837e78783bdcfc26e63174ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf382457574b8f75a7a6506bc0ec6951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#abf382457574b8f75a7a6506bc0ec6951">IndexOfOrLength</a> (TChar needle) const</td></tr>
<tr class="separator:abf382457574b8f75a7a6506bc0ec6951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b8eacef0334c6af457f0c86724a7a9"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a65b8eacef0334c6af457f0c86724a7a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a65b8eacef0334c6af457f0c86724a7a9">IndexOfOrLength</a> (TChar needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx) const</td></tr>
<tr class="separator:a65b8eacef0334c6af457f0c86724a7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38bce942d05842f4ecefb1140eb3bf6"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:af38bce942d05842f4ecefb1140eb3bf6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af38bce942d05842f4ecefb1140eb3bf6">LastIndexOf</a> (TChar needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIndex=<a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a>) const</td></tr>
<tr class="separator:af38bce942d05842f4ecefb1140eb3bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eaa001240a349fac9478220b23403a"><td class="memTemplParams" colspan="2">template&lt;lang::Inclusion TInclusion, bool TCheck = true&gt; </td></tr>
<tr class="memitem:a29eaa001240a349fac9478220b23403a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a29eaa001240a349fac9478220b23403a">IndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needles, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0) const</td></tr>
<tr class="separator:a29eaa001240a349fac9478220b23403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119f7bb46c931ad30a335e5ab83dabee"><td class="memTemplParams" colspan="2">template&lt;lang::Inclusion TInclusion, bool TCheck = true&gt; </td></tr>
<tr class="memitem:a119f7bb46c931ad30a335e5ab83dabee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a119f7bb46c931ad30a335e5ab83dabee">LastIndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needles, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=<a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a>) const</td></tr>
<tr class="separator:a119f7bb46c931ad30a335e5ab83dabee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fe4e938720efa83da98ff27535671b"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a85fe4e938720efa83da98ff27535671b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a85fe4e938720efa83da98ff27535671b">IndexOf</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0) const</td></tr>
<tr class="separator:a85fe4e938720efa83da98ff27535671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44be8c55047fd0c8b8bc2608ce947aa2"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a44be8c55047fd0c8b8bc2608ce947aa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a44be8c55047fd0c8b8bc2608ce947aa2">IndexOfFirstDifference</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx=0) const</td></tr>
<tr class="separator:a44be8c55047fd0c8b8bc2608ce947aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dcd2cfc8117ddbf8c4833d70dc79db"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a82dcd2cfc8117ddbf8c4833d70dc79db"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a82dcd2cfc8117ddbf8c4833d70dc79db">CountChar</a> (TChar needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startPos=0) const</td></tr>
<tr class="separator:a82dcd2cfc8117ddbf8c4833d70dc79db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cafb3e217bd74359d28dfd3a00aaa7"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a25cafb3e217bd74359d28dfd3a00aaa7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a25cafb3e217bd74359d28dfd3a00aaa7">CountChar</a> (TChar needle, TChar omit, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startPos) const</td></tr>
<tr class="separator:a25cafb3e217bd74359d28dfd3a00aaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e186f758b6878c57503abc95ae28de4"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a5e186f758b6878c57503abc95ae28de4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a5e186f758b6878c57503abc95ae28de4">Count</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startPos=0) const</td></tr>
<tr class="separator:a5e186f758b6878c57503abc95ae28de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753f5f6772a185f6226d3fdbe3343cb1"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a753f5f6772a185f6226d3fdbe3343cb1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a753f5f6772a185f6226d3fdbe3343cb1">Count</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;omit, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startPos=0) const</td></tr>
<tr class="separator:a753f5f6772a185f6226d3fdbe3343cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parsing Numbers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:ae90a74f69e3f3a6bd49c0ac9ee49fa2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ae90a74f69e3f3a6bd49c0ac9ee49fa2b">ParseDecDigits</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:ae90a74f69e3f3a6bd49c0ac9ee49fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3e1d26d3a4f7f4c4c52e0986ab4d7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#abb3e1d26d3a4f7f4c4c52e0986ab4d7d">ParseInt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:abb3e1d26d3a4f7f4c4c52e0986ab4d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512d7720544451fd156ab37ea14faae2"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a512d7720544451fd156ab37ea14faae2">ParseInt</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a512d7720544451fd156ab37ea14faae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a06eeb9f1360a0b05a6535befce22a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a28a06eeb9f1360a0b05a6535befce22a">ParseInt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a28a06eeb9f1360a0b05a6535befce22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40f70946dd0e0dd6cfe16eab99641ad"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aa40f70946dd0e0dd6cfe16eab99641ad">ParseInt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:aa40f70946dd0e0dd6cfe16eab99641ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ee16992c512b6019dbeebb89953b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af2ee16992c512b6019dbeebb89953b44">ParseDec</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:af2ee16992c512b6019dbeebb89953b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18e3430a8c1b1c4ccecafc12f87b3f3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ac18e3430a8c1b1c4ccecafc12f87b3f3">ParseDec</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:ac18e3430a8c1b1c4ccecafc12f87b3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b1e60ca537a6dac5999b997f5218d2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a93b1e60ca537a6dac5999b997f5218d2">ParseDec</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a93b1e60ca537a6dac5999b997f5218d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a273a98a915a9a61fc7995c40085de2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a5a273a98a915a9a61fc7995c40085de2">ParseDec</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a5a273a98a915a9a61fc7995c40085de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f558f35101b0708244e6c39ab97dbc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a2f558f35101b0708244e6c39ab97dbc2">ParseBin</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a2f558f35101b0708244e6c39ab97dbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46cd229d906fd1b073270233be5fb64"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ae46cd229d906fd1b073270233be5fb64">ParseBin</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:ae46cd229d906fd1b073270233be5fb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69fd90f441ff55fa73e34c78b128e73"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ae69fd90f441ff55fa73e34c78b128e73">ParseBin</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:ae69fd90f441ff55fa73e34c78b128e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dd5d8854654a2781e1595823df6f24"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a83dd5d8854654a2781e1595823df6f24">ParseBin</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a83dd5d8854654a2781e1595823df6f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50beefcaa92d04c3c3a819a185ba9e59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a50beefcaa92d04c3c3a819a185ba9e59">ParseHex</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a50beefcaa92d04c3c3a819a185ba9e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedd85b10e70a754cde6fc1336703a66"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#adedd85b10e70a754cde6fc1336703a66">ParseHex</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:adedd85b10e70a754cde6fc1336703a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9272a2301c548f706d207165d153bc0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ac9272a2301c548f706d207165d153bc0">ParseHex</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:ac9272a2301c548f706d207165d153bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7cbc449ac1997e1b069cf3cef5140f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#afa7cbc449ac1997e1b069cf3cef5140f">ParseHex</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:afa7cbc449ac1997e1b069cf3cef5140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e33684d83e29a23395c9da90c94337d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a8e33684d83e29a23395c9da90c94337d">ParseOct</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a8e33684d83e29a23395c9da90c94337d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eecf2122e05d7522eaaa8d21977b99"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ad4eecf2122e05d7522eaaa8d21977b99">ParseOct</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:ad4eecf2122e05d7522eaaa8d21977b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434944b66df7cebd59d8ae16b41dca05"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a434944b66df7cebd59d8ae16b41dca05">ParseOct</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a434944b66df7cebd59d8ae16b41dca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8253dc78198cc4207e93b612222f0bfb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a8253dc78198cc4207e93b612222f0bfb">ParseOct</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a8253dc78198cc4207e93b612222f0bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee49fe3354e6402bee3c951f26580340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aee49fe3354e6402bee3c951f26580340">ParseFloat</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:aee49fe3354e6402bee3c951f26580340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a97fa3b1a25516ca6e54aa39f615fe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a54a97fa3b1a25516ca6e54aa39f615fe">ParseFloat</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a54a97fa3b1a25516ca6e54aa39f615fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c8bcafc22b07e8b40d33606970b409"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ae2c8bcafc22b07e8b40d33606970b409">ParseFloat</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:ae2c8bcafc22b07e8b40d33606970b409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3764e8f6da9a144f7e721258ea5a8152"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a3764e8f6da9a144f7e721258ea5a8152">ParseFloat</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a3764e8f6da9a144f7e721258ea5a8152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a9d76a1d6d4d3e9e15e239ce47b4b715d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a9d76a1d6d4d3e9e15e239ce47b4b715d">CopyTo</a> (TChar *dest) const</td></tr>
<tr class="separator:a9d76a1d6d4d3e9e15e239ce47b4b715d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Helper methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:abbbca75c8d760ba66c441e9f67273a7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#abbbca75c8d760ba66c441e9f67273a7f">AdjustRegion</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;regionLength) const</td></tr>
<tr class="separator:abbbca75c8d760ba66c441e9f67273a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Fields</h2></td></tr>
<tr class="memitem:a40158f724cad985410aecfa3ae24d69c"><td class="memItemLeft" align="right" valign="top">const TChar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a></td></tr>
<tr class="separator:a40158f724cad985410aecfa3ae24d69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af940c51e198511031f839dec6e7f1b71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af940c51e198511031f839dec6e7f1b71">length</a></td></tr>
<tr class="separator:af940c51e198511031f839dec6e7f1b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6b67a5303af331571356899a9f7257"><td class="memItemLeft" align="right" valign="top">TChar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#acd6b67a5303af331571356899a9f7257">vbuffer</a></td></tr>
<tr class="separator:acd6b67a5303af331571356899a9f7257"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
std::iterator</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp152bdea49501981808ffd45d7c70c609"></a></p><h6></h6>
<h2></h2>
</td></tr>
<tr class="memitem:a00756c37c765de4b687b1f5bf3baebb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a> = <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase_1_1RandomAccessIteratorBase.html">RandomAccessIteratorBase</a>&lt; const TChar *, const TChar &amp; &gt;</td></tr>
<tr class="separator:a00756c37c765de4b687b1f5bf3baebb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fee900c7aee90671038c79225bf8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ad5fee900c7aee90671038c79225bf8ec">begin</a> () const</td></tr>
<tr class="separator:ad5fee900c7aee90671038c79225bf8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b6e2a03c835ca5d658a1f16acbaa9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a69b6e2a03c835ca5d658a1f16acbaa9c">end</a> () const</td></tr>
<tr class="separator:a69b6e2a03c835ca5d658a1f16acbaa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddd459664161ca6cab975b341ac76a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#adddd459664161ca6cab975b341ac76a8">StringBase</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a> &amp;start, <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a> &amp;<a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a69b6e2a03c835ca5d658a1f16acbaa9c">end</a>)</td></tr>
<tr class="separator:adddd459664161ca6cab975b341ac76a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6456298b3a9e804a766ab14df1dd632"><td class="memTemplParams" colspan="2">template&lt;lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:ad6456298b3a9e804a766ab14df1dd632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga92dffb610bb065c39d0c26293cbd63d0">ALIB_WARNINGS_IGNORE_DOCS</a> <a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#ad6456298b3a9e804a766ab14df1dd632">indexOfString</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx) const</td></tr>
<tr class="separator:ad6456298b3a9e804a766ab14df1dd632"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a00756c37c765de4b687b1f5bf3baebb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00756c37c765de4b687b1f5bf3baebb3">&#9670;&nbsp;</a></span>ConstIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a> =  <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase_1_1RandomAccessIteratorBase.html">RandomAccessIteratorBase</a>&lt;const TChar*, const TChar&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constant iterator exposed by this character container. A Mutable version is found only in descendant classes (e.g. <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">AString</a>). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4c98745f668b50cb05de83be4f8880a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c98745f668b50cb05de83be4f8880a">&#9670;&nbsp;</a></span>StringBase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs a <em>nulled</em> StringBase </p>

</div>
</div>
<a id="a6295005ac5c23795d382fc90a284ea20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6295005ac5c23795d382fc90a284ea20">&#9670;&nbsp;</a></span>StringBase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> </td>
          <td>(</td>
          <td class="paramtype">const TChar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>contentLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs this object using the given external buffer and length of content.</p>
<dl class="section note"><dt>Note</dt><dd>The provided buffer does not need to be zero-terminated. However, there must not be any '\0' characters within the start and the given <span>contentLength</span>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to use. </td></tr>
    <tr><td class="paramname">contentLength</td><td>The length of the content in the given buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fb89f1194ce11503120d97aca0f8ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb89f1194ce11503120d97aca0f8ad6">&#9670;&nbsp;</a></span>StringBase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> </td>
          <td>(</td>
          <td class="paramtype">const TStringLike &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Templated constructor for different types. This constructor uses some template meta programming to provide maximum flexibility to implicitly embed the data of any string type in an object of type String.</p>
<p>This constructor accepts the following types:</p><ul>
<li><em>nullptr</em> (creates a <em>nulled</em> String).</li>
<li><em>[const] TChar*</em></li>
<li>Classes derived from String.</li>
<li>User defined (external) types. See documentation of <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a> on how to add support for implicit construction of <b>ALib</b> strings from custom string types.</li>
<li>User defined literal types. See documentation of <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__StringLiteral.html">T_StringLiteral</a>.</li>
</ul>
<p>When a non-supported type is passed, a compile-time error (<code>static_assert</code>) is raised. In some rare cases, dependent on the compiler and platform, some false alarms may be given for types that are not even passed to the constructor, but the compiler wrongly "thinks" that such type is passed. For example, with advanced use of <code>std::tuple</code> template class, such errors might occur. To suppress a "false" error, use macro <a class="el" href="group__GrpALibStringsMacros.html#ga9b8c6c053a556ee1e1be49592a23c282">ALIB_STRING_CONSTRUCTOR_FIX</a> for the type in question.</p>
<dl class="section note"><dt>Note</dt><dd>Other than the type of parameter <span>src</span> (<em>const TStringLike&amp;</em>) may indicate, objects of the class types named above may be provided as pointer or reference. The TMP will detect <code>nullptr</code> and otherwise convert pointers to references.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>For more information, see <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">namespace documentation</a> and template function <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TStringLike</td><td>Type that allows to construct <a class="el" href="classaworx_1_1lib_1_1strings_1_1Strings.html">Strings</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source of template type T to take the buffer and length from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adddd459664161ca6cab975b341ac76a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddd459664161ca6cab975b341ac76a8">&#9670;&nbsp;</a></span>StringBase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs this string using start and end iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>An iterator referencing the start of the string. </td></tr>
    <tr><td class="paramname">end</td><td>An iterator referencing the end of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abbbca75c8d760ba66c441e9f67273a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbca75c8d760ba66c441e9f67273a7f">&#9670;&nbsp;</a></span>AdjustRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AdjustRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>regionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Adjusts a given region (in/out parameters) to fit to this object's range [0..length].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">regionStart</td><td>The proposed region start which might get adjusted to fit to range [0..length]. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">regionLength</td><td>The proposed region length which might get adjusted to fit to range [0..length].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code>, if the adjusted region is empty. </dd></dl>

</div>
</div>
<a id="ad5fee900c7aee90671038c79225bf8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fee900c7aee90671038c79225bf8ec">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the start of this string. </p><dl class="section return"><dt>Returns</dt><dd>The start of this string. </dd></dl>

</div>
</div>
<a id="aa84b2d544b50b9e3a50e89952bc61c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84b2d544b50b9e3a50e89952bc61c19">&#9670;&nbsp;</a></span>Buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TChar* Buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns a pointer to the first character of the string we are representing. </p><dl class="section note"><dt>Note</dt><dd>The string is not guaranteed to be zero terminated.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The internal buffer array. </dd></dl>

</div>
</div>
<a id="a3a8ae5b43c650ce179280c511afeec30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8ae5b43c650ce179280c511afeec30">&#9670;&nbsp;</a></span>CharAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TChar CharAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Retrieves the character at the given index. A range check is performed. If this fails, '\0' is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the character to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character at the given index, or '\0' if index out of range. </dd></dl>

</div>
</div>
<a id="ad7bee18b76ce1db4bb98c7cc55100f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bee18b76ce1db4bb98c7cc55100f09">&#9670;&nbsp;</a></span>CharAtEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TChar CharAtEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Retrieves the last character. In case of an empty or <em>nulled</em> string, '\0' is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for an empty or <em>nulled</em> object is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last character in the String. If this instance's length is zero, '\0' is returned. </dd></dl>

</div>
</div>
<a id="a7f28f01d1597b6155ce16b0f37553f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f28f01d1597b6155ce16b0f37553f72">&#9670;&nbsp;</a></span>CharAtStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TChar CharAtStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Retrieves the first character. In case of an empty or <em>nulled</em> string, '\0' is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for an empty or <em>nulled</em> object is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first character in the String. If this instance's length is zero, '\0' is returned. </dd></dl>

</div>
</div>
<a id="acf79607d9f0720255fd795ad639f0d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf79607d9f0720255fd795ad639f0d0d">&#9670;&nbsp;</a></span>CompareTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares this with another StringBase.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for a <em>nulled</em> object (this) performed and this string must not be of zero length (while <span>needle</span> might be of zero length). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if this and <span>needle</span> are <em>nulled</em> or if both have a length of 0 or if both share the same content</li>
<li>&lt;0 if this is <em>nulled</em> and <span>needle</span> is not or if this is smaller than <span>needle</span>.</li>
<li>&gt;0 if this is not <em>nulled</em> but <span>needle</span> is or if this is greater than <span>needle</span>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af791b47bf062f4de21687bb1db2c0ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af791b47bf062f4de21687bb1db2c0ec6">&#9670;&nbsp;</a></span>CompareTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>needleRegionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>needleRegionLength</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares this with a region of another StringBase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare this string with. </td></tr>
    <tr><td class="paramname">needleRegionStart</td><td>The start of the region in <span>needle</span> to compare this object with. </td></tr>
    <tr><td class="paramname">needleRegionLength</td><td>The length of the region in <span>needle</span> to compare this object with. Defaults to <b>MaxLen</b>; </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for a <em>nulled</em> comparison object is performed and this string must not be empty. Furthermore, no check is performed whether the given region fits to parameter <span>needle</span>. This also means that the default value must not be used with <em>TCheck==&lt;<code>false&gt;</em></code>. </td></tr>
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if this and <span>needle</span> are <em>nulled</em> or if both have a length of 0 or if both share the same content</li>
<li>&lt;0 if this is <em>nulled</em> and <span>needle</span> is not or if this is smaller than <span>needle</span>.</li>
<li>&gt;0 if this is not <em>nulled</em> but <span>needle</span> is or if this is greater than <span>needle</span>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac9881a4940b82d5d0750699fae4bdaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9881a4940b82d5d0750699fae4bdaa2">&#9670;&nbsp;</a></span>CompareTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>cmpRegionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>cmpRegionLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares a region of this object with a region of another StringBase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare this string with. </td></tr>
    <tr><td class="paramname">cmpRegionStart</td><td>The start of the region in <span>needle</span> to compare this object with. </td></tr>
    <tr><td class="paramname">cmpRegionLength</td><td>The length of the region in <span>needle</span> to compare this object with. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in this object to compare with </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in this object to compare with. Defaults to <b>MaxLen</b>; </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for a <em>nulled</em> comparison object is performed and this string must not be empty. Furthermore, no check is performed whether the given regions fit to this object respectively the other region to the object given with parameter <span>needle</span>. This also means that the default value must not be used with <em>TCheck==&lt;<code>false&gt;</em></code>. </td></tr>
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if this and <span>needle</span> are <em>nulled</em> or if both have a length of 0 or if both share the same content</li>
<li>&lt;0 if this is <em>nulled</em> and <span>needle</span> is not or if this is smaller than <span>needle</span>.</li>
<li>&gt;0 if this is not <em>nulled</em> but <span>needle</span> is or if this is greater than <span>needle</span>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1ba246a73e13d354258f8c4b669c7f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba246a73e13d354258f8c4b669c7f20">&#9670;&nbsp;</a></span>ContainsAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code>, if the given String is found at the given position.</p>
<dl class="section note"><dt>Note</dt><dd>The following rules apply<ul>
<li>If <span>pos</span> is out of range or <span>needle</span> is <em>nulled</em>, <code>false</code> is returned. (This check only done if <span>TCheck</span> equals <code>true</code>.)</li>
<li>Otherwise, if the length of <span>needle</span> is 0, <code>true</code> is returned.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare with. If is <em>nulled</em> or empty, <code>true</code> is returned. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to search for needle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is given, no check on parameter <span>pos</span> is performed and <span>needle</span> must not be <em>nulled</em>. </td></tr>
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <span>needle</span> is found at the given position. False otherwise. * </dd></dl>

</div>
</div>
<a id="a9d76a1d6d4d3e9e15e239ce47b4b715d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d76a1d6d4d3e9e15e239ce47b4b715d">&#9670;&nbsp;</a></span>CopyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> CopyTo </td>
          <td>(</td>
          <td class="paramtype">TChar *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copies the strings contents into a given character buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of this string. </dd></dl>

</div>
</div>
<a id="a5e186f758b6878c57503abc95ae28de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e186f758b6878c57503abc95ae28de4">&#9670;&nbsp;</a></span>Count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startPos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Counts all occurrences of <span>needle</span> from <span>startPos</span> to the end of the string.</p>
<p>For empty strings <span>needle</span>, <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">startPos</td><td>The index to start the counting. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, parameter <span>startIdx</span> must be valid and <span>needle</span> must not be empty. </td></tr>
    <tr><td class="paramname">TSensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to <b>Case::Sensitive</b>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference in <span>needle</span>. </dd></dl>

</div>
</div>
<a id="a753f5f6772a185f6226d3fdbe3343cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753f5f6772a185f6226d3fdbe3343cb1">&#9670;&nbsp;</a></span>Count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>omit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startPos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Counts all occurrences of <span>needle</span>, unless followed by <span>omit</span>, starting at <span>startPos</span> to the end of the string.</p>
<p>For empty strings <span>needle</span>, <code>0</code> is returned. Also, for empty strings <span>omit</span>, <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">omit</td><td>Omit occurrence if the given string follows. </td></tr>
    <tr><td class="paramname">startPos</td><td>The index to start the counting. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to <b>Case::Sensitive</b>. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, parameter <span>startIdx</span> must be valid and <span>needle</span> must not be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference in <span>needle</span>. </dd></dl>

</div>
</div>
<a id="a82dcd2cfc8117ddbf8c4833d70dc79db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dcd2cfc8117ddbf8c4833d70dc79db">&#9670;&nbsp;</a></span>CountChar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CountChar </td>
          <td>(</td>
          <td class="paramtype">TChar&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startPos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Counts all occurrences of <span>needle</span> from <span>startPos</span> to the end of the string.</p>
<p>For empty strings <span>needle</span>, <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">startPos</td><td>The index to start the counting. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference in <span>needle</span>. </dd></dl>

</div>
</div>
<a id="a25cafb3e217bd74359d28dfd3a00aaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cafb3e217bd74359d28dfd3a00aaa7">&#9670;&nbsp;</a></span>CountChar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CountChar </td>
          <td>(</td>
          <td class="paramtype">TChar&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TChar&#160;</td>
          <td class="paramname"><em>omit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Counts all occurrences of <span>needle</span>, unless followed by <span>omit</span>, starting at <span>startPos</span> to the end of the string.</p>
<p>For empty strings <span>needle</span>, <code>0</code> is returned. Also, for empty strings <span>omit</span>, <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">omit</td><td>Omit occurrence if the given character follows. </td></tr>
    <tr><td class="paramname">startPos</td><td>The index to start the counting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference in <span>needle</span>. </dd></dl>

</div>
</div>
<a id="a69b6e2a03c835ca5d658a1f16acbaa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b6e2a03c835ca5d658a1f16acbaa9c">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a00756c37c765de4b687b1f5bf3baebb3">ConstIterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first character behind this string. </p><dl class="section return"><dt>Returns</dt><dd>The end of this string. </dd></dl>

</div>
</div>
<a id="a1791ab596ba005471ed1d472ccf65335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1791ab596ba005471ed1d472ccf65335">&#9670;&nbsp;</a></span>EndsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EndsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code>, if this string ends with the string found in parameter <span>needle</span>. If <span>needle</span> is <em>nulled</em> or empty, <code>true</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare the end of this string with. If <em>nulled</em> or empty, <code>true</code> is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <span>needle</span> is found at the end of this, <code>false</code> otherwise. * </dd></dl>

</div>
</div>
<a id="a77e806163516e9161d77a9e64030d2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e806163516e9161d77a9e64030d2ac">&#9670;&nbsp;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares this with given String. <code>true</code> is returned if both are <em>nulled</em> or empty. If only one is <em>nulled</em>, <code>false</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>An String that is compared to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if contents of this and the given String are equal. </dd></dl>

</div>
</div>
<a id="a212bf8ac1fbd26ee2740a61335afbf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212bf8ac1fbd26ee2740a61335afbf46">&#9670;&nbsp;</a></span>IndexOf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOf </td>
          <td>(</td>
          <td class="paramtype">TChar&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches a character starting from a given position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index in this to start searching the character. Defaults to <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the character <span>needle</span> is not found. Otherwise the index of its first occurrence. </dd></dl>

</div>
</div>
<a id="ac1b228a837e78783bdcfc26e63174ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b228a837e78783bdcfc26e63174ea7">&#9670;&nbsp;</a></span>IndexOf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOf </td>
          <td>(</td>
          <td class="paramtype">TChar&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches a character within a region of this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region to search the character in. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region to search the character in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the character <span>needle</span> is not found. Otherwise the index of its first occurrence. </dd></dl>

</div>
</div>
<a id="a85fe4e938720efa83da98ff27535671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fe4e938720efa83da98ff27535671b">&#9670;&nbsp;</a></span>IndexOf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches the given (unterminated) StringBase in the Buffer.</p>
<p>If this string and string <span>needle</span> <span>needle</span> are known to be zero-terminated, it is advisable to use the faster implementation of this method, <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a212bf8ac1fbd26ee2740a61335afbf46">TString::IndexOf</a>.<br />
 This method is useful for example to search needles of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">Substring</a> (which are not terminatable).</p>
<p>If <span>needle</span> is empty, <span>startIdx</span> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to <b>Case::Sensitive</b>. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, parameter <span>startIdx</span> must be valid and <span>needle</span> must not be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the string is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a id="a29eaa001240a349fac9478220b23403a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29eaa001240a349fac9478220b23403a">&#9670;&nbsp;</a></span>IndexOfAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the index of the first character which is included, respectively <em>not</em> included in a given set of characters.</p>
<dl class="section note"><dt>Note</dt><dd>In derived class <b>TString</b>, a faster version (using <em>std::strpbrk()</em> respectively <em>std::strspn()</em>) is available. So, if performance is important, it might be advisable to copy this <b>StringBase</b> (and the needles) to a terminatable buffer.</dd></dl>
<p>This method searches forwards. For backwards search, see <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af38bce942d05842f4ecefb1140eb3bf6">LastIndexOf</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needles</td><td>Pointer to a zero terminated set of characters to be taken into account. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. If the given value is less than 0, it is set to 0. If it exceeds the length of the string, the length of the string is returned. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInclusion</td><td>Denotes whether the search returns the first index that holds a value that is included or that is not excluded in the set of needle characters. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is given, no parameter checks are performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character found which is included, respectively not included, in the given set of characters. If nothing is found, -1 is returned. </dd></dl>

</div>
</div>
<a id="a44be8c55047fd0c8b8bc2608ce947aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44be8c55047fd0c8b8bc2608ce947aa2">&#9670;&nbsp;</a></span>IndexOfFirstDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfFirstDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a>&#160;</td>
          <td class="paramname"><em>sensitivity</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches the first difference with given string. If this string starts with <span>needle</span>, then the length of <span>needle</span> is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">sensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to <b>Case::Sensitive</b>. </td></tr>
    <tr><td class="paramname">idx</td><td>The index in this to start comparing with <span>needle</span>. Optional and defaults to <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference found in <span>needle</span> or the needle's length. </dd></dl>

</div>
</div>
<a id="abf382457574b8f75a7a6506bc0ec6951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf382457574b8f75a7a6506bc0ec6951">&#9670;&nbsp;</a></span>IndexOfOrLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfOrLength </td>
          <td>(</td>
          <td class="paramtype">TChar&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Like <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a212bf8ac1fbd26ee2740a61335afbf46">IndexOf</a> but in case the character is not found, this method returns the length of this string instead of <code>-1</code>. Depending on the invocation context, the choice for the right version of this method may lead to shorter and more efficient code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This strings <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> if the character <span>needle</span> is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a id="a65b8eacef0334c6af457f0c86724a7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b8eacef0334c6af457f0c86724a7a9">&#9670;&nbsp;</a></span>IndexOfOrLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfOrLength </td>
          <td>(</td>
          <td class="paramtype">TChar&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Like <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a212bf8ac1fbd26ee2740a61335afbf46">IndexOf</a> but in case the character is not found, this method returns the length of this string instead of <code>-1</code>. Depending on the invocation context, the choice for the right version of this method may lead to shorter and more efficient code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index in this to start searching the character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This strings <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> if the character <span>needle</span> is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a id="ad6456298b3a9e804a766ab14df1dd632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6456298b3a9e804a766ab14df1dd632">&#9670;&nbsp;</a></span>indexOfString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga92dffb610bb065c39d0c26293cbd63d0">ALIB_WARNINGS_IGNORE_DOCS</a> <a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> indexOfString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Implementation of substring search function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The substring to search. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The start index of the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>The letter case sensitivity of the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <span>needle</span>, respectively <code>-1</code> if not found. </dd></dl>

</div>
</div>
<a id="a8e12342fc420701fbffd97025421575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12342fc420701fbffd97025421575a">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if this string is of zero length. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the actual length equals zero. </dd></dl>

</div>
</div>
<a id="a6c546c3e5ed2e243ae839807fe633140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c546c3e5ed2e243ae839807fe633140">&#9670;&nbsp;</a></span>IsNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNotEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if this string has a length of 1 or more. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the actual length does not equal zero. </dd></dl>

</div>
</div>
<a id="a1975261f9100a453259d7df75ad4080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1975261f9100a453259d7df75ad4080d">&#9670;&nbsp;</a></span>IsNotNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNotNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if field <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a> does not equal nullptr, <code>false</code> otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no buffer is allocated. </dd></dl>

</div>
</div>
<a id="ac4d637a0dec45d546495c1660c9f6047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d637a0dec45d546495c1660c9f6047">&#9670;&nbsp;</a></span>IsNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if field <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a> equals nullptr, <code>false</code> otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no buffer is allocated. </dd></dl>

</div>
</div>
<a id="af38bce942d05842f4ecefb1140eb3bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38bce942d05842f4ecefb1140eb3bf6">&#9670;&nbsp;</a></span>LastIndexOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">TChar&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches a character starting backwards from the end or a given start index.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. Also, in this case, parameter startIndex must be provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">startIndex</td><td>The index in this to start searching the character. Defaults to <b>MaxLen</b>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the character <span>needle</span> is not found. Otherwise the index of its last occurrence relative to the start index. </dd></dl>

</div>
</div>
<a id="a119f7bb46c931ad30a335e5ab83dabee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119f7bb46c931ad30a335e5ab83dabee">&#9670;&nbsp;</a></span>LastIndexOfAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> LastIndexOfAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the index of the last character which is included, respectively <em>not</em> included in a given set of characters.</p>
<p>This method searches backwards starting at the given index. For forwards search, see <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a212bf8ac1fbd26ee2740a61335afbf46">IndexOf</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needles</td><td>Pointer to a zero terminated set of characters to be searched for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. The value is cropped to be in the bounds of 0 and the length of this object minus one. Defaults to maximum integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInclusion</td><td>Denotes whether the search returns the first index that holds a value that is included or that is not excluded in the set of needle characters. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is given, no parameter checks are performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character found which is included, respectively not included, in the given set of characters. If nothing is found, -1 is returned. </dd></dl>

</div>
</div>
<a id="a78a515bdd031a8d3b713bb05edcf126c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a515bdd031a8d3b713bb05edcf126c">&#9670;&nbsp;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the length of the string we are representing.</p>
<dl class="section return"><dt>Returns</dt><dd>The length of the string represented by this. </dd></dl>

</div>
</div>
<a id="a0bd4452c9f8b70477346f0e65f5d5904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd4452c9f8b70477346f0e65f5d5904">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a77e806163516e9161d77a9e64030d2ac">Equals</a> with parameter <span>op</span> to test on equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the strings are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a47f2658f00a1091fdd0e1979a7ca2309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f2658f00a1091fdd0e1979a7ca2309">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#acf79607d9f0720255fd795ad639f0d0d">CompareTo</a> with parameter <span>op</span> to perform a lexical comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is lexically smaller then <span>op</span>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8b85950d4ef038f5b5784ddf533548b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b85950d4ef038f5b5784ddf533548b4">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#acf79607d9f0720255fd795ad639f0d0d">CompareTo</a> with parameter <span>op</span> to perform a lexical comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is lexically smaller or equal then <span>op</span>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a2314adbed14db4878e2eeda25e6d8f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2314adbed14db4878e2eeda25e6d8f66">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a77e806163516e9161d77a9e64030d2ac">Equals</a> with parameter <span>op</span> to test on equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the strings are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a778f491ab6849fa74efea7144833c754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778f491ab6849fa74efea7144833c754">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#acf79607d9f0720255fd795ad639f0d0d">CompareTo</a> with parameter <span>op</span> to perform a lexical comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is lexically greater then <span>op</span>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a2a149591ab34ea9129f278855a22bc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a149591ab34ea9129f278855a22bc37">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#acf79607d9f0720255fd795ad639f0d0d">CompareTo</a> with parameter <span>op</span> to perform a lexical comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is lexically greater or equal then <span>op</span>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a7fb7a5c77149422bdd4b6cf186f68408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb7a5c77149422bdd4b6cf186f68408">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TChar operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Reads a character at a given index.</p>
<dl class="section attention"><dt>Attention</dt><dd>Unlike other operator methods in the family of of <b>ALib</b> string classes, which are performing parameter checks (in this case a range check), this operator does <em>not</em> do a check!<br />
 The rationale is that in derived class AString, which overrides this operator returning, a reference to the character to provide write access, no reference to a character can be given if the index is out of range. This way, this method is equivalent to method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a3a8ae5b43c650ce179280c511afeec30">CharAt</a>&lt;<code>false&gt;</code>.<br />
 For safe access to characters in the buffer use <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a3a8ae5b43c650ce179280c511afeec30">CharAt</a> (with template parameter <span>TCheck</span> being <code>true</code>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the character within this objects' buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the character contained at index <span>op</span>. </dd></dl>

</div>
</div>
<a id="a2f558f35101b0708244e6c39ab97dbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f558f35101b0708244e6c39ab97dbc2">&#9670;&nbsp;</a></span>ParseBin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t ParseBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an unsigned 64-bit integer in binary format at the given position from this <b>AString</b>. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a9e55c4e4df39c06f06d0719a741d6275">NumberFormat::ParseBin</a> on the given <span>numberFormat</span> instance.<br />
 Parameter <span>numberFormat</span> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a556076ae552a1b513a84a26fa7e8f46c">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <span>newIdx</span> may be used to detect if parsing was successful. If not, it receives the value of <span>startIdx</span>, even if leading whitespaces had been read.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae46cd229d906fd1b073270233be5fb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46cd229d906fd1b073270233be5fb64">&#9670;&nbsp;</a></span>ParseBin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a2f558f35101b0708244e6c39ab97dbc2">ParseBin</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae69fd90f441ff55fa73e34c78b128e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69fd90f441ff55fa73e34c78b128e73">&#9670;&nbsp;</a></span>ParseBin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a2f558f35101b0708244e6c39ab97dbc2">ParseBin</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a83dd5d8854654a2781e1595823df6f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83dd5d8854654a2781e1595823df6f24">&#9670;&nbsp;</a></span>ParseBin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a2f558f35101b0708244e6c39ab97dbc2">ParseBin</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="af2ee16992c512b6019dbeebb89953b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ee16992c512b6019dbeebb89953b44">&#9670;&nbsp;</a></span>ParseDec() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t ParseDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an unsigned 64-bit integer in standard decimal format at the given position from this AString. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a3eed3495f9a0011bab586f9e385ac812">NumberFormatBase::ParseDec</a> on the given <span>numberFormat</span> instance.<br />
 Parameter <span>numberFormat</span> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a556076ae552a1b513a84a26fa7e8f46c">NumberFormatBase::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <span>newIdx</span> may be used to detect if parsing was successful. If not, it receives the value of <span>startIdx</span>, even if leading whitespaces had been read.</p>
<p>Sign literals <code>'-'</code> or <code>'+'</code> are <b>not</b> accepted and parsing will fail. For reading signed integer values, see methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#abb3e1d26d3a4f7f4c4c52e0986ab4d7d">ParseInt</a>, for floating point numbers <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aee49fe3354e6402bee3c951f26580340">ParseFloat</a>.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ac18e3430a8c1b1c4ccecafc12f87b3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18e3430a8c1b1c4ccecafc12f87b3f3">&#9670;&nbsp;</a></span>ParseDec() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af2ee16992c512b6019dbeebb89953b44">ParseDec</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a93b1e60ca537a6dac5999b997f5218d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b1e60ca537a6dac5999b997f5218d2">&#9670;&nbsp;</a></span>ParseDec() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af2ee16992c512b6019dbeebb89953b44">ParseDec</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a5a273a98a915a9a61fc7995c40085de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a273a98a915a9a61fc7995c40085de2">&#9670;&nbsp;</a></span>ParseDec() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af2ee16992c512b6019dbeebb89953b44">ParseDec</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae90a74f69e3f3a6bd49c0ac9ee49fa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90a74f69e3f3a6bd49c0ac9ee49fa2b">&#9670;&nbsp;</a></span>ParseDecDigits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t ParseDecDigits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Parses an integer value consisting of characters <code>'0'</code> to <code>'9'</code> from this string. <br />
Unlike with <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#abb3e1d26d3a4f7f4c4c52e0986ab4d7d">ParseInt</a> or <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af2ee16992c512b6019dbeebb89953b44">ParseDec</a>, no sign, whitespaces or group characters are accepted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index from where the integer value is tried to be parsed. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the float number that was parsed. If parsing fails, it will be set to the value of parameter startIdx. Therefore, this parameter can be used to check if a value was found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the parameter <span>newIdx</span> is set to point to the first character behind any found integer number. </dd></dl>

</div>
</div>
<a id="aee49fe3354e6402bee3c951f26580340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee49fe3354e6402bee3c951f26580340">&#9670;&nbsp;</a></span>ParseFloat() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> double ParseFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads a floating point number at the given position from this <b>AString</b>. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a707266bed27e2179d69fb84cc59bca93">NumberFormat::ParseFloat</a> on the given <span>numberFormat</span> instance.<br />
 Parameter <span>numberFormat</span> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a556076ae552a1b513a84a26fa7e8f46c">NumberFormat::Computational</a> which is configured to 'international' settings (not using the locale) and therefore also not parsing grouping characters.</p>
<p>Optional output parameter <span>newIdx</span> may be used to detect if parsing was successful. If not, it receives the value of <span>startIdx</span>, even if leading whitespaces had been read.</p>
<p>For more information on parsing options for floating point numbers and number conversion in general, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a54a97fa3b1a25516ca6e54aa39f615fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a97fa3b1a25516ca6e54aa39f615fe">&#9670;&nbsp;</a></span>ParseFloat() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ParseFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aee49fe3354e6402bee3c951f26580340">ParseFloat</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae2c8bcafc22b07e8b40d33606970b409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c8bcafc22b07e8b40d33606970b409">&#9670;&nbsp;</a></span>ParseFloat() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ParseFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aee49fe3354e6402bee3c951f26580340">ParseFloat</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a3764e8f6da9a144f7e721258ea5a8152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3764e8f6da9a144f7e721258ea5a8152">&#9670;&nbsp;</a></span>ParseFloat() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ParseFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aee49fe3354e6402bee3c951f26580340">ParseFloat</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a50beefcaa92d04c3c3a819a185ba9e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50beefcaa92d04c3c3a819a185ba9e59">&#9670;&nbsp;</a></span>ParseHex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t ParseHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an unsigned 64-bit integer in hexadecimal format at the given position from this <b>AString</b>. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a43f69916f0b14495a9939d183f07603c">NumberFormat::ParseHex</a> on the given <span>numberFormat</span> instance.<br />
 Parameter <span>numberFormat</span> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a556076ae552a1b513a84a26fa7e8f46c">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <span>newIdx</span> may be used to detect if parsing was successful. If not, it receives the value of <span>startIdx</span>, even if leading whitespaces had been read.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="adedd85b10e70a754cde6fc1336703a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedd85b10e70a754cde6fc1336703a66">&#9670;&nbsp;</a></span>ParseHex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a50beefcaa92d04c3c3a819a185ba9e59">ParseHex</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ac9272a2301c548f706d207165d153bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9272a2301c548f706d207165d153bc0">&#9670;&nbsp;</a></span>ParseHex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a50beefcaa92d04c3c3a819a185ba9e59">ParseHex</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="afa7cbc449ac1997e1b069cf3cef5140f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7cbc449ac1997e1b069cf3cef5140f">&#9670;&nbsp;</a></span>ParseHex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a50beefcaa92d04c3c3a819a185ba9e59">ParseHex</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="abb3e1d26d3a4f7f4c4c52e0986ab4d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3e1d26d3a4f7f4c4c52e0986ab4d7d">&#9670;&nbsp;</a></span>ParseInt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int64_t ParseInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Parses an integer value in decimal, binary, hexadecimal or octal format from the string by invoking method <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#ab818b67b7c45e816929e33c2b5ee4ebf">NumberFormat::ParseInt</a> on the given <span>numberFormat</span> instance.<br />
 Parameter <span>numberFormat</span> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a556076ae552a1b513a84a26fa7e8f46c">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <span>newIdx</span> may be used to detect if parsing was successful. If not, it receives the value of <span>startIdx</span>, even if leading whitespaces had been read.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a512d7720544451fd156ab37ea14faae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512d7720544451fd156ab37ea14faae2">&#9670;&nbsp;</a></span>ParseInt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ParseInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#abb3e1d26d3a4f7f4c4c52e0986ab4d7d">ParseInt</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a28a06eeb9f1360a0b05a6535befce22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a06eeb9f1360a0b05a6535befce22a">&#9670;&nbsp;</a></span>ParseInt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ParseInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#abb3e1d26d3a4f7f4c4c52e0986ab4d7d">ParseInt</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="aa40f70946dd0e0dd6cfe16eab99641ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40f70946dd0e0dd6cfe16eab99641ad">&#9670;&nbsp;</a></span>ParseInt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ParseInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#abb3e1d26d3a4f7f4c4c52e0986ab4d7d">ParseInt</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a8e33684d83e29a23395c9da90c94337d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e33684d83e29a23395c9da90c94337d">&#9670;&nbsp;</a></span>ParseOct() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t ParseOct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an unsigned 64-bit integer in octal format at the given position from this <b>AString</b>. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a0205de90f8eb3008f9c8d62754f64cea">NumberFormat::ParseOct</a> on the given <span>numberFormat</span> instance.<br />
 Parameter <span>numberFormat</span> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html#a556076ae552a1b513a84a26fa7e8f46c">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <span>newIdx</span> may be used to detect if parsing was successful. If not, it receives the value of <span>startIdx</span>, even if leading whitespaces had been read.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ad4eecf2122e05d7522eaaa8d21977b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eecf2122e05d7522eaaa8d21977b99">&#9670;&nbsp;</a></span>ParseOct() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseOct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a>&lt; TChar &gt; *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a8e33684d83e29a23395c9da90c94337d">ParseOct</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a434944b66df7cebd59d8ae16b41dca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434944b66df7cebd59d8ae16b41dca05">&#9670;&nbsp;</a></span>ParseOct() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseOct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a8e33684d83e29a23395c9da90c94337d">ParseOct</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a8253dc78198cc4207e93b612222f0bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8253dc78198cc4207e93b612222f0bfb">&#9670;&nbsp;</a></span>ParseOct() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseOct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a8e33684d83e29a23395c9da90c94337d">ParseOct</a>(int =,NumberFormatBase&lt;TChar&gt;* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <span>startIdx</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a123e6feae7d2fc943941458bfcbdcffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123e6feae7d2fc943941458bfcbdcffa">&#9670;&nbsp;</a></span>StartsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StartsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt; TChar &gt; &amp;&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code>, if this string starts with the string found in parameter <span>needle</span>. If <span>needle</span> is <em>nulled</em> or empty, <code>true</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare the start of this string with. If <em>nulled</em> or empty, <code>true</code> is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is given, the given needle must not be empty and must not be longer than this string! <span>pos</span> is performed and <span>needle</span> must not be <em>nulled</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <span>needle</span> is found at the start of this, <code>false</code> otherwise. * </dd></dl>

</div>
</div>
<a id="a6d88db63363ba01226cc1bbf9378da26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d88db63363ba01226cc1bbf9378da26">&#9670;&nbsp;</a></span>Substring()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a>&lt;TChar&gt; <a class="el" href="namespaceaworx.html#a0b6bbb077ffab175127cbb67c9d5ead0">Substring</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns a sub-string of this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>The start of the region within this string. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region to return. Defaults to <b>MaxLen</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing a region of this string. </dd></dl>

</div>
</div>
<a id="af797d8a0c58407810576860f553e25d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af797d8a0c58407810576860f553e25d3">&#9670;&nbsp;</a></span>WStringLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> WStringLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Returns the length of the string if represented as a wide character string. If template parameter <span>TChar</span> equals <code>wchar_t</code>, then this is identical with <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a>.</p>
<p>Otherwise the calculation is done using</p><ul>
<li><em>mbsnrtowcs()</em> (without providing a conversion buffer) on glibc platforms (e.g. Linux)</li>
<li><em>MultiByteToWideChar()</em> (without providing a conversion buffer) on the Windows platform.</li>
</ul>
<p>If the conversion fails, <code>-1</code> is returned.</p>
<dl class="section note"><dt>Note</dt><dd>On GNU/Linux and Mac OS, it might be necessary to invoke std c method <em>setlocale()</em> once, prior to using this method, to successfully calculate the length. This, by default, is done in <a class="el" href="classaworx_1_1lib_1_1ALib.html#a0f7439457156e6270dfd3ccfd07e1ea1">ALib::init</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The length of string when it was converted to wide characters. If counting failed (what means that the conversion will fail) <code>-1</code> is returned. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a40158f724cad985410aecfa3ae24d69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40158f724cad985410aecfa3ae24d69c">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TChar* buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to an array of characters that holds the string we are representing. Read access to this field is granted with method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#aa84b2d544b50b9e3a50e89952bc61c19">Buffer</a>. </p>

</div>
</div>
<a id="af940c51e198511031f839dec6e7f1b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af940c51e198511031f839dec6e7f1b71">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The length of the string represented by us. Read access to this field is granted with method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a>. </p>

</div>
</div>
<a id="acd6b67a5303af331571356899a9f7257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6b67a5303af331571356899a9f7257">&#9670;&nbsp;</a></span>vbuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TChar* vbuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-constant version of field <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a>. This field is not used in this class, but has to be declared here, because it constitutes an anonymous union with field <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a>. Derived classes might use and expose this field, like e.g. class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">AString</a> does. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="string_8hpp_source.html">string.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 12 2018 15:57:47 for ALib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
