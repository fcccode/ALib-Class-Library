<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALib: aworx::lib::strings Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALib
   &#160;<span id="projectnumber">V. 1805 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html">strings</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Nested namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">aworx::lib::strings Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Programmer's Manual</h2>
<div class="textblock"><p>This is namespace documentation starts with a comprehensive programmer's manual.<br />
 <b>Reference documentation</b> is found below:</p>
<ul>
<li><a href="#namespaces">Nested Namespaces</a></li>
<li><a href="#nested-classes">Classes</a></li>
<li><a href="#typedef-members">Typedefs</a> and</li>
<li><a href="#func-members">Functions</a></li>
</ul>
<h1>ALib Strings - Programmer's Manual</h1>
<p><b>Contents:</b></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_intro">1. Introduction</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_intro_hell">1.1 The C++ String Hell</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_intro_goals">1.2 Library Design Goals</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_intro_feat">1.3 Library Features</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_characters">2. Characters</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_char_hell">2.1 The Character Hell</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_char_by_width">2.2 ALib Character Types By Widths</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_char_by_logic">2.3 ALib Logical Character Types</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_char_summary">2.4 Character Type Summary</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_templated">3. Templated String Types</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes">4. The String Classes</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_String">4.1 Class String</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_String_custom">4.1.1 Binding User Types To %ALib Strings</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_String_nullable">4.1.2 Nullable %Strings</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_String_term">4.1.3 No Zero-Termination</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_TString">4.2 Class TString</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_AString">4.3 Class AString</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_AString_constr">4.3.1 Construction</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_AString_bufmngmnt">4.3.2 Buffer Management</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_AString_apply">4.3.3 Appending and Applying Objects</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_PAString">4.4 Class PreallocatedString</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_PAString_bo">4.4.1 Exceeding the Buffer Capacity</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_PAString_constr">4.4.2 Implicit Construction</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_PAString_move">4.4.3 No Move Constructor</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_PAString_aliases">4.4.4 Aliases For Frequently Used Sizes</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_Substring">4.5 Class Substring</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_StringLiteral">4.6 Class StringLiteral</a></p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_details">5. Details On Strings</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_details_nonchecking">5.1 "Non-Checking Methods" Of ALib String Classes</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_details_format">5.2 Formatting Strings</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_details_compat">5.3 Compatibility with External Libraries</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_details_debug">5.4 Debugging ALib String Classes</a></p>
<p><a class="anchor" id="alib_strings_intro"></a></p><h1>1. Introduction</h1>
<p><a class="anchor" id="alib_strings_intro_hell"></a></p><h2>1.1 The C/C++ String Hell</h2>
<p>C++ programmer's do not need to get motivated about using a 3rd-party string library. This is true due to the fact that the language itself does not offer a powerful built-in type that solves their daily needs.</p>
<p>Even worse, there are two types of character strings available:</p><ol type="1">
<li>Traditional zero-terminated string buffers, also called a "c-string" (in this manual <em>cstring</em>), and</li>
<li>C++ <code>std::basic_string&lt;CharT&gt;</code> template class.</li>
</ol>
<p>Even if <em>cstrings</em> are not supposed to be used in modern software, they still are needed and will be in the (long) future, because they until today are used when strings are exchanged between software units, especially when it comes to operating system function calls.</p>
<dl class="section note"><dt>Note</dt><dd>We, the makers of <b>ALib</b>, very much agree to the theses that the invention of zero-terminated strings during the previous millennium, was one of the <a href="http://queue.acm.org/detail.cfm?id=2010365">most expensive one-byte mistakes</a> of IT-history!</dd></dl>
<p>The second type, which is the base for <code>std::string</code> and <code>std::wstring</code> is a nice feature of the standard library, but - in the its typical, rightfully minimalistic fashion - there are no higher level string features available with them. But apart from such higher level features that are found in string types of almost any programing language (see Java, C+, Python, etc.) the single missing feature that really constitute the need of a 3rd party string is the fact that class std::basic_string does not allow to distinguish between strings that are constant and immutable and those that have a dynamically managed (growing) buffer attached. The following simple line of code: </p><pre class="fragment">   std::string  s= "string";
</pre><p>claims heap memory and copies the characters into the allocated string buffer. To avoid this overhead, a programmer would often write </p><pre class="fragment">   const char* s= "string";
</pre><p>Unfortunately, now we have a cstring: This means the information about the string's length disappeared. So, where did it go? Well, technically it was "casted away" by the compiler. Therefore a programmer could write: </p><pre class="fragment">   char s[]= "string";
</pre><p>and voila, the type of variable <code>s</code> would become <code>char[7]</code>. But why <code>7</code>, not <code>6</code>? Because the array is created from a cstring, which is a zero-terminated array and the character array includes this termination character. So, the array somehow has the "wrong" length. Apart from this, the length is stuck in the type, hence known to the compiler but not at run-time. Therefore, a string class is needed that comprises the start of the string's buffer together with the length of the string - just as <code>std::string</code> does, but without the allocation of heap memory.</p>
<p>As of C++ 17, new string class <code>std::basic_string_view</code> was added, solving exactly this: </p><pre class="fragment">   std::string_view s= "string";
</pre><p>A next stumbling block using C++ strings is the width of the characters. When type <code>wchar_t</code> was introduced, most people thought that this will solve most of the problems when it comes to international character representations and uni-code. Unfortunately, the promise was (could!) not be fulfilled because of the complexity of languages and writing codes of different human cultures worldwide. Even worse, the width of <code>wchar_t</code> was not specified by the language, therefore different compilers and platforms implement it either as two or four byte integral type. Even one byte implementation is theoretically allowed by the language specification!</p>
<p>To make it short: Any more complex C++ software needs to rely on some 3rd party string library. The string classes provided with the standard library are a basic tool for simple programs, but do not have and probably will never have the aspiration to provide the convenience that a more "high level" library will provide in this area.</p>
<p><a class="anchor" id="alib_strings_intro_goals"></a></p><h2>1.2 Library Design Goals</h2>
<p>The design goals of module <b>ALib Strings</b> are:</p>
<p><b>1. The Provision of high level string features</b><br />
 </p><dl class="section user"><dt></dt><dd>As explained in the previous chapter, the C++ standard library does not have this goal, hence such features are needed to be added.</dd></dl>
<p><b>2. Mitigate the "%CString-Problem"</b><br />
 </p><dl class="section user"><dt></dt><dd>Zero-terminated strings are considered "evil", their use is to be reduced to a safe minimum but if necessary, their use should still be transparent and convenient.</dd></dl>
<p><b>3. Hide character widths</b><br />
 </p><dl class="section user"><dt></dt><dd>Unlike with types <code>std::string</code>, <code>std::wstring</code> or for example <code>QString</code> of the <a href="https://www.qt.io">QT Class Library</a>, the character width of <b>ALib</b> strings should be not fixed, but rather only "preferred". This preference should depend on the platform and compilation settings. Only in special situations, a programmer needs to start caring about the underlying character width. Hence code should compile without changes with different underlying string width. Furthermore, strings of different width can be conveniently converted or even transparently used in a mixed fashion.</dd></dl>
<p><b>4. Compatibility with <code>std::string</code> as well as any other 3rd-party string</b><br />
 </p><dl class="section user"><dt></dt><dd>An <b>ALib</b> principal goal is "non-intrusiveness". Hence, <b>ALib</b> strings are always considered to co-exist with other string types used in the same software module. Therefore, a last but not least important goal of <b>ALib</b> strings library design is to provide seamless conversion from any other 3rd-party string type.</dd></dl>
<p><a class="anchor" id="alib_strings_intro_feat"></a></p><h2>1.3 Library Features</h2>
<p>With the definition of the general problem and the resulting goals, the feature list of module <b>ALib Strings</b> can be well understood. It is:</p>
<ul>
<li><b>Implicit string object construction</b> from virtually any custom/3rd party string type. This is implemented using some template meta programming. Some of the consequences of this feature are:<ul>
<li>If a function/method that accepts a <b>const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b" title="Type alias in namespace aworx. ">aworx::String</a>&amp;</b>, then any object that "smells like a string" may be passed to this function.</li>
<li>This means, there is no need to overload methods to accept different string types: One method takes them all.</li>
<li>On the other hand, there is no need to convert string types when passing them. This means that users of libraries which use <b><a class="el" href="classaworx_1_1lib_1_1ALib.html">ALib</a> <a class="el" href="classaworx_1_1lib_1_1strings_1_1Strings.html">Strings</a></b>, do not need to know about <a class="el" href="classaworx_1_1lib_1_1ALib.html">ALib</a> <a class="el" href="classaworx_1_1lib_1_1strings_1_1Strings.html">Strings</a>. Instead, users just pass strings "as they are" (aka the 3rd party type directly). We call this "non-intrusiveness". <br />
 </li>
</ul>
</li>
<li><p class="startli">Concept of <b>"application of objects to strings"</b>, for example using operator <code>&lt;&lt;</code>: </p><pre class="fragment"> AString() &lt;&lt; anyObject;
</pre><p class="startli">Such "application" of arbitrarily typed objects usually means: "appending a human readable representation of the object to the string". This is very similar to <code>"Object.ToString()"</code> methods in other programming languages. Details hereof are:</p><ul>
<li>Support for fundamental C++ types included (of-course). Furthermore support for some types of the standard library as well as 3rd-party library types included.</li>
<li>Special "applicable types" are included that allow formatting of data, upper/lower conversion, etc. For example: <pre class="fragment">  AString() &lt;&lt; Format::Hex(65536);
</pre></li>
<li>Enabling support for custom types is usually a matter of a few lines of code.</li>
<li>In contrast to having <em>ToString()</em> methods (like Java, C# have), this TMP approach allows to add support for custom types without "touching" those custom types. Again, we call this "non-intrusiveness of ALib": Any existing 3rd-party type becomes "applicable" to class <b>AString</b>. <br />
 <br />
 </li>
</ul>
</li>
<li>Handles zero terminated cstrings as well as non-zero terminated strings and provides a reasonable, <b>mostly seamless bridge</b> between the two. <br />
 </li>
</ul>
<ul>
<li>Multi-byte character and unicode support and conversion between strings of differend widths (1-byte, 2-byte and 4-byte character widths). <br />
 </li>
</ul>
<ul>
<li>Various <b>tool/helper types</b>, for example:<ul>
<li>String <b>formatters</b> supporting format strings in <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterPythonStyleBase.html">Python style</a> as well as in <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterJavaStyleBase.html">Java/printf style</a>, including:<ul>
<li>hexadecimal, binary and octal number formatting</li>
<li>date/time formatting</li>
<li>custom type formatting, optionally including custom format string specifications</li>
</ul>
</li>
<li>String <a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">parsing</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1util_1_1Tokenizer.html">tokenizing</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1util_1_1WildcardMatcherBase.html">Wildcard matching</a> (using <code>'*'</code> and <code>'?'</code>) and <a class="el" href="classaworx_1_1lib_1_1strings_1_1util_1_1RegexMatcher.html">Regular expression matching</a>.</li>
<li>String <a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">parsing</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1util_1_1Tokenizer.html">tokenizing</a></li>
<li>Special substring search using <a class="el" href="classaworx_1_1lib_1_1strings_1_1util_1_1SubstringSearchBase.html">Knuth-Morris-Pratt</a> algorithm.</li>
<li>Simple <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1SimpleTextBase.html">text formatting</a>, e.g. for nicely indented and structured console or log-file output.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Some of the features are only available when module <b>ALib Strings</b> is used in combination with other <b>ALib</b> modules or the complete <b>ALib</b> distribution. Especially the formatters extensively use features of module <b>ALib Boxing</b>.</dd></dl>
<p><br />
 </p><dl class="section note"><dt>Note</dt><dd><b>ALib Strings</b> are available for <b>C#</b> (.Net) and <b>Java</b> as well. Of-course there are some differences, but the goal here is to provide a certain level of source-compatibility within <b>cross-language projects</b>. C# and Java versions of the library can be downloaded bundled with <a href="https://github.com/AlexWorx/ALox-Logging-Library">ALox Logging Library</a>.</dd></dl>
<p><a class="anchor" id="alib_strings_characters"></a></p><h1>2. Characters</h1>
<p>Strings are arrays of characters. Unfortunately (because it makes it all a little complex) before talking about strings, some theory and basics about characters have to be discussed.</p>
<p><a class="anchor" id="alib_strings_char_hell"></a></p><h2>2.1 The C++ Character Hell</h2>
<p>In the previous introduction sections, the situation with C++ and character strings has already been named a "hell". This is mainly due to two things: The invention and continued use of zero-terminated strings ("cstrings") and secondly the encoding of international character sets within strings of <b>different character width</b>. Isolating only the latter of the problems can be named "a hell" in itself already - in that respect that the consistent and rightful treatment of single characters can become very complex already. Furthermore testing software in different cultures (locales) may become a very expensive process.</p>
<p>This programmer's manual can not elaborate on this topic. To understand the rationals behind the design decisions and to make best effective use of module <b>ALib Strings</b>, it is important to know the basics and today's state of discussion. For this, some links are provided here:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/ASCII">ASCII, Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unicode">Unicode, Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>, <a href="https://en.wikipedia.org/wiki/UTF-32">UTF-32</a> (all Wikipedia)</li>
<li><a href="http://utf8everywhere.org/">UTF-8 Everywhere</a>, a "manifesto" on the use of UTF-8 written by people that have a strong opinion. Absolutely worth to read.</li>
<li><a href="http://site.icu-project.org/">ICU Library</a>. See the more general and introduction/tutorial parts of their documentation.</li>
</ul>
<p>The fact that choosing "the right" character width to efficiently implement C++ strings is a non-trivial task, is already shown by the following facts:</p><ol type="1">
<li>GNU C++ and Clang compilers define <code>wchar_t</code> as a <b>4-byte</b> integral type under GNU/Linux.</li>
<li>Microsoft Visual Studio C++ compiler for Windows defines <code>wchar_t</code> as a <b>2-byte</b> integral type.</li>
<li>Famous and wide-spread <a href="https://www.qt.io">QT Class Library</a> uses a <b>2-byte</b> integral type on both platforms, GNU/Linux and Windows OS.</li>
</ol>
<p><a class="anchor" id="alib_strings_char_by_width"></a></p><h2>2.2 ALib Character Types By Widths</h2>
<p>In general, <b>ALib</b> differs between two scenarios when it comes to choosing the underlying character width of a string:</p><ol type="1">
<li>Explicit choice, or</li>
<li>Logical choice (or no choice, which is using whatever is the default).</li>
</ol>
<p>The explicit choice of the character width is the less frequently approach and rather used internally in the library and when it comes to implementing explicit string functionality. For this, type definitions</p><ul>
<li><a class="el" href="namespaceaworx.html#a1c1d3a35b0a83dedccba1d22b1f7b656">aworx::nchar</a> and</li>
<li><a class="el" href="namespaceaworx.html#abbc5be3aede7f73fb15150870c2e16f9">aworx::wchar</a></li>
</ul>
<p>are provided.<br />
 While <b>nchar</b> is always an alias name for C++ type <code>char</code>, type <code>wchar</code> might resolve to either of built-in types <code>wchar_t</code>, <code>char16_t</code> or <code>char32_t</code>.</p>
<p><a class="anchor" id="alib_strings_char_by_logic"></a></p><h2>2.3 ALib Logical Character Types</h2>
<p>While the two explicit character types <a class="el" href="namespaceaworx.html#a1c1d3a35b0a83dedccba1d22b1f7b656">nchar</a> and <a class="el" href="namespaceaworx.html#abbc5be3aede7f73fb15150870c2e16f9">wchar</a> are aliasing two of the built-in types (<code>char</code>, <code>wchar_t</code>, <code>char16_t</code> or <code>char32_t</code>.), the&lt; themselves are aliased by two further type definitions:</p>
<ul>
<li><a class="el" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">aworx::character</a> and</li>
<li><a class="el" href="namespaceaworx.html#a916274aace0a6d2f4b11299698e2f7ed">aworx::complementChar</a>.</li>
</ul>
<p>Depending on the platform and/or compilation symbols provided when building the library, one of these types aliases <b>nchar</b> and the other <b>wchar</b>. This logical naming means that a <a class="el" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">character</a> is the default type for characters used with <b>ALib</b> and type <a class="el" href="namespaceaworx.html#a916274aace0a6d2f4b11299698e2f7ed">complementChar</a> is just the counterpart.</p>
<p>All together this results in a three-level type/alias scheme. For example, the default on GNU/Linux platform, is: </p><pre class="fragment">   aworx::character      &lt;==&gt; aworx::nchar &lt;==&gt; char
   aworx::complementChar &lt;==&gt; aworx::wchar &lt;==&gt; wchar_t
</pre><p>In contrast to this, under Windows OS the scheme is: </p><pre class="fragment">   aworx::character      &lt;==&gt; aworx::wchar &lt;==&gt; wchar_t
   aworx::complementChar &lt;==&gt; aworx::nchar &lt;==&gt; char
</pre><p>The attentive reader now notices that an <b><a class="el" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">aworx::character</a></b> under Windows OS is not equivalent to an <a class="el" href="namespaceaworx.html#a916274aace0a6d2f4b11299698e2f7ed">aworx::complementChar</a> GNU/Linux, although both are aliasing C++ type<code>wchar_t:</code> As explained above, this type is platform dependent, hence 2-bytes wide on Windows OS and 4-bytes wide on GNU Linux.<br />
 Therefore, <b>ALib</b> defines a third logical character type, which holds the third possible width:</p>
<ul>
<li><a class="el" href="namespaceaworx.html#a1081c8dd80089acd557dc4684ebaf66c">aworx::strangeChar</a></li>
</ul>
<p>So why did we choose this (strange) name? It should express that this third type is neither compatible with <b>ALib</b> narrow characters nor with <b>ALib</b> wide characters.</p>
<p>Looking back at the GNU/Linux sample (with default compilation options), we then have covered all three possible width: </p><pre class="fragment">   aworx::character      &lt;==&gt; aworx::nchar &lt;==&gt; char      // 1-byte character
   aworx::complementChar &lt;==&gt; aworx::wchar &lt;==&gt; wchar_t   // 4-byte character
   aworx::strangeChar            &lt;==&gt;           char16_t  // 2-byte character
</pre><dl class="section note"><dt>Note</dt><dd>From this perspective, if mixing <b>ALib</b> with strings of <a href="https://www.qt.io">QT Class Library</a>, these <code>QStrings</code> are based on character type <a class="el" href="namespaceaworx.html#a1081c8dd80089acd557dc4684ebaf66c">strangeChar</a> under GNU/Linux, while they are based on <a class="el" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">character</a> on Windows OS - because in any case <code>QString</code> objects have a character width of 2 bytes!</dd></dl>
<p>While it is obvious that the default character type alias <a class="el" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">aworx::character</a> is needed to write platform independent code, the use of alias types <code>complementChar</code> and <code>strangeChar</code> is not so obvious. Mostly again, it is needed internally, but is also very useful when it comes to template meta programming with the aim to create functionality that supports any type of string. We will see samples of this later in this programmer's manual.</p>
<dl class="section note"><dt>Note</dt><dd>When programming types or functions that are templated in respect to to the character type, helper struct <a class="el" href="structaworx_1_1T__ComplementChar.html">aworx::T_ComplementChar</a> may be used to identify the complementary character type in respect to the template type that is currently compiled. Its two specializations <b>T_ComplementChar&lt;nchar&gt;</b> and <b>T_ComplementChar&lt;wchar&gt;</b> each define inner type <b>type</b> to being the respectively complementary type.</dd></dl>
<p><a class="anchor" id="alib_strings_char_summary"></a></p><h2>2.4 Character Type Summary</h2>
<p>Let us quickly summarize what was said in this chapter about character types:</p><ul>
<li>Four C++ built-in types exist: <code>char</code>, <code>char16_t</code> or <code>char32_t</code>, <code>wchar_t</code>. While the first three have a defined size, the fourth, <code>wchar_t</code> is not defined in respect to its byte width (it may even be 1-byte wide!).</li>
<li><b>ALib</b> provides two alias types that define characters by their width:<ul>
<li><a class="el" href="namespaceaworx.html#a1c1d3a35b0a83dedccba1d22b1f7b656">aworx::nchar</a> for 1-byte narrow characters, and</li>
<li><a class="el" href="namespaceaworx.html#abbc5be3aede7f73fb15150870c2e16f9">aworx::wchar</a> for wide characters of either two or four bytes width.<br />
 (The width of <code>wchar</code> is not necessarily the same as the width of built-in type <code>wchar_t</code>.)</li>
</ul>
</li>
<li><b>ALib</b> provides three alias types that define characters in a logical sense:<ul>
<li><a class="el" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">aworx::character</a> for default character types. This either resolves to <code>nchar</code> or <code>wchar</code>.</li>
<li><a class="el" href="namespaceaworx.html#a916274aace0a6d2f4b11299698e2f7ed">aworx::complementChar</a> providing the complementary character to <b>character</b>.</li>
<li><a class="el" href="namespaceaworx.html#a1081c8dd80089acd557dc4684ebaf66c">aworx::strangeChar</a> providing the third possible character width which is neither <b>nchar</b> nor <b>wchar</b>.</li>
</ul>
</li>
</ul>
<p><a class="anchor" id="alib_strings_templated"></a></p><h1>3. Templated String Types</h1>
<p>Likewise the standard library uses template class <code>std::basic_string&lt;CharT&gt;</code>, <b>ALib</b> uses template classes for its various string classes and for most of the string helper and utility classes.</p>
<p>Before these classes are presented, it is important to understand the schematic of naming string types and placing shortcuts (alias types) of them in namespace <a class="el" href="namespaceaworx.html">aworx</a>.</p>
<p>The different string classes use a template parameter called p{TChar} and carry the suffix <code>"Base"</code> in their name. The central types are:</p>
<ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">aworx::lib::strings::StringBase&lt;TChar&gt;</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">aworx::lib::strings::SubstringBase&lt;TChar&gt;</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1TStringBase.html">aworx::lib::strings::TStringBase&lt;TChar&gt;</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">aworx::lib::strings::AStringBase&lt;TChar&gt;</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedStringBase.html">aworx::lib::strings::PreallocatedStringBase&lt;TChar&gt;</a></li>
</ul>
<p>Now, for each of the classes, <b>three alias types</b> are defined. For convenience, those are placed in namespace <b>aworx</b> (instead of namespace <b>aworx::lib::strings</b>). In respect to their base type's name, their name translates using the following scheme:</p><ul>
<li>The suffix <b>Base</b> is removed</li>
<li>With <span>TChar</span> being logical character type <b>character</b>, nothing is prefixed to the name.<br />
 Note that this version of the type is referred to as <b>"default string type"</b> at various places in this manual and the reference documentation.</li>
<li>With <span>TChar</span> being character type <b>nchar</b>, <code>'N'</code> is prefixed to the name.</li>
<li>With <span>TChar</span> being character type <b>wchar</b>, <code>'W'</code> is prefixed to the name.</li>
</ul>
<p>For example, for type <b><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a></b>, this translates to types:</p><ul>
<li><a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">aworx::String</a>, being <b>aworx::lib::strings::StringBase&lt;aworx::character&gt;</b></li>
<li><a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">aworx::NString</a>, being <b>aworx::lib::strings::StringBase&lt;aworx::nchar&gt;</b></li>
<li><a class="el" href="namespaceaworx.html#a4e2054049ab1c56bb65a50c2ccd046d5">aworx::WString</a>, being <b>aworx::lib::strings::StringBase&lt;aworx::wchar&gt;</b></li>
</ul>
<p>This schematic is important to understand. Mostly, only the simple form <b>"String"</b> is needed and this is equivalent to either <b>NString</b> or <b>WString</b>, depending on the whether <code>character</code> is equivalent to <code>nchar</code>, respectively <code>wchar</code>.<br />
 As a second sample for this naming scheme, type <code>NAString</code> is equivalent to class <b>AStringBase&lt;nchar&gt;</b>.</p>
<dl class="section note"><dt>Note</dt><dd>In a small exclamation, the name of template class <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">StringLiteralBase</a> is shortened with the definition of the three types, to<ul>
<li><a class="el" href="namespaceaworx.html#a8d2ec4d3e7bbefefdca67ceecd0b637c">aworx::SLiteral</a>,</li>
<li><a class="el" href="namespaceaworx.html#acdd37b479faa2819f3990aa87ba9e936">aworx::NSLiteral</a> and</li>
<li><a class="el" href="namespaceaworx.html#a58e5e6f6d8f43233006bf084792b9c9f">aworx::WSLiteral</a></li>
</ul>
</dd></dl>
<p>To avoid redundancy, in the next sections we finally can start to talk about the string classes, their use and functionality. Within these sections, it is only seldom mentioned that in fact templated underlying base classes are meant using different character types.</p>
<p><a class="anchor" id="alib_strings_classes"></a></p><h1>4. The String Classes</h1>
<dl class="section attention"><dt>Attention</dt><dd>In the upcoming chapters of this manual, when for example type <code>String</code> is mentioned, this in general means the template base type <b>StringBase&lt;TChar&gt;</b> and thus includes types <b>NString</b> or <b>WString</b>. The same applies to the other string types, which all follow the same naming scheme, as explained in the previous chapter.</dd></dl>
<p>The classes discussed in this chapter are:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">String</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1TStringBase.html">TString</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">AString</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedStringBase.html">PreallocatedString</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">StringLiteral</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">Substring</a></li>
</ul>
<p>The documentation of class <b>String</b> includes an <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">inheritance diagram</a> at the top of the page, which shows how the classes relate to each other. The next sub-chapters discuss each class in detail.</p>
<p><a class="anchor" id="alib_strings_classes_String"></a></p><h2>4.1 Class String</h2>
<p>The most basic class is <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">String</a>. It just contains the pointer to the first character and the length of the string. Class <b>String</b> does <em>not</em> allocate any data and with the exclamation of assigning something (completely) different, it does not allow to change the pointer to its buffer or its length. It could be said that an object of <b>String</b> is "immutable". But instead, a better way to look at it is that the class is just not really a string, but it rather is pointer to a string! While the interface does not allow to change the contents of the string, of-course the pointer may be changed easily.<br />
</p>
<p>The good thing about considering class <b>String</b> as being rather a pointer is that this implies that the class is very lightweight. Look at the following code: </p><pre class="fragment">   String s= "Hello";
   s= "World";
   s= s.Substring( 2, 3 ); // assignment of value type -&gt; overwrites the object
   s= nullptr;             // writes nullptr to buffer and 0 to length
</pre><p>This lightweight, pointer-like nature of the class makes clear that the class is not comparable to class <code>std::string</code> at all. Much more, it is comparable to <code>std::string_view</code>, which was introduced only with C++ version 17. Due to the minimum footprint, move construction and assignment is compiler defined and very fast. Even passing objects as value has a very limited performance impact (with move semantics even no impact).</p>
<p>Objects of type <b>String</b> are implicitly constructed or assigned to from other string types like</p><ul>
<li>C++ string literals</li>
<li><b>char*</b> / <b>wchar_t*</b> pointers</li>
<li><b>std::string</b> objects</li>
<li>custom, 3rd-party string types (Note: this is most important and explained below)</li>
</ul>
<p>The use cases of the class is obvious in two scenarios:</p>
<ol type="1">
<li><p class="startli">Using class String for String Constants:<br />
 Often, some constant string data is needed. By having this field of type <b>String</b>, just any string type can be assigned to it, especially string literals of-course. The advantage to type <code>const char*</code>, along with the pointer, the length of the string is stored. While with this, the buffer is not needed to be zero-terminated, a huge advantage is a good performance improvement, as for example no <code>std::strlen()</code> call has to be made if the length needs to be evaluated by the receiver of the string.</p>
<p class="startli">Same as with a use of <code>const char*</code> (or any other pointer type), it has to be made sure that the underlying string buffer is kept valid during the life-time of a string that points to it. This is not in the field of responsibility of the string object.</p>
</li>
<li><p class="startli">Using <code>const String&amp;</code> as type of method parameters:<br />
 All <b>ALib</b> interface methods that need some string input use a constant reference to <code>String</code> as parameter type (alternatively using derived type <code>TString</code>, discussed later). The code that uses such methods often does not need to care about parameter type conversion. References or pointers to any sort of "string-like objects" might be just passed "as is".</p>
<p class="startli">With C++ 11 move construction and assignment in place, and by not having a destructor, no virtual methods, etc., objects of type <code>String</code> are perfect candidates to be constructed implicitly for method parameter passing.<br />
 As a sample, see constructor of class <a class="el" href="classaworx_1_1lib_1_1system_1_1Directory.html#a3d2aef8216e51d8fea90c4f4b4f26959">Directory</a>. It is declared as: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a>( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">aworx::String</a>&amp; path );</div></div><!-- fragment --><p> With this declaration, it is possible to invoke that constructor passing using just any type of strings: </p><div class="fragment"><div class="line"><span class="comment">// Creating Directory object from C++ string literal</span></div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> bin( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;/usr/bin&quot;</span>) );</div><div class="line"></div><div class="line"><span class="comment">// Creating Directory object from std::string</span></div><div class="line">std::basic_string&lt;character&gt; libPath( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;/usr/lib&quot;</span>) );</div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> lib( libPath );</div><div class="line"></div><div class="line"><span class="comment">// Creating Directory object from std::string given as pointer</span></div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> lib2( &amp;libPath );</div><div class="line"></div><div class="line"><span class="comment">// Creating Directory object from ALib AString</span></div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">aworx::AString</a> srcPath( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;/usr/src&quot;</span>) );</div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> src( srcPath );</div><div class="line"></div><div class="line"><span class="comment">// Creating Directory object from ALib AString given as pointer</span></div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> src2( &amp;srcPath );</div></div><!-- fragment --></li>
</ol>
<p><a class="anchor" id="alib_strings_classes_String_custom"></a></p><h3>4.1.1 Binding User Types To ALib Strings:</h3>
<p>With a little one-time effort for specializing a simple template struct of two methods, also user defined string types (or types from other 3rd party libraries) can be made compatible easily. Due to the template meta programming, variations of these types, like pointers or references, const or non-const, etc. will be accepted with minimum (mostly no!) runtime impact.</p>
<p>For details and a source code sample on how to make <b>ALib</b> support user defined types, see <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">documentation of partially specialized template function T_String</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The value of this feature should not be under-estimated. For a software that uses <b>ALib</b> that means that the software is "allowed" to continue using the type of string class that it ever used. No <b>ALib</b> <b>Strings</b> objects start cluttering into the code. Instead, whenever <b>ALib</b> is invoked, an implicit, lightweight conversion is done.</dd></dl>
<p><a class="anchor" id="alib_strings_classes_String_nullable"></a></p><h3>4.1.2 Nullable Strings</h3>
<p>Another important note is the fact that class <b>String</b> are 'nullable'. This term means here, that when they got constructed with no value, with <em>nullptr</em>, with other <em>nulled</em> <b>ALib</b> strings, etc., this state is detectable and is different from representing an empty string of zero length. This is very important to create for lean and clean user code.</p>
<p>Derived mutable class <b>AString</b> (which is discussed below in more detail) inherits this ability See the sample exposed in <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#alib_namespace_strings_astring_nullable">Nullable AStrings</a> to get a better understanding of this concept.</p>
<p><a class="anchor" id="alib_strings_classes_String_term"></a></p><h3>4.1.3 No Zero-Termination</h3>
<p>Strings represented by this class may be zero terminated. E.g. when constructed from a string literal they definitely are (as C++ string literals are zero terminated an not writable). However, class <b>String</b> does not count on that and treats its content as not zero-terminated.</p>
<p>For further information about class <b>String</b>, consult <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">reference documentation of class String</a>.</p>
<p><a class="anchor" id="alib_strings_classes_TString"></a></p><h2>4.2 Class TString</h2>
<p>A first specialization of class <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">String</a> is class <a class="el" href="classaworx_1_1lib_1_1strings_1_1TStringBase.html">TString</a> which is representing strings that - other than the name might indicate - either</p><ul>
<li><b>are</b> terminated with a trailing '\0' character, or</li>
<li><b>can be</b> terminated by writing a trailing '\0' into the <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a> at position <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af940c51e198511031f839dec6e7f1b71">length</a>.</li>
</ul>
<p>This is important to understand. For example, a C++ string literal like <code>"Hello"</code> is zero terminated. If it was not, it could not be terminated explicitly because write access is not allowed. But still it meets the requirements to get represented by a objects of <b>TString!</b> </p>
<p>The important design decision made here is that the construction of objects this class is still implicit. This is sometimes a little dangerous, but runtime checks are provided in debug compilations to detect illegal construction with data that does not meet the criteria (either is not terminated or can't be terminated).</p>
<p>The interface of class <b>TString</b> extends the set of methods provided by parent class <b>String</b>, especially by method <a class="el" href="classaworx_1_1lib_1_1strings_1_1TStringBase.html#ac4b0a4bfa3586611cc6b9583705a017f">ToCString</a>. This method terminates the buffer (if not terminated, yet) and returns the pointer to it. Such zero-terminated strings are often needed with 3rd party library functions, including operating system calls.</p>
<p>For details, refer to the <a class="el" href="classaworx_1_1lib_1_1strings_1_1TStringBase.html">reference documentation of class TString</a>.</p>
<p><a class="anchor" id="alib_strings_classes_AString"></a></p><h2>4.3 Class AString</h2>
<p>Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">AString</a>, which specializes class <a class="el" href="classaworx_1_1lib_1_1strings_1_1TStringBase.html">TString</a>, disposes of an allocation mechanism to allow the creation and manipulation of character strings. Therefore, this is the central class to assemble strings at runtime. Whenever append operations exceed the existing buffer, the contents is copied to a new, bigger buffer and the old one is disposed.</p>
<p>Conceptually, it could be said that the difference to parent classes <b>String</b> and <b>TString</b> is that those <em>"represent"</em> character strings, while this class <em>"implements"</em> a string.</p>
<p><a class="anchor" id="alib_strings_classes_AString_constr"></a></p><h3>4.3.1 Construction</h3>
<p>Class <b>AString</b> hides all parent constructors and offers re-implementations that rather <b>copy</b> the data that is passed. Consequently - as this copying is not considered a lightweight operation - all constructors are explicit. If, for example, a function expects a constant <b>AString</b> reference, such <b>AString</b> has to be created explicitly before or inside the function invocation. On the same token, the assignment operator is not applicable with initializations as well.<br />
 The following code will not compile: </p><pre class="fragment"> AString as=  "This will not compile";</pre><p> Instead, explicit creation has to be made, as shown here: </p><pre class="fragment"> AString as("This will compile");

 // or alternatively
 AString as;
 as= "This will compile";</pre><p>With templated constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#a2bc85b3c2edbaa51e999b9d51d1bfb32">AString::AString(const TApplicable&amp;)</a>, class <b>AString</b> accepts any type of object that a conversion function exists for. This makes construction very flexible. In the terminology of <b>ALib</b>, the conversion of custom types into string representations is called <em>"to apply an object to an AString"</em>. What this precisely means, is explained below.</p>
<p>Copy constructor, move constructor and move assignment are well defined, which allows <b>AString</b> objects to be used (as efficiently as possible) as value types in containers of the standard library, for example as in <code>std::vector&lt;AString&gt;</code>.</p>
<p><a class="anchor" id="alib_strings_classes_AString_bufmngmnt"></a></p><h3>4.3.2 Buffer Management</h3>
<p>As mentioned before, class <b>AString</b> provides logic to manage its own buffer. Furthermore, it is also possible to have objects of class <b>AString</b> work on 'external' buffers. This means that the life-cycle of an <b>AString's</b> buffer not necessarily is bound to the life-cycle of the <b>AString</b> object itself. For details on using external buffers, see method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#a10072fb642233dd0ead937dfaad541cc">AString::SetBuffer</a>. Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedStringBase.html">PreallocatedString</a>, which is discussed below, makes use of this feature and provides the possibility to have local (stack based) allocations of strings.</p>
<p><a class="anchor" id="alib_strings_classes_AString_apply"></a></p><h3>4.3.3 Appending and Applying Objects</h3>
<p>Class <b>AString</b> uses some template meta programming method to be able to create a string representation from any object of arbitrary type. In <b>ALib</b> terminology, this is called "to apply
 an object to an AString". Such "application" can be performed by either calling method</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#ab6c3f64bbc79da9399975d250584f428">AString::Apply</a>,</li>
<li>alias method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#a138790ba8dc38da7d5199b607f763c7a">AString::_</a> (yes, the method name is simply <code>"_"</code>), or using</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#a2bd573962354f91967cb46df7bc2c2bf">AString::operator&lt;&lt;</a>,</li>
</ul>
<p>which are all exactly the same. Furthermore, an "applicable" object may also be passed to the constructor of an <b>AString</b>, which applies the object right during construction.</p>
<p>For many types, e.g. string types or integer and floating point types, the term '<em>applying</em>' is means nothing else than '<em>appending</em>' a string representation of the object to the current end of the string. However, as almost any type, including 'external', user defined types might be applied and such application is performed in a specialized template method, the operation associated with the <em>application</em> of an object of a certain type is not limited to appending data.</p>
<p>As an example, the concept of <em>'applying'</em> is used to add 'fields' to an <b>AString</b>. To achieve this, a special <em>'applicable'</em> type named <a class="el" href="structaworx_1_1lib_1_1strings_1_1FormatBase_1_1Field.html">Format::Field</a> is defined. Appending a field is done as follows: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a> centered;</div><div class="line">centered &lt;&lt; <span class="charliteral">&#39;*&#39;</span> &lt;&lt; Format::Field( <span class="stringliteral">&quot;Hello&quot;</span>, 15, Alignment::Center ) &lt;&lt; <span class="charliteral">&#39;*&#39;</span>;</div><div class="line">cout &lt;&lt; centered &lt;&lt; endl;</div></div><!-- fragment --><p> which produces the following output: </p><div class="fragment"><div class="line">*     Hello     *</div></div><!-- fragment --><p>For information on how to make a custom type an "applicable" type, see documentation of method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#ab6c3f64bbc79da9399975d250584f428">AString::Apply</a> and of partially specialized template struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a>.</p>
<p>The concept of having "applicable types" is a little comparable to the concept of having a common base class that exposes a virtual function called <b>ToString</b> as found in some programming languages. However, the concept introduced with <b>ALib</b> is more flexible and convenient. This is especially true because:</p><ul>
<li>Any type can be made applicable without extending the type's definition: No "ToString" or similar method has to be added to the type. Instead, all necessary code is defined outside of the type definition. Even 3rd-party library types can be defined to be "applicable" without having access to the library's source code.</li>
<li>Besides appending string representations, some completely different meanings can be given to what "apply" means for a certain custom type.</li>
</ul>
<p><a class="anchor" id="alib_strings_classes_PAString"></a></p><h2>4.4 Class PreallocatedString</h2>
<p>Template class <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedStringBase.html">PreallocatedString&lt;int TCapacity&gt;</a>, derived from class <b>AString</b> uses an internal member of type <em>char[TCapacity]</em> of a length specified by a template parameter, to store the string data. The huge benefit lies in performance: The impact of frequent <em>heap allocations</em> is often underestimated by software developers. Therefore, for local string operations with foreseeable maximum string buffer sizes, class <b>PreallocatedString</b> should be considered as a fast alternative of class <b>AString</b>.</p>
<p><a class="anchor" id="alib_strings_classes_PAString_bo"></a></p><h3>4.4.1 Exceeding the Buffer Capacity</h3>
<p>Although the internal buffer size is fixed at compile time and hence can not be expanded, a user of the class must not fear an assertion from '<em>buffer overflows</em>'. If the internal buffer capacity is exceeded, a regular allocated buffer from the <em>free memory</em> (aka '<em>heap'</em>) will be allocated. The slight disadvantage then is, that the memory of the internal buffer is (of-course) not freed and thus remains unused.</p>
<p>In debug compilations of <b>ALib</b>, parent class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">AString</a> provides a warning mechanism that enables the easy detection of such probably unwanted replacements of external buffers (in this case the buffer given by the character array member). Using macro <a class="el" href="assert_8hpp.html#a7577d63e934e68269adef8746c176901">ALIB_WARN_ONCE_PER_INSTANCE_DECL</a> an <em><a class="el" href="classaworx_1_1lib_1_1ALib.html">ALib</a> Warning</em> will be issued when a buffer is replaced. There are two scenarios how this mechanism might be used during development:</p><ul>
<li>If the buffer should never be replaced, the capacity of an PreallocatedString has to be increased step by step (during the software development/testing cycle) in the moment the warning is issued. This has to be done, until the member-buffer is huge enough and no more warning is raised..</li>
<li>If it is OK that the buffer is replaced "every once in a while" (because there special situations with higher capacity needs may occur, but are "relatively" seldom) then, the warning should be switched off for this specific object. By switching the warning off, a developer places the information in the code that the internal buffer size might be too small in some occasions. Having this explicit information, helps to understand the intentions of the software developer.</li>
</ul>
<p>If the latter case applies, then the one-time warning can be disabled using macro <a class="el" href="assert_8hpp.html#a30e363647f8ea56f0af8e834768548bc">ALIB_WARN_ONCE_PER_INSTANCE_DISABLE(myPreallocatedString, ReplaceExternalBuffer)</a></p>
<p>Note that the warning, the macro that disables it and all related efforts and code are effective only with debug compilations of module <b>ALib Strings</b>.</p>
<p><a class="anchor" id="alib_strings_classes_PAString_constr"></a></p><h3>4.4.2 Implicit construction</h3>
<p>While class <b>AString</b>, as <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_strings_classes_AString_constr">noted above</a>, does not provide implicit construction, this class re-implements the common constructors of <b>AString</b> and exposes them as <em>implicit</em>. The rationale here is that although the data is copied (which might not be a very lightweight task), still the performance impact is far less compared to constructing an <b>AString</b> that uses a heap-allocated buffer. So, the design decision is that it is taken into account that an <b>PreallocatedString</b> is created without explicit exposure of this creation.</p>
<p>The following method, as a sample, takes three different <b>ALib</b> string types as parameters: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TakeStrings( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">aworx::String</a>&amp; s1, <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">aworx::AString</a>&amp; s2, <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1PreallocatedStringBase.html">aworx::String64</a> s3 )</div></div><!-- fragment --><p> The following code will <em>not</em> compile: </p><div class="fragment"><div class="line">TakeStrings( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Str1&quot;</span>), <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Str2&quot;</span>), <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Str3&quot;</span>) );      <span class="comment">// Error, AString not implicitly constructable</span></div></div><!-- fragment --><p> Class AString has to be explicitly created, the others don't: </p><div class="fragment"><div class="line">TakeStrings( <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Str1&quot;</span>), <a class="code" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">aworx::AString</a>(<a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Str2&quot;</span>)), <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Str3&quot;</span>) ); <span class="comment">// OK, AString explicit, String and PreallocatedString implicit</span></div></div><!-- fragment --><p> In addition, besides having implicit construction, the default assign operator is defined as well. This allows to use objects of this type as class members that are initialized within the class declaration as shown here: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1PreallocatedStringBase.html">aworx::PreallocatedString&lt;20&gt;</a> name=  <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;(none)&quot;</span>);</div><div class="line">};</div></div><!-- fragment --><p> Such members are not allowed to be initialized in the declaration if their type is <b>AString</b>.</p>
<p><a class="anchor" id="alib_strings_classes_PAString_move"></a></p><h3>4.4.3 No Move Constructor</h3>
<p>Class <b>PreallocatedString</b> provides no <em>move constructor</em> and thus is very inefficient in scenarios where objects of the class could rather be moved than copied. Consequently such situations are to be avoided. The use of <b>PreallocatedString</b> should instead be very determined and it should not be subject to copy and move operations.</p>
<p><a class="anchor" id="alib_strings_classes_PAString_aliases"></a></p><h3>4.4.4 Aliases For Frequently Used Sizes</h3>
<p>Within namespace <a class="el" href="namespaceaworx.html">aworx</a>, some convenient alias type definitions are available that define preallocated strings of frequently uses sizes:</p><ul>
<li><a class="el" href="namespaceaworx.html#a09d5c6f95606d714f55858a2d514a377" title="Type alias name for PreallocatedStringBase&lt;character,16&gt;. ">String16</a>, <a class="el" href="namespaceaworx.html#a1c6b5fc580e7109ff14f552d20642255" title="Type alias name for PreallocatedStringBase&lt;character,32&gt;. ">String32</a> ... <a class="el" href="namespaceaworx.html#a9ced73ac68ff770c417574f8596297f3" title="Type alias name for PreallocatedStringBase&lt;character,1024&gt;. ">String1K</a>, <a class="el" href="namespaceaworx.html#aee36aeeb6e653d2bfdba9f0c331a7abd" title="Type alias name for PreallocatedStringBase&lt;character,2048&gt;. ">String2K</a>, <a class="el" href="namespaceaworx.html#ae93fc0d28c395c0c051dae822aca08da" title="Type alias name for PreallocatedStringBase&lt;character,4096&gt;. ">String4K</a>,</li>
<li><a class="el" href="namespaceaworx.html#a909bcddeed9106ff2941eb99ea2dbab7" title="Type alias name for PreallocatedStringBase&lt;nchar,16&gt;. ">NString16</a>, <a class="el" href="namespaceaworx.html#a6342913579bbbf52eebaab0f4cd54c0b" title="Type alias name for PreallocatedStringBase&lt;nchar,32&gt;. ">NString32</a> ... <a class="el" href="namespaceaworx.html#a380079aa9f77e82f9f1eb199a7754972" title="Type alias name for PreallocatedStringBase&lt;nchar,1024&gt;. ">NString1K</a>, <a class="el" href="namespaceaworx.html#ae05adb4f1cf91a4a7f7e139813fbc5a0" title="Type alias name for PreallocatedStringBase&lt;nchar,2048&gt;. ">NString2K</a>, <a class="el" href="namespaceaworx.html#ad74d1cfa73fecfec18cf4f89708482e9" title="Type alias name for PreallocatedStringBase&lt;nchar,4096&gt;. ">NString4K</a>, and</li>
<li><a class="el" href="namespaceaworx.html#ab024d9a88f97ad341f4a42096a52eeec" title="Type alias name for PreallocatedStringBase&lt;wchar,16&gt;. ">WString16</a>, <a class="el" href="namespaceaworx.html#aac08df89a1fb10f9b4aabe4d159c09e6" title="Type alias name for PreallocatedStringBase&lt;wchar,32&gt;. ">WString32</a> ... <a class="el" href="namespaceaworx.html#aa119fabcb26233a1fe68e431809b3871" title="Type alias name for PreallocatedStringBase&lt;wchar,1024&gt;. ">WString1K</a>, <a class="el" href="namespaceaworx.html#a26d233b9c6d223d2bb24be3d3690e48f" title="Type alias name for PreallocatedStringBase&lt;wchar,2048&gt;. ">WString2K</a>, <a class="el" href="namespaceaworx.html#a41a362e7a34bfa95131708c12cda1be4" title="Type alias name for PreallocatedStringBase&lt;wchar,4096&gt;. ">WString4K</a>.</li>
</ul>
<p><a class="anchor" id="alib_strings_classes_Substring"></a></p><h2>4.5 Class Substring</h2>
<p>Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">Substring</a> is derived directly from class <b>String</b>. Conceptually, the difference to its parent class is that it is not constant. It was discussed earlier, that objects of type <b>String</b>, once constructed, will never change the pointer to the buffer or its length. Objects of class <b>Substring</b> are entitled to do so. In general, the string they represent is a portion of another string and if they change, this change normally means shrinking the string to a substring of itself.</p>
<dl class="section note"><dt>Note</dt><dd>Speaking of changes, this must not be confused with changes of the contents of the string data. What is meant here are changes of the two fields <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a40158f724cad985410aecfa3ae24d69c">buffer</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#af940c51e198511031f839dec6e7f1b71">length</a></dd></dl>
<p>Class <b>Substring</b> does not extend parent class <b>String</b> with new field members. All methods of the class could therefore technically be implemented in <b>String</b> already. The reason why all methods that change the <b>buffer</b> and/or the <b>length</b> of the string have been aggregated in this derived type is, that these methods must not be inherited by class <b>AString</b>, which manages its own string buffer and must not loose information about the start of the allocated memory.</p>
<p><b>Objects</b> of type Substring are especially useful to perform simple parsing of string data. For this reason, a big portion of its interface methods are named "ConsumeXYZ". These methods read something from the substring, cut it off the string and return the result value that was "consumed".</p>
<p><a class="anchor" id="alib_strings_classes_StringLiteral"></a></p><h2>4.6 Class StringLiteral</h2>
<p>Template class <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">StringLiteral</a>, which is derived from class <b>TString</b>, represents strings whose length is fixed and known at compile time. Most objects of this type are constructed from C++ string literals, like in the following samples: </p><div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">aworx::SLiteral&lt;3&gt;</a>  litA    = <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>( <span class="stringliteral">&quot;123&quot;</span>   );</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">aworx::SLiteral&lt;5&gt;</a>  litB    = <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>( <span class="stringliteral">&quot;MAGIC&quot;</span> );</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">aworx::NSLiteral&lt;5&gt;</a> ansiRed = <span class="stringliteral">&quot;\033[31m&quot;</span>;</div></div><!-- fragment --><p> But it is also allowed to construct them from other character arrays, even writable ones, like here: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">character</a> cArray[4] { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>( <span class="stringliteral">&quot;123&quot;</span> ) };</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">aworx::SLiteral&lt;3&gt;</a> OneTwoThree= cArray;</div><div class="line"></div><div class="line">cArray[0]= <span class="charliteral">&#39;A&#39;</span>;</div><div class="line">cArray[1]= <span class="charliteral">&#39;B&#39;</span>;</div><div class="line">cArray[2]= <span class="charliteral">&#39;C&#39;</span>;</div><div class="line">cArray[3]= <span class="charliteral">&#39;D&#39;</span>; <span class="comment">// This must not be done, violates TString requirement</span></div></div><!-- fragment --><p> As the class specializes <a class="el" href="classaworx_1_1lib_1_1strings_1_1TStringBase.html">TString</a>, the user of the class has to make sure that the string represented by objects of this type is zero terminated.</p>
<p>Using class <b>StringLiteral</b> improves the performance of certain operations. For example appending (applying) objects of this type to objects of class <b>AString</b> will not result in a copy loop but will simply inline the correct number of copy operations into the object code (at least for the smaller sizes which are typically used).</p>
<p>Similar to TMP struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a> used to enable the construction of <b>String</b> object from string-like types, TMP struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__StringLiteral.html">T_StringLiteral</a> is used to construct objects of class <b>StringLiteral</b>. Consequently, it is possible to enable 'external', user defined types to seamlessly act as string literals as well.</p>
<p>This is a rather unlikely scenario, but if requested (solely for a potentially small performance gain), these types can get adopted to <b>ALib</b> by specializing <b>T_StringLiteral</b>. This process is not further documented or demonstrated by a sample. Interested users should consult the source code of <b>ALib</b> for doing it.<br />
 The only built-in specialization of the TMP struct provided with <b>ALib</b>, is for C++ string literals, respectively for character arrays of a known, fixed length.</p>
<p><a class="anchor" id="alib_strings_details"></a></p><h1>5. Details On Strings</h1>
<p><a class="anchor" id="alib_strings_details_nonchecking"></a></p><h2>5.1 "Non-Checking" Methods Of ALib String Classes</h2>
<p>Several of the methods found in the different string classes of <b>ALib</b> are templated with a boolean template parameter named <span>TCheck</span>. This template parameter is defaulted with the value <code>true</code> which is sort of 'hiding' it in normal code. Consider the following snippet: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> parse( <a class="code" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">aworx::Substring</a> line )</div><div class="line">{</div><div class="line">    constexpr <a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">aworx::SLiteral&lt;7&gt;</a> startWord= <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;&lt;start&gt;&quot;</span>);</div><div class="line">    <a class="code" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx= line.<a class="code" href="classaworx_1_1lib_1_1strings_1_1StringBase.html#a212bf8ac1fbd26ee2740a61335afbf46">IndexOf</a>( startWord );</div><div class="line">    <span class="keywordflow">if</span>( idx &gt; 0 )</div><div class="line">        line.<a class="code" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html#a7cf4d6791cd036f6547d5e53240281e0">ConsumeChars</a>( idx + startWord.Length() );</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div></div><!-- fragment --><p> The implementation of method <a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html#a7cf4d6791cd036f6547d5e53240281e0">Substring::ConsumeChars</a> by default checks if object <em>line</em> is big enough to cut the given number of characters from the front. Obviously this check is redundant here, because <b>ConsumeChars</b> is invoked only if <b>IndexOf</b> had found the string <em>"&lt;start&gt;"</em>. To avoid the redundant check, we invoke the non-checking version of method <b>ConsumeChars</b> by providing template parameter <span>TCheck</span> with value <code>false:</code> </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span>( idx &gt; 0 )</div><div class="line">        line.<a class="code" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html#a7cf4d6791cd036f6547d5e53240281e0">ConsumeChars</a>&lt;<span class="keyword">false</span>&gt;( idx + startWord.Length() ); <span class="comment">// No check for length of object &#39;line&#39;</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In this simple sample, especially as these methods are inlined, the compiler might detect already that the check is redundant and would remove it from the code. However, there are many occasions where the compiler is lacking the information and the possibility to detect such redundancy.</dd></dl>
<p>In the C# and Java versions of <b>ALib</b>, where such template methods are not available, still some non-checking methods are provided, but less than in the C++ implementation. In these languages, these methods exist twice with the same name, the non-checking one with suffix <em>_NC</em>.</p>
<p>The following general rules apply for all non-checking methods:</p><ul>
<li>String parameters are not checked for being nullptr.</li>
<li>Index, size, length, region start/end and other parameters are not checked to be correct</li>
<li>If parameters are incorrect, the result of the methods is undefined and an exception/assertion may be raised.</li>
<li>Append methods that in their original version would set a <em>nulled</em> <b>AString</b> to non <em>nulled</em> state in the case that an empty string or string region is appended, are not confirming to this principle in their non-checking version.<br />
 In other words, <em>nulled</em> strings keep being <em>nulled</em> if empty strings are appended.</li>
<li>In the Java and C# versions of <b>ALib</b>, the hash value of an <b>AString</b> object keeps being cached when invoking an <em>_NC</em> method. This may lead to wrong behavior, e.g. when an <b>AString</b> object is used as a key of a hash table. To avoid errors, within a context that makes use of an <b>AStrings'</b> hash value, before each hash code retrieval (C#: <em>GetHashCode()</em>, Java: <em>hashCode()</em>), it has to be certified that at least one of the methods manipulating the object has to be a non <em>_NC</em> method.</li>
</ul>
<p>Apart from the previous points, the behavior and result of invoking a non-checking version of a method is the same as of invoking the original version. The only difference is in a higher execution performance.</p>
<p>In debug compilations of module <b>ALib Strings</b>, the non-checking versions of the methods perform debug-assertions about the checks that are left out! This means, that it is very safe to use non-checking versions, as during development non-checking invocations in situations where checks are needed become detected by these assertions.</p>
<p><a class="anchor" id="alib_strings_details_format"></a></p><h2>5.2 Formatting Strings</h2>
<p>Module <b>ALib Strings</b> provides powerful formatting facilities for string data stored in <b>AString</b> objects through abstract class <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterBase.html">Formatter</a> and its specializations <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterPythonStyleBase.html">FormatterPythonStyle</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterJavaStyleBase.html">FormatterJavaStyle</a>.</p>
<p>Please consult the reference documentation of sub-namespace <a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1format.html">aworx::lib::strings::format</a> for details on string formatting features.</p>
<dl class="section note"><dt>Note</dt><dd>The formatting features are only available if the module is used together with module <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a>. The rational for this is that the formatting methods accept arbitrary typed objects using the C++ elipsis keyword <code>"..."</code>. Nevertheless, the goal was to have 100% type safeness when processing the objects passed. Such type safeness is the core feature of <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a>.</dd></dl>
<p><a class="anchor" id="alib_strings_details_compat"></a></p><h2>5.3 Compatibility with External Libraries</h2>
<p><b>ALib</b> provides compatibility extensions with different class libraries. Currently the following extensions are provided: </p><h3>Standard C++ Library</h3>
<ul>
<li>Trough header file <em>"alib/compatibility/std_string.hpp"</em><ul>
<li>Implements template struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a> to allow (implicit) conversion of objects of type <code>std::string</code> to type <b>aworx::NString</b> and <code>std::wstring</code> to type <b>aworx::WString</b> </li>
<li>If languages standard C++ 17 is in place, implements template struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a> to allow (implicit) conversion of objects of type <code>std::string_view</code> to type <b>aworx::NString</b> and <code>std::wstring_view</code> to type <b>aworx::WString</b> </li>
<li>Implements template struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a> to allow the concatenation of objects of type <em>std::string</em> to type <a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61" title="Type alias in namespace aworx. ">aworx::AString</a>.</li>
<li>Implements namespace function <a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1thirdparty_1_1std.html#a2e056957f914cbcc0f00fc89e348b35f">ToStdString</a> (with various overloads) to convert an object of type <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b" title="Type alias in namespace aworx. ">aworx::String</a> to type <em>std::string</em>.</li>
</ul>
</li>
</ul>
<ul>
<li>Trough header file <em>"alib/compatibility/std_iostream.hpp"</em><ul>
<li>Provides <em>applicable</em> class <a class="el" href="classaworx_1_1lib_1_1strings_1_1thirdparty_1_1std_1_1ISReadLineBase.html">ISReadLineBase</a> and corresponding specialization of <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a> to allow reading lines of text from a <em>std::istream</em> into an object of type <a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61" title="Type alias in namespace aworx. ">aworx::AString</a>.</li>
<li>Provides namespace functions <a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1thirdparty_1_1std.html#ade19e1704b60ecef0a0c7cab8573d7dd">aworx::lib::strings::thirdparty::std::operator&gt;&gt;</a>(std::istream&amp; " AString&amp;)" and <a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1thirdparty_1_1std.html#ade19e1704b60ecef0a0c7cab8573d7dd">aworx::lib::strings::thirdparty::std::operator&gt;&gt;</a>(std::istream* " AString&amp;)" which are using aforementioned applicable class <b>ISReadLine</b> with default parameters to read a line from a <em>std::istream</em> into an object of type <a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61" title="Type alias in namespace aworx. ">aworx::AString</a>.</li>
<li>Provides namespace functions <a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1thirdparty_1_1std.html#aaa41896631d03cf4fd316b775c46491e">aworx::lib::strings::thirdparty::std::operator&lt;&lt;</a>(std::ostream&amp; os " const String&amp; as)" and <a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1thirdparty_1_1std.html#aaa41896631d03cf4fd316b775c46491e">aworx::lib::strings::thirdparty::std::operator&lt;&lt;</a>(std::ostream* os " const String&amp; as)" to write an object of type <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b" title="Type alias in namespace aworx. ">aworx::String</a> into a <em>std::ostream</em>.</li>
</ul>
</li>
</ul>
<h3>QT Library</h3>
<ul>
<li><p class="startli">String classes of the <a href="https://www.qt.io">QT library</a> are supported trough header file <em>"alib/compatibility/qt.hpp"</em>.</p>
<p class="startli">General information about the use of QT strings with <b>ALox</b> is given in documentation of sub-namespace <a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1thirdparty_1_1qt.html">thirdparty::qt</a>.</p>
</li>
</ul>
<h3>Other Libraries</h3>
<dl class="section note"><dt>Note</dt><dd>Support for other Libraries to come... Feel free to send us your work!</dd></dl>
<p><a class="anchor" id="alib_strings_details_debug"></a></p><h2>5.4 Debugging ALib String Classes</h2>
<p>In some situations some additional debug checking is helpful when working with <b>ALib</b> strings. Among such situations are:</p><ul>
<li>development of types derived from <b>ALib</b> string types</li>
<li>specializing template structs <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a> or <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a> to add support for user defined string types or formatting operations to class <b>AString</b>.</li>
<li>external manipulation of <b>AString</b> string data</li>
<li>provision of external data buffers to class <b>AString</b> </li>
</ul>
<p>In these and similar situations, it is advised to using the compiler symbol <a class="el" href="group__GrpALibCompilerSymbols.html#ga2992625b88f70b1e01564be4e7eba2fb">ALIB_DEBUG_STRINGS_ON</a>. This enables internal consistency checks with almost any method <b>ALib</b> string invoked. By default this is disabled, as it generates a quite huge drop of runtime performance. When string debugging is enabled, macro ALIB_STRING_DBG_CHK can be used to check the consistency of <b>ALib</b> string classes. Furthermore, macro <a class="el" href="group__GrpALibStringsMacros.html#ga40c5a8cdae19517b0b56e4e69b6aedbb">ALIB_STRING_DBG_UNTERMINATE</a> <em>has to</em> be used when changing the length of a terminatable string without using method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#a4101d7715aa5920c9271cd6c10b216f9">AString::SetLength&lt;false&gt;</a> (e.g. in custom, derived classes).</p>
<p>With compilation symbol <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> set to true, the string buffer allocated by class <b>AString</b> is extended by 32 bytes, 16 bytes at the front and 16 bytes at the end. Therefore, code that:</p><ol type="1">
<li>uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html#a5473577f9d5c557fb50aa183a359037e">AString::SetBuffer</a> to set an external buffer, and</li>
<li>transfers responsibility to <b>ALib</b> by setting parameter <span>responsibility</span> of that method accordingly, and where</li>
<li>this external buffer gets replaced later when the string's size increases,</li>
</ol>
<p>then the buffer passed has to to be allocated accordingly. This means, the buffer has to be 32 bytes larger than specified and the starting address of the heap allocation has to be 16 bytes before what parameter <span>extBuffer</span> points to.<br />
</p>
<h1>Reference Documentation</h1>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Nested namespaces</h2></td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1strings_1_1applyto"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1applyto.html">applyto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1strings_1_1boxing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1boxing.html">boxing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1strings_1_1format"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1format.html">format</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1strings_1_1thirdparty"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1thirdparty.html">thirdparty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1strings_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1util.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AStringBase.html">AStringBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1CString.html">CString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1FormatBase.html">FormatBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormatBase.html">NumberFormatBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedStringBase.html">PreallocatedStringBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1ResourceString.html">ResourceString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">StringBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteralBase.html">StringLiteralBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1Strings.html">Strings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1SubstringBase.html">SubstringBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply_3_01typename_01format_1_1PropertyFormatterMapApplicabl9456c94e4b77bb618eb1895e4b057977.html">T_Apply&lt; typename format::PropertyFormatterMapApplicable&lt; TFormattable, TOptionEnum &gt;, character &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__IsTerminatable.html">T_IsTerminatable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__IsTerminatable_3_01AStringBase_3_01TChar_01_4_01_4.html">T_IsTerminatable&lt; AStringBase&lt; TChar &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__IsTerminatable_3_01PreallocatedStringBase_3_01TChar_00_01TCapacity_01_4_01_4.html">T_IsTerminatable&lt; PreallocatedStringBase&lt; TChar, TCapacity &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__StringLiteral.html">T_StringLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__StringLiteral_3_01StringLiteralBase_3_01TChar_00_01TLength_01_4_00_01TChar_01_4.html">T_StringLiteral&lt; StringLiteralBase&lt; TChar, TLength &gt;, TChar &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TStringBase.html">TStringBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a37fcd751b87e5c4aaeb804637bb716fa"><td class="memItemLeft" align="right" valign="top"><a id="a37fcd751b87e5c4aaeb804637bb716fa"></a>
static constexpr <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a37fcd751b87e5c4aaeb804637bb716fa">MaxLen</a> = (std::numeric_limits&lt;<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&gt;::max)()</td></tr>
<tr class="memdesc:a37fcd751b87e5c4aaeb804637bb716fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of an <b>ALib</b> string. <br /></td></tr>
<tr class="separator:a37fcd751b87e5c4aaeb804637bb716fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 12 2018 15:57:47 for ALib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
