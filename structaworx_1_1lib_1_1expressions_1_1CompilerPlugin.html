<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALib: CompilerPlugin Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALib
   &#160;<span id="projectnumber">V. 1805 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html">expressions</a></li><li class="navelem"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Inner Classes</a> &#124;
<a href="#pub-attribs">Public Fields</a> &#124;
<a href="#pub-methods">Public Methods</a> &#124;
<a href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CompilerPlugin Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="compilerplugin_8hpp_source.html">compilerplugin.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CompilerPlugin:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin__inherit__graph.svg" width="390" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CompilerPlugin:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin__coll__graph.svg" width="1930" height="660"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
<p> This interface class represents "plug-ins" which are attachable to container class <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a>. The compiler uses the plug-ins to <em>"compile"</em> single nodes of <em>abstract syntax trees</em>, which are the intermediate, internal result of parsing expression strings.</p>
<p>In depth information on how this class is used is given in the <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html">User Manual And Tutorial</a> of module <b>ALib Expressions</b>.</p>
<p>The overloaded methods <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#af04a6f83b4d51fa8217ce2760791b18b">TryCompilation</a> are not abstract, but have a default implementation that return constant <code>false</code>. A plug-in derived from this class needs to override only those methods that represent syntax elements of an expression, that it volunteers to take responsibility for.</p>
<p>The overloaded methods have one input/output parameter which is of one of the following types:</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html">CIFunction</a>,</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a>,</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a> or</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html">CIBinaryAutoCast</a>.</li>
</ul>
<p>These inner types of this struct are derived from likewise inner struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CompilationInfo.html">CompilationInfo</a>, which provides all output members and those input members that are common between the four descendants. In other words, the variants of the struct provide detail information on the node that is actually compiled.</p>
<p>When overriding one of the overloaded methods <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#af04a6f83b4d51fa8217ce2760791b18b">TryCompilation</a>, it has to be checked if the custom plug-in is responsible for the permutation of given parameter types which are passed. If so, the actual 'compilation' is performed, by filling the result members of the given struct and by returning <code>true</code>. Each overloaded method provides a suitable return type, which are defined as inner types of this class.</p>
<p>The output information comprises a <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">sample box</a> that determines the result type of the native C++ function that is later invoked when the expression is evaluated against a scope. Together with this type information, the pointer to the callback function itself needs to be set in the given struct.</p>
<p>Alternatively, if a constant result is to be returned, the pointer to the callback function might be kept <em>nulled</em>. In this case, the <b>Box</b> object that represents the result type of the callback function is used to provide the constant value, instead of just a sample value.</p>
<p>There are two possibilities, why a compiler plug-in might return a constant value, instead of a function:</p><ol type="1">
<li><em>Identifiers</em> (parameterless functions) might just represent constant values. (For example identifiers <code>"True"</code> or <code>"Monday"</code> do that, while <code>"Today"</code> returns a callback function.).</li>
<li>The compiler provides information about whether the given parameters are constant values. In this case, a compiler plug-in may decide to evaluate the result of the function at compile time. This is often, but not always possible and depends largely on the fact if scope information is used with the function as well. <br />
 For more details on this topic see manual section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_details_optimizations">11.5 Optimizations</a>.</li>
</ol>
<dl class="section attention"><dt>Attention</dt><dd>If constant data is returned, it has to be assured, that the contents of the returned <b>Box</b> remains valid during the lifecycle of the expression. This is assured for all <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_ftypes">boxed C++ fundamental types</a>. For custom types it depends on where the constant value is received from and how boxing is performed. (By default, custom types are boxed as pointers to the assigned object.)<br />
 Field <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CompilationInfo.html#a6696af828b4392429a520f56c258c553">CompilationInfo::CompileTimeScope</a> is to be used for compile-time allocations.</dd></dl>
<p>The plug-ins are attached to the <b>Compiler</b> using a dedicated prioritization defined with (arithmetical) enum type <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#add6d77f919179e44f6147a0ef9352e59">CompilePriorities</a>. This means, that if a higher prioritized plug-in already compiles a certain permutation of expression node type and argument types, then a lower prioritized plug-in is not even asked to do so. With this concept, <b><a class="el" href="classaworx_1_1lib_1_1ALib.html">ALib</a> <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expressions.html">Expressions</a></b> provides a lot of flexibility: the built-in operators and identifiers can be unplugged completely or just sparsely "superseded" in certain aspects by adding a custom <b>CompilerPlugin</b> with a higher priority than that of the built-in one.</p>
<dl class="section note"><dt>Note</dt><dd>Instead of deriving from this struct, it is recommended to consider convenience struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">plugins::Calculus</a> instead.</dd>
<dd>
More information on this topic is given in manual section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_cpcc_calculus">5.4 Class Calculus</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Inner Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html">CIBinaryAutoCast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html">CIFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CompilationInfo.html">CompilationInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Fields</h2></td></tr>
<tr class="memitem:a4169832ab4df5578238257e7163e9943"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">NString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a4169832ab4df5578238257e7163e9943">Name</a></td></tr>
<tr class="separator:a4169832ab4df5578238257e7163e9943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11443ececcac579ee94c5cdc262227ea"><td class="memItemLeft" align="right" valign="top"><a id="a11443ececcac579ee94c5cdc262227ea"></a>
<a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a11443ececcac579ee94c5cdc262227ea">Parent</a></td></tr>
<tr class="memdesc:a11443ececcac579ee94c5cdc262227ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compiler that this plug-in is attached to. <br /></td></tr>
<tr class="separator:a11443ececcac579ee94c5cdc262227ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr class="memitem:aee988a894af3931decd97144ebbc7237"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#aee988a894af3931decd97144ebbc7237">CompilerPlugin</a> (const <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">NString</a> &amp;name, <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> &amp;compiler)</td></tr>
<tr class="separator:aee988a894af3931decd97144ebbc7237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60955a1bebb6f7af951b06dcc42c320"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#af60955a1bebb6f7af951b06dcc42c320">~CompilerPlugin</a> ()</td></tr>
<tr class="separator:af60955a1bebb6f7af951b06dcc42c320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04a6f83b4d51fa8217ce2760791b18b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#af04a6f83b4d51fa8217ce2760791b18b">TryCompilation</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html">CIFunction</a> &amp;ciFunction)</td></tr>
<tr class="separator:af04a6f83b4d51fa8217ce2760791b18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59450a0da6fc0ab65b05b90b898ae22"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#ae59450a0da6fc0ab65b05b90b898ae22">TryCompilation</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a> &amp;ciUnaryOp)</td></tr>
<tr class="separator:ae59450a0da6fc0ab65b05b90b898ae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9d4673228b1e2c4c89c6467c490262"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a2a9d4673228b1e2c4c89c6467c490262">TryCompilation</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a> &amp;ciBinaryOp)</td></tr>
<tr class="separator:a2a9d4673228b1e2c4c89c6467c490262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87336db1fa6d0310add5cd5c21190783"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a87336db1fa6d0310add5cd5c21190783">TryCompilation</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html">CIBinaryAutoCast</a> &amp;ciBinaryAutoCast)</td></tr>
<tr class="separator:a87336db1fa6d0310add5cd5c21190783"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee988a894af3931decd97144ebbc7237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee988a894af3931decd97144ebbc7237">&#9670;&nbsp;</a></span>CompilerPlugin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">NString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> &amp;&#160;</td>
          <td class="paramname"><em>compiler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Assigned to field <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a4169832ab4df5578238257e7163e9943">Name</a>. </td></tr>
    <tr><td class="paramname">compiler</td><td>The compiler we will get attached to. Gets stored in field <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a11443ececcac579ee94c5cdc262227ea" title="The compiler that this plug-in is attached to. ">Parent</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60955a1bebb6f7af951b06dcc42c320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60955a1bebb6f7af951b06dcc42c320">&#9670;&nbsp;</a></span>~CompilerPlugin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Virtual destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af04a6f83b4d51fa8217ce2760791b18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04a6f83b4d51fa8217ce2760791b18b">&#9670;&nbsp;</a></span>TryCompilation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TryCompilation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html">CIFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>ciFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Used to compile identifiers (parameterless functions ) and functions parsed from expression strings.</p>
<p>The function name is given as an in/out parameter. Implementations might (should) choose to</p><ul>
<li>on the one hand allow abbreviations and letter case insensitive identifier recognitions, and</li>
<li>consequently return 'corrected' identifier names if an identifier name matched and the element got compiled.</li>
</ul>
<p>Such corrected names will appear in the normalized expression strings returned by <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a9e5bd8d42c1eba7541d4cc615c366844">Expression::GetNormalizedString</a>, in case flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a7c2bd4bd8f395c98c342e0e7912cb9a5">Normalization::ReplaceFunctionNames</a> is set in field <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ac2b0822b970754be8993e1a8071aea96">Compiler::CfgNormalization</a>.</p>
<p>On success, this method has to provide a (native C++) callback function that accepts start and end iterators of boxed arguments which are of the same time as proposed by the corresponding iterators found in parameter <span>ciFunction</span>, along with the return type of that function.</p>
<p>Alternatively, if a constant identifier is compiled or if all parameters are known to be constant at compile time, a constant value might be returned. For details of the input and output parameters of the function, see struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html">CIFunction</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ciFunction</td><td>The compilation info struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementations have to return <code>true</code> if the given info struct was filled, or in other words, if the plug-in chose to compile the <em>AST</em>-node.<br />
 This default implementation returns <code>false</code> to indicate that no compilation was done. </dd></dl>

<p>Reimplemented in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a098fc2b68c8d9a17aeaa2dd8dff31e75">Calculus</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html#a0baab3c8d1b98a03b3fe8250e1f3826d">Strings</a>, and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html#a0baab3c8d1b98a03b3fe8250e1f3826d">Arithmetics</a>.</p>

</div>
</div>
<a id="ae59450a0da6fc0ab65b05b90b898ae22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59450a0da6fc0ab65b05b90b898ae22">&#9670;&nbsp;</a></span>TryCompilation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TryCompilation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a> &amp;&#160;</td>
          <td class="paramname"><em>ciUnaryOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Used to compile unary operators parsed from expressions.</p>
<p>On success, this method has to provide a native C++ callback function together with a <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">sample box</a> that specifies its return type. Both are to be stored in output parameter <span>result</span>.</p>
<p>Alternatively, if field <code>ArgIsConst</code> of the given compilation info struct is <code>true</code>, a constant value might be returned. For details of the input and output parameters of the function, see struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a>.</p>
<p>The implementation might allow alias operators. If such alias is found, the used original operator should be returned in/out parameter <span>operation</span>.</p>
<p>Such "corrected" operators will appear in the normalized expression strings returned by <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a9e5bd8d42c1eba7541d4cc615c366844">Expression::GetNormalizedString</a>, in case flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a7cb98ff4ba877f4c1b9318b25fde4bf8">Normalization::ReplaceAliasOperators</a> is set in field <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ac2b0822b970754be8993e1a8071aea96">Compiler::CfgNormalization</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ciUnaryOp</td><td>The compilation info struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementations have to return <code>true</code> if the given info struct was filled, or in other words, if the plug-in chose to compile the <em>AST</em>-node.<br />
 This default implementation returns <code>false</code> to indicate that no compilation was done. </dd></dl>

<p>Reimplemented in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ace3350452fbcb2317e43b2e2406c36f6">Calculus</a>.</p>

</div>
</div>
<a id="a2a9d4673228b1e2c4c89c6467c490262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9d4673228b1e2c4c89c6467c490262">&#9670;&nbsp;</a></span>TryCompilation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TryCompilation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a> &amp;&#160;</td>
          <td class="paramname"><em>ciBinaryOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Used to compile binary operators parsed from expressions.</p>
<p>On success, this method has to provide a native C++ callback function together with a <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">sample box</a> that specifies its return type. Both are to be stored in output parameter <span>result</span>.</p>
<p>Alternatively, depending on fields <code>LhsIsConst</code> and <code>RhsIsConst</code> of the given compilation info struct, a constant value might be returned or, as a third alternative, field <code>NonConstArgIsResult</code> may be set to <code>true</code>, if an "identity" operation is detected For details of the input and output parameters of the function, see struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a>.</p>
<p>The implementation might allow alias operators. If such alias is found, the used original operator should be returned in/out parameter <span>operation</span>.</p>
<p>Such "corrected" operators will appear in the normalized expression strings returned by <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Expression.html#a9e5bd8d42c1eba7541d4cc615c366844">Expression::GetNormalizedString</a>, in case flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a5ff21ac37397b09f1e9ab0b4bfcd99a3a7cb98ff4ba877f4c1b9318b25fde4bf8">Normalization::ReplaceAliasOperators</a> is set in field <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ac2b0822b970754be8993e1a8071aea96">Compiler::CfgNormalization</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ciBinaryOp</td><td>The compilation info struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementations have to return <code>true</code> if the given info struct was filled, or in other words, if the plug-in chose to compile the <em>AST</em>-node.<br />
 This default implementation returns <code>false</code> to indicate that no compilation was done. </dd></dl>

<p>Reimplemented in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a84c99402490968c29e27e6bcffc4ee40">Calculus</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html#ac8c09be3ae1f55352b07969020595015">Strings</a>, and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1ElvisOperator.html#ac8c09be3ae1f55352b07969020595015">ElvisOperator</a>.</p>

</div>
</div>
<a id="a87336db1fa6d0310add5cd5c21190783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87336db1fa6d0310add5cd5c21190783">&#9670;&nbsp;</a></span>TryCompilation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TryCompilation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html">CIBinaryAutoCast</a> &amp;&#160;</td>
          <td class="paramname"><em>ciBinaryAutoCast</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Used to provide information to the compiler for casting types.</p>
<p>For details on how this method is overridden, consult the documentation of the input/output parameter type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html">CIBinaryAutoCast</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ciBinaryAutoCast</td><td>The compilation info struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementations have to return <code>true</code> if the given info struct was filled, or in other words, if the plug-in chose to provide auto-cast information as requested.<br />
 This default implementation returns <code>false</code> to indicate that no compilation was done. </dd></dl>

<p>Reimplemented in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a7de6da5b8e856b151433f4782a465373">Calculus</a>, and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1AutoCast.html#aa5a9f5ab0c87cfda9a557f2dd743f770">AutoCast</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4169832ab4df5578238257e7163e9943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4169832ab4df5578238257e7163e9943">&#9670;&nbsp;</a></span>Name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">NString</a> Name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The name of the plug-in. This is used with exception information and <a class="el" href="classaworx_1_1lib_1_1expressions_1_1detail_1_1VirtualMachine.html#a8ea31517f6995455a2e5a3cc4e698cb8">program listings</a> which are available in debug-compilations of the library. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="compilerplugin_8hpp_source.html">compilerplugin.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 12 2018 15:57:47 for ALib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
