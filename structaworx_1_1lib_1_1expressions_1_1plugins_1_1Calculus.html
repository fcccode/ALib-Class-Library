<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALib: Calculus Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALib
   &#160;<span id="projectnumber">V. 1805 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html">expressions</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1expressions_1_1plugins.html">plugins</a></li><li class="navelem"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#nested-classes">Inner Classes</a> &#124;
<a href="#pub-static-attribs">Public Static Fields</a> &#124;
<a href="#pub-attribs">Public Fields</a> &#124;
<a href="#pub-methods">Public Methods</a> &#124;
<a href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Calculus Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="calculus_8hpp_source.html">calculus.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Calculus:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus__inherit__graph.svg" width="390" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Calculus:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus__coll__graph.svg" width="2566" height="710"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
 <h2>1. Introduction</h2>
<p>This struct specializes <b>CompilerPlugin</b> and provides generic approaches and implementation of variants of method <b>TryCompilation</b>. Consequently, this is the base type of most built-in compiler plug-ins, and is strongly recommended to consider this struct as the preferred base when implementing custom plug-ins.</p>
<p>The class implements virtual, overloaded methods</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#af04a6f83b4d51fa8217ce2760791b18b">TryCompilation(CIFunction&amp;)</a>,</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#ae59450a0da6fc0ab65b05b90b898ae22">TryCompilation(CIUnaryOp&amp;)</a> and</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a2a9d4673228b1e2c4c89c6467c490262">TryCompilation(CIBinaryOp&amp;)</a>.</li>
</ul>
<p>For each <em>AST</em> node type to compile, this class holds a vector or a hash map to store all information needed for compilation.</p>
<p>The simple schema of using this class is:</p><ol type="1">
<li>Derive a custom type from this class.</li>
<li>Create constant value objects and C++ native callback functions.</li>
<li>Create constant (<code>constexpr</code>) tables with all compilation information.</li>
<li>In the constructor of the derived class, feed the tables into to this struct, using the corresponding helper methods.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Sample code and detailed explanations are given with user manual section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_cpcc_calculus">5.4 Class Calculus</a> and tutorial section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_tut_ffext">6. Extending The File Filter Sample</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The name "Calculus" seems a little overstated, we admit.</dd></dl>
<h2>2. Choose Anonymous Namespaces</h2>
<p>A good design pattern is to put the callback functions, constant values and compilation information tables into an anonymous namespace at the start of the compilation unit (.cc or .cpp file) of your custom plug-in. This way, the linker is not bothered with the function and object names, which solely are referenced by their address and never need to get linked to other units.</p>
<p>Just after this anonymous namespace, the implementation of the constructor of the custom plug-in, should be placed. As explained above, its duty is to fills in the vector/hash map using the right combination of operator or function argument types, as well as providing a proper <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">sample box</a> that corresponds to the type of the output parameter of the native function.</p>
<p>When implementing a custom plug-in, it may be helpful to have a look at the source code of the built-in plug-ins provided with module <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html">ALib Expressions</a>. You will see that these implementations are quite straight forward and use some 'handy' local preprocessor macros that may be copied and used for custom implementations.</p>
<h2>3. Specifics For Identifiers and Functions</h2>
<p>While parent class <b>CompilerPlugin</b> does not make any direct distinction between functions that are always returning a constant value and those that don't, this class does. Arguably such functions are always parameterless, hence identifiers. Samples for such constants are <b>"PI"</b> or <b>"True"</b>.<br />
 Such constant identifiers are supported by populating table <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a12b81e575790db8c949079e707fe1244" title="List of identifiers that return constant values to be compiled by this plug-in. ">ConstantIdentifiers</a> which is a <code>std::vector</code> of elements of type <b>ConstantIdentifiersEntry</b>. For details on each "table column", refer to the documentation of the fields of <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus_1_1ConstantIdentifierEntry.html">ConstantIdentifierEntry</a>.</p>
<p>Non-constant identifiers and functions are supported by populating table <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a7058d524e02a12c3c4a4a40e60415136" title="List of functions to be compiled by this plug-in. ">Functions</a>, which is a <code>std::vector</code> of elements of type <b>FunctionEntry</b>. For details on each "table column", refer to the documentation of the fields of <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus_1_1FunctionEntry.html">FunctionEntry</a>.</p>
<p>Some notes:</p><ul>
<li>It can be specified if function names are case sensitive and whether they might be abbreviated.</li>
<li>The list of arguments (their types) accepted by a function is to be provided as a <code>std::vector</code> of <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_prereq_sb">sample boxes</a>. It is recommended to define such vectors once per unique function "signature" in the anonymous namespace section of the compilation unit and fill its contents once in the constructor of the custom plug-in. Such vectors can then be reused for each function that shares the same signature.</li>
<li>Variadic functions are supported by adding a final <em>nulled</em> <b>Box</b> to the argument list. All sample argument types before this box are mandatory, but an arbitrary amount of arguments of likewise arbitrary type may be followed. It is also allowed to add just that one nulled <b>Box</b> to the signature vector, which leads to functions that accept just any number of any type of argument, including zero arguments.</li>
<li>In debug compilations, besides the callback function pointer, the C++ name of the callback function is to be provided. For this, macro <a class="el" href="group__GrpALibMacros.html#ga66bc22b995956d786f1dacfb496f0fbd">CALCULUS_CALLBACK</a> is defined. The macro creates a stringified version of the given function pointer, separated by a comma.</li>
<li>Flag <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus_1_1FunctionEntry.html#a6bdb2157e6bb046c17b9d8ef7dd5969a">FunctionEntry::IsCTInvokable</a> is a boolean value that denotes whether a function can be evaluated at compile time in the case that all of the parameters given in the expression are constant. If so, this struct will do the invocation at compile time and return the constant result value instead of the function call.<br />
 Most built-in functions are compile time invokable. For example most mathematical functions like <code>log(Float)</code> or <code>sin(Float)</code> can be evaluated at compile time (again, only in the case that the given parameters are constant). The reason is, that these functions are independent from custom scope data. In contrast to this, custom functions, especially even parameterless identifiers usually are dependent on scope information and thus often can not be evaluated at compile time.</li>
</ul>
<h2>4. Specifics For Unary Operators</h2>
<p>The compilation of <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a420a3f6ea0cec87492bd0dd5781dfd4d">unary operators</a> is supported by populating nested hash map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a>. Because feeding a nested hash-map is a rather complicated process that can not easily be done using static table data, several helpers are provided:</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ab984cd5eb3d1267ad057e701af4dcc56">AddUnaryOp</a><br />
 This function adds compilation information for a single unary operator to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a>.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a50a3b92edb8db6f058f7a13c1a066b1c">UnaryOpTableEntry</a><br />
 This is a type definition that allows to define tables with compilation information on unary operators. It is recommended to create such tables as <code>constexpr</code> data in an anonymous namespace of the compilation unit.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9b441eb6aa16bee58b41189071139a3a">AddUnaryOps</a><br />
 This is a pair of overloaded functions. One of them is templated and just used to deduce the length of the given table of static data. This table is then fed as a pointer, together with the table size to the second method, which in turn feeds the table entries into <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a>.</li>
</ul>
<p>In other words: Method <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ab984cd5eb3d1267ad057e701af4dcc56">AddUnaryOp</a> feeds one single operator to the nested hash-map, while <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9b441eb6aa16bee58b41189071139a3a">AddUnaryOps</a> feeds static "bulk" data to it. For details of the functions and types, consult the corresponding documentation.</p>
<p>As documented in user manual section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_aliases">9.4 Type-Specific Operator Aliases</a>, module <b>ALib Expressions</b> supports the use of alias operators. For unary operators, this is reflected by this class with:</p>
<ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a><br />
 A nested hash map that collects information about unary operator aliases.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ad8ccbbf281a8ef90c59a549f27bd8e05">AddUnaryOpAlias</a><br />
 This function adds information about an unary operator alias to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a>.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa8ba776f87c79538751cd5b6c5ecd7da">UnaryOpAliasTableEntry</a> A type definition that allows to define tables with information about unary operator aliases. It is recommended to create such tables as <code>constexpr</code> data in an anonymous namespace of the compilation unit.</li>
<li>AddUnaryOpAliases<br />
 This is a pair of overloaded functions. One of them is templated and just used to deduce the length of the given table of static data. This table is then fed as a pointer, together with the table size to the second method, which in turn feeds the table entries into <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a>.</li>
</ul>
<h2>5. Specifics For Binary Operators</h2>
<p>The compilation of binary operators is supported by populating nested hash map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a>. Because feeding a nested hash-map is a rather complicated process that can not easily be done using static table data, several helper methods are provided:</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3ce433cab3d7592142af35c892c162b1">AddBinaryOp</a><br />
 This function adds compilation information for a single binary operator to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a>.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">BinaryOpTableEntry</a><br />
 This is a type definition that allows to define tables with compilation information on binary operators. It is recommended to create such tables as <code>constexpr</code> data in an anonymous namespace of the compilation unit.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#acb762d501655b7cc2b74fc9b0d051b37">AddBinaryOps</a><br />
 This is a pair of overloaded functions. One of them is templated and just used to deduce the length of the given table of static data. This table is then fed as a pointer, together with the table size to the second method, which in turn feeds the table entries into <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a>.</li>
</ul>
<p>In other words: Method <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3ce433cab3d7592142af35c892c162b1">AddBinaryOp</a> feeds one single operator to the nested hash-map, while <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#acb762d501655b7cc2b74fc9b0d051b37">AddBinaryOps</a> feeds static "bulk" data to it. For details of the functions and types, consult the corresponding documentation.</p>
<p>As documented in user manual section <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#alib_expressions_operators_aliases">9.4 Type-Specific Operator Aliases</a>, module <b>ALib Expressions</b> supports the use of alias operators. For binary operators, this is reflected by this class with:</p>
<ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a><br />
 A nested hash map that collects information about binary operator aliases.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a49b4c0d3872b1d18018f5b3b508bf625">AddBinaryOpAlias</a><br />
 This function adds information about a binary operator alias to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a>.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a44b86c388937af5110a76620421b345c">BinaryOpAliasTableEntry</a><br />
 A type definition that allows to define tables with information about binary operator aliases. It is recommended to create such tables as <code>constexpr</code> data in an anonymous namespace of the compilation unit.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a672ba0d4902b6d18b08b3fbab8ba3f9e">AddBinaryOpAliases</a><br />
 This is a pair of overloaded functions. One of them is templated and just used to deduce the length of the given table of static data. This table is then fed as a pointer, together with the table size to the second method, which in turn feeds the table entries into <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>It is <em>not</em> necessary to define an alias operator <code>'='</code> for operator <code>'=='</code>, when using this class, because this alias replacement is internally always made by this class, if compilation flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6abe80c37b4a47cbebdb18e6e070cc7804">Compilation::AliasEqualsOperatorWithAssignOperator</a> is set in field <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html#ab80df79edf00c08ed5f7b74b48f5f0f6">Compiler::CfgCompilation</a>.</dd>
<dd>
In contrast to this, compilation flag <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a54935d405a62c0faf5bea2a1bde5f5e6a88c96a668631a41aeda561bb21a0a8f3">Compilation::AllowBitwiseBooleanOperations</a> affects only built-in type <em>boolean</em> - just as the flag's name suggests. The flag is tested only in derived plug-in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html">plugins::Arithmetics</a>. In other words: to allow for example operator <code>'&amp;'</code> to be used as an alias for operator <code>'&amp;&amp;'</code> defined on custom types, this has to be explicitly added as an alias definition.</dd></dl>
<p>Finally, for binary operators, this type provides a mechanism to provide information on compile-time optimizations. The following fields and methods are provided:</p>
<ul>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa245c95cee592e1090a088984941e4b6">BinaryOpConstLHSOptimizations</a><br />
 A nested hash-map that collects information about possible optimizations of binary operations when the left-hand side operator is a specific constant value.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3107055a490e640f0580570a4ef82767">BinaryOpConstRHSOptimizations</a><br />
 A nested hash-map that collects information about possible optimizations of binary operations when the right-hand side operator is a specific constant value.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a281fefd51a6dbcc32be53ea22e708375">BinaryOpOptimizationsTableEntry</a><br />
 A type definition that allows to define tables with information about binary operator optimizations.. It is recommended to create such tables as <code>constexpr</code> data in an anonymous namespace of the compilation unit.</li>
<li><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a589611c4b9f2efa9b323425b650eaf2f">AddBinaryOpOptimizations</a><br />
 A pair of overloaded functions. One of them is templated and just used to deduce the length of the given table of static data. This table is then fed as a pointer, together with the table size to the second method, which in turn feeds the table entries into either <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa245c95cee592e1090a088984941e4b6">BinaryOpConstLHSOptimizations</a> or <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3107055a490e640f0580570a4ef82767">BinaryOpConstRHSOptimizations</a>.</li>
</ul>
<p>Samples of binary operator optimizations are given in documentation of struct <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CompilerPlugin::CIBinaryOp</a>, which is filled with the optimization information given by the use of above listed helpers.</p>
<h1>Reference Documentation</h1>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a44b86c388937af5110a76620421b345c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a44b86c388937af5110a76620421b345c">BinaryOpAliasTableEntry</a> = const std::tuple&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &gt;</td></tr>
<tr class="separator:a44b86c388937af5110a76620421b345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281fefd51a6dbcc32be53ea22e708375"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a281fefd51a6dbcc32be53ea22e708375">BinaryOpOptimizationsTableEntry</a> = const std::tuple&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> &amp;, const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> &amp; &gt;</td></tr>
<tr class="separator:a281fefd51a6dbcc32be53ea22e708375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf27e1bce1168bcdbd913d38678c69d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">BinaryOpTableEntry</a> = const std::tuple&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>, const char *, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> &gt;</td></tr>
<tr class="separator:a0cf27e1bce1168bcdbd913d38678c69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55b508702600cd59382f1623a5ca53c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> = bool</td></tr>
<tr class="separator:af55b508702600cd59382f1623a5ca53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ba776f87c79538751cd5b6c5ecd7da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa8ba776f87c79538751cd5b6c5ecd7da">UnaryOpAliasTableEntry</a> = const std::tuple&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &gt;</td></tr>
<tr class="separator:aa8ba776f87c79538751cd5b6c5ecd7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a3b92edb8db6f058f7a13c1a066b1c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a50a3b92edb8db6f058f7a13c1a066b1c">UnaryOpTableEntry</a> = const std::tuple&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>, const char *, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> &gt;</td></tr>
<tr class="separator:a50a3b92edb8db6f058f7a13c1a066b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Inner Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus_1_1ConstantIdentifierEntry.html">ConstantIdentifierEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus_1_1FunctionEntry.html">FunctionEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public Static Fields</h2></td></tr>
<tr class="memitem:aca7d895c9d90f88412d70322cc52a758"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">CTI</a> = true</td></tr>
<tr class="separator:aca7d895c9d90f88412d70322cc52a758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd3f41961ca66ba27a5c43747458b67"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9dd3f41961ca66ba27a5c43747458b67">ETI</a> = false</td></tr>
<tr class="separator:a9dd3f41961ca66ba27a5c43747458b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Fields</h2></td></tr>
<tr class="memitem:abc20034d3657fc4928136b507744c179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt; <a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt; <a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a></td></tr>
<tr class="separator:abc20034d3657fc4928136b507744c179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245c95cee592e1090a088984941e4b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt; <a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt; <a class="el" href="namespaceaworx.html#a934e14062eb77d29860412391c841690">UnorderedBoxMap</a>&lt; <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa245c95cee592e1090a088984941e4b6">BinaryOpConstLHSOptimizations</a></td></tr>
<tr class="separator:aa245c95cee592e1090a088984941e4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3107055a490e640f0580570a4ef82767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt; <a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt; <a class="el" href="namespaceaworx.html#a934e14062eb77d29860412391c841690">UnorderedBoxMap</a>&lt; <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3107055a490e640f0580570a4ef82767">BinaryOpConstRHSOptimizations</a></td></tr>
<tr class="separator:a3107055a490e640f0580570a4ef82767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033a0344c10e80fa7f3176bbb00251e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt; <a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt; <a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt; std::tuple&lt; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>, <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a>, const char *&gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a></td></tr>
<tr class="separator:a033a0344c10e80fa7f3176bbb00251e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b81e575790db8c949079e707fe1244"><td class="memItemLeft" align="right" valign="top"><a id="a12b81e575790db8c949079e707fe1244"></a>
std::vector&lt; <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus_1_1ConstantIdentifierEntry.html">ConstantIdentifierEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a12b81e575790db8c949079e707fe1244">ConstantIdentifiers</a></td></tr>
<tr class="memdesc:a12b81e575790db8c949079e707fe1244"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of identifiers that return constant values to be compiled by this plug-in. <br /></td></tr>
<tr class="separator:a12b81e575790db8c949079e707fe1244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7058d524e02a12c3c4a4a40e60415136"><td class="memItemLeft" align="right" valign="top"><a id="a7058d524e02a12c3c4a4a40e60415136"></a>
std::vector&lt; <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus_1_1FunctionEntry.html">FunctionEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a7058d524e02a12c3c4a4a40e60415136">Functions</a></td></tr>
<tr class="memdesc:a7058d524e02a12c3c4a4a40e60415136"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of functions to be compiled by this plug-in. <br /></td></tr>
<tr class="separator:a7058d524e02a12c3c4a4a40e60415136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71e0f4571d9018e32ffe4d5b9333a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt; <a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a></td></tr>
<tr class="separator:aa71e0f4571d9018e32ffe4d5b9333a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3888e8792f7083550cce0c47ad1a949a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt; <a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt; std::tuple&lt; <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>, <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a>, const char *&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a></td></tr>
<tr class="separator:a3888e8792f7083550cce0c47ad1a949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin')"><img src="closed.png" alt="-"/>&#160;Public Fields inherited from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a></td></tr>
<tr class="memitem:a4169832ab4df5578238257e7163e9943 inherit pub_attribs_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">NString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a4169832ab4df5578238257e7163e9943">Name</a></td></tr>
<tr class="separator:a4169832ab4df5578238257e7163e9943 inherit pub_attribs_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11443ececcac579ee94c5cdc262227ea inherit pub_attribs_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="memItemLeft" align="right" valign="top"><a id="a11443ececcac579ee94c5cdc262227ea"></a>
<a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a11443ececcac579ee94c5cdc262227ea">Parent</a></td></tr>
<tr class="memdesc:a11443ececcac579ee94c5cdc262227ea inherit pub_attribs_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compiler that this plug-in is attached to. <br /></td></tr>
<tr class="separator:a11443ececcac579ee94c5cdc262227ea inherit pub_attribs_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr class="memitem:aa1ab7fdcb88e1b43365a25693da5611e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa1ab7fdcb88e1b43365a25693da5611e">Calculus</a> (const <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">NString</a> &amp;name, <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> &amp;compiler)</td></tr>
<tr class="separator:aa1ab7fdcb88e1b43365a25693da5611e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5f01bb24685c9871753bc270ac476a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aed5f01bb24685c9871753bc270ac476a">~Calculus</a> () override</td></tr>
<tr class="separator:aed5f01bb24685c9871753bc270ac476a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce433cab3d7592142af35c892c162b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3ce433cab3d7592142af35c892c162b1">AddBinaryOp</a> (const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;op, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> lhsType, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> rhsType, CallbackTypes::Binary callback, const char *dbgCallbackName, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> resultType, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> cti)</td></tr>
<tr class="separator:a3ce433cab3d7592142af35c892c162b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b4c0d3872b1d18018f5b3b508bf625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a49b4c0d3872b1d18018f5b3b508bf625">AddBinaryOpAlias</a> (const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;alias, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> lhsType, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> rhsType, const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;op)</td></tr>
<tr class="separator:a49b4c0d3872b1d18018f5b3b508bf625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672ba0d4902b6d18b08b3fbab8ba3f9e"><td class="memTemplParams" colspan="2">template&lt;size_t TCapacity&gt; </td></tr>
<tr class="memitem:a672ba0d4902b6d18b08b3fbab8ba3f9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a672ba0d4902b6d18b08b3fbab8ba3f9e">AddBinaryOpAliases</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a44b86c388937af5110a76620421b345c">BinaryOpAliasTableEntry</a>(&amp;table) [TCapacity])</td></tr>
<tr class="separator:a672ba0d4902b6d18b08b3fbab8ba3f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afd89c74d8c574894c9eddf2356ff8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a5afd89c74d8c574894c9eddf2356ff8e">AddBinaryOpAliases</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a44b86c388937af5110a76620421b345c">BinaryOpAliasTableEntry</a> *table, size_t length)</td></tr>
<tr class="separator:a5afd89c74d8c574894c9eddf2356ff8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589611c4b9f2efa9b323425b650eaf2f"><td class="memTemplParams" colspan="2">template&lt;size_t TCapacity&gt; </td></tr>
<tr class="memitem:a589611c4b9f2efa9b323425b650eaf2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a589611c4b9f2efa9b323425b650eaf2f">AddBinaryOpOptimizations</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a281fefd51a6dbcc32be53ea22e708375">BinaryOpOptimizationsTableEntry</a>(&amp;table) [TCapacity], bool lhsOrRhs)</td></tr>
<tr class="separator:a589611c4b9f2efa9b323425b650eaf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5199aaeff72d584296a5211530b8eefc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a5199aaeff72d584296a5211530b8eefc">AddBinaryOpOptimizations</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a281fefd51a6dbcc32be53ea22e708375">BinaryOpOptimizationsTableEntry</a> *table, size_t length, bool lhsOrRhs)</td></tr>
<tr class="separator:a5199aaeff72d584296a5211530b8eefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb762d501655b7cc2b74fc9b0d051b37"><td class="memTemplParams" colspan="2">template&lt;size_t TCapacity&gt; </td></tr>
<tr class="memitem:acb762d501655b7cc2b74fc9b0d051b37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#acb762d501655b7cc2b74fc9b0d051b37">AddBinaryOps</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">BinaryOpTableEntry</a>(&amp;table) [TCapacity])</td></tr>
<tr class="separator:acb762d501655b7cc2b74fc9b0d051b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962376ee94cff37a8e5ae810b89d1788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a962376ee94cff37a8e5ae810b89d1788">AddBinaryOps</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">BinaryOpTableEntry</a> *table, size_t length)</td></tr>
<tr class="separator:a962376ee94cff37a8e5ae810b89d1788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984cd5eb3d1267ad057e701af4dcc56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ab984cd5eb3d1267ad057e701af4dcc56">AddUnaryOp</a> (const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;op, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> argType, CallbackTypes::Unary callback, const char *dbgCallbackName, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> resultType, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> cti)</td></tr>
<tr class="separator:ab984cd5eb3d1267ad057e701af4dcc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ccbbf281a8ef90c59a549f27bd8e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ad8ccbbf281a8ef90c59a549f27bd8e05">AddUnaryOpAlias</a> (const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;alias, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a> argType, const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;op)</td></tr>
<tr class="separator:ad8ccbbf281a8ef90c59a549f27bd8e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae193651ef315f1cf1143e54ecb18b890"><td class="memTemplParams" colspan="2">template&lt;size_t TCapacity&gt; </td></tr>
<tr class="memitem:ae193651ef315f1cf1143e54ecb18b890"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ae193651ef315f1cf1143e54ecb18b890">AddUnaryOpAliases</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa8ba776f87c79538751cd5b6c5ecd7da">UnaryOpAliasTableEntry</a>(&amp;table) [TCapacity])</td></tr>
<tr class="separator:ae193651ef315f1cf1143e54ecb18b890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa233330f8d2c43320a63215dfededfd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa233330f8d2c43320a63215dfededfd0">AddUnaryOpAliases</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa8ba776f87c79538751cd5b6c5ecd7da">UnaryOpAliasTableEntry</a> *table, size_t length)</td></tr>
<tr class="separator:aa233330f8d2c43320a63215dfededfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b441eb6aa16bee58b41189071139a3a"><td class="memTemplParams" colspan="2">template&lt;size_t TCapacity&gt; </td></tr>
<tr class="memitem:a9b441eb6aa16bee58b41189071139a3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9b441eb6aa16bee58b41189071139a3a">AddUnaryOps</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a50a3b92edb8db6f058f7a13c1a066b1c">UnaryOpTableEntry</a>(&amp;table) [TCapacity])</td></tr>
<tr class="separator:a9b441eb6aa16bee58b41189071139a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a927739182e13b232cc4a3a71d52a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a02a927739182e13b232cc4a3a71d52a8">AddUnaryOps</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a50a3b92edb8db6f058f7a13c1a066b1c">UnaryOpTableEntry</a> *table, size_t length)</td></tr>
<tr class="separator:a02a927739182e13b232cc4a3a71d52a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098fc2b68c8d9a17aeaa2dd8dff31e75"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a098fc2b68c8d9a17aeaa2dd8dff31e75">TryCompilation</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html">CIFunction</a> &amp;ciFunction) override</td></tr>
<tr class="separator:a098fc2b68c8d9a17aeaa2dd8dff31e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3350452fbcb2317e43b2e2406c36f6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ace3350452fbcb2317e43b2e2406c36f6">TryCompilation</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a> &amp;ciUnaryOp) override</td></tr>
<tr class="separator:ace3350452fbcb2317e43b2e2406c36f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c99402490968c29e27e6bcffc4ee40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a84c99402490968c29e27e6bcffc4ee40">TryCompilation</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a> &amp;ciBinaryOp) override</td></tr>
<tr class="separator:a84c99402490968c29e27e6bcffc4ee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6da5b8e856b151433f4782a465373"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a7de6da5b8e856b151433f4782a465373">TryCompilation</a> (<a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html">CIBinaryAutoCast</a> &amp;) override</td></tr>
<tr class="separator:a7de6da5b8e856b151433f4782a465373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin')"><img src="closed.png" alt="-"/>&#160;Public Methods inherited from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html">CompilerPlugin</a></td></tr>
<tr class="memitem:aee988a894af3931decd97144ebbc7237 inherit pub_methods_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#aee988a894af3931decd97144ebbc7237">CompilerPlugin</a> (const <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">NString</a> &amp;name, <a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> &amp;compiler)</td></tr>
<tr class="separator:aee988a894af3931decd97144ebbc7237 inherit pub_methods_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60955a1bebb6f7af951b06dcc42c320 inherit pub_methods_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#af60955a1bebb6f7af951b06dcc42c320">~CompilerPlugin</a> ()</td></tr>
<tr class="separator:af60955a1bebb6f7af951b06dcc42c320 inherit pub_methods_structaworx_1_1lib_1_1expressions_1_1CompilerPlugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a44b86c388937af5110a76620421b345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b86c388937af5110a76620421b345c">&#9670;&nbsp;</a></span>BinaryOpAliasTableEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a44b86c388937af5110a76620421b345c">BinaryOpAliasTableEntry</a> =  const std::tuple&lt;<a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Entry of arrays used with methods T <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a672ba0d4902b6d18b08b3fbab8ba3f9e">AddBinaryOpAliases</a> to perform bulk-loading of operator alias definition data into <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a>. The tuple elements are:</p><ul>
<li>The alias operator.</li>
<li>The left-hand side type of the binary operation.</li>
<li>The right-hand side type of the binary operation.</li>
<li>The operator that gets aliased. </li>
</ul>

</div>
</div>
<a id="a281fefd51a6dbcc32be53ea22e708375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281fefd51a6dbcc32be53ea22e708375">&#9670;&nbsp;</a></span>BinaryOpOptimizationsTableEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a281fefd51a6dbcc32be53ea22e708375">BinaryOpOptimizationsTableEntry</a> =  const std::tuple&lt;<a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>,<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp;, const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Entry of arrays used with methods <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a589611c4b9f2efa9b323425b650eaf2f">AddBinaryOpOptimizations</a> to perform bulk-loading of optimization data for maps <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa245c95cee592e1090a088984941e4b6">BinaryOpConstLHSOptimizations</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3107055a490e640f0580570a4ef82767">BinaryOpConstRHSOptimizations</a>. The tuple elements are:</p><ul>
<li>The alias operator.</li>
<li>The type of the non-constant argument.</li>
<li>The type and value of the constant argument.</li>
<li>Either, a constant result value that replaces the binary operation (as in <code> x || true</code>) or a nulled box, which indicates that the result equals the non-constant argument (as in <code>x &amp;&amp; true</code>). </li>
</ul>

</div>
</div>
<a id="a0cf27e1bce1168bcdbd913d38678c69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf27e1bce1168bcdbd913d38678c69d">&#9670;&nbsp;</a></span>BinaryOpTableEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">BinaryOpTableEntry</a> =  const std::tuple&lt;<a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>, const char*, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Entry of arrays used with methods <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#acb762d501655b7cc2b74fc9b0d051b37">AddBinaryOps</a> to perform bulk-loading of compile definition data into <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a>. The tuple elements are:</p><ul>
<li>The operator to compile.</li>
<li>The left-hand side type of the binary operation.</li>
<li>The right-hand side type of the binary operation.</li>
<li>The callback function. Set to <code>nullptr</code> if operator evaluates constant.</li>
<li>The C++ name of the callback function. (This tuple element is only available in debug compilations of the library.)</li>
<li>The result type sample box, respectively, if <b>callback</b> is <code>nullptr</code>, the constant result value.</li>
<li>Flag to denote if the callback function allows compile-time invocation and thus on constant input the program can be optimized. This is true e.g. for arithmetic functions, but usually not for custom operators that rely on scope objects available only at evaluation time. </li>
</ul>

</div>
</div>
<a id="af55b508702600cd59382f1623a5ca53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55b508702600cd59382f1623a5ca53c">&#9670;&nbsp;</a></span>CTInvokable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> =  bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boolean to denote if a callback function allows compile-time invocation. If <code>true</code>, on constant function input (either from expression string literals or sub-expressions that have been optimized to constant input) the program can be optimized by invoking the <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a> already at compile-time.</p>
<p>This flag is set for most built-in functions, e.g. arithmetic calculations, but usually can not be set custom callbacks, as those usually rely on custom scope objects which are available only at evaluation-time.</p>
<dl class="section note"><dt>Note</dt><dd>This type is used with helper class <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">plugins::Calculus</a> but exposed as a namespace type for convenience, together with constants <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aca7d895c9d90f88412d70322cc52a758">CTI</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9dd3f41961ca66ba27a5c43747458b67">ETI</a> </dd></dl>

</div>
</div>
<a id="aa8ba776f87c79538751cd5b6c5ecd7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ba776f87c79538751cd5b6c5ecd7da">&#9670;&nbsp;</a></span>UnaryOpAliasTableEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa8ba776f87c79538751cd5b6c5ecd7da">UnaryOpAliasTableEntry</a> =  const std::tuple&lt;<a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Entry of arrays used with methods <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ae193651ef315f1cf1143e54ecb18b890">AddUnaryOpAliases</a> to perform bulk-loading of operator alias definition data into <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a>. The tuple elements are:</p><ul>
<li>The alias operator.</li>
<li>The argument type of the unary operation.</li>
<li>The operator that gets aliased. </li>
</ul>

</div>
</div>
<a id="a50a3b92edb8db6f058f7a13c1a066b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a3b92edb8db6f058f7a13c1a066b1c">&#9670;&nbsp;</a></span>UnaryOpTableEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a50a3b92edb8db6f058f7a13c1a066b1c">UnaryOpTableEntry</a> =  const std::tuple&lt;<a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>, const char*, <a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Entry of arrays used with methods <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9b441eb6aa16bee58b41189071139a3a">AddUnaryOps</a> to perform bulk-loading of compile definition data into <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a>. The tuple elements are:<br />
</p><ul>
<li>The operator to compile.</li>
<li>The argument type of the unary operation.</li>
<li>The callback function. Set to <code>nullptr</code> if operator evaluates always constant.</li>
<li>The C++ name of the callback function. (This tuple element is only available in debug compilations of the library.)</li>
<li>The result type sample box, respectively, if <b>callback</b> is <code>nullptr</code>, the constant result value.</li>
<li>Flag to denote if the callback function allows compile-time invocation and thus on constant input the program can be optimized. This is true e.g. for arithmetic functions, but usually not for custom operators that rely on scope objects available only at evaluation time. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa1ab7fdcb88e1b43365a25693da5611e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ab7fdcb88e1b43365a25693da5611e">&#9670;&nbsp;</a></span>Calculus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7af8a9e3564064047a575c7ff5462de9">NString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1expressions_1_1Compiler.html">Compiler</a> &amp;&#160;</td>
          <td class="paramname"><em>compiler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Assigned to field <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a4169832ab4df5578238257e7163e9943">CompilerPlugin::Name</a>. </td></tr>
    <tr><td class="paramname">compiler</td><td>The compiler we will get attached to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed5f01bb24685c9871753bc270ac476a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5f01bb24685c9871753bc270ac476a">&#9670;&nbsp;</a></span>~Calculus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html">Calculus</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ce433cab3d7592142af35c892c162b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce433cab3d7592142af35c892c162b1">&#9670;&nbsp;</a></span>AddBinaryOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddBinaryOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>&#160;</td>
          <td class="paramname"><em>lhsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>&#160;</td>
          <td class="paramname"><em>rhsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackTypes::Binary&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dbgCallbackName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a>&#160;</td>
          <td class="paramname"><em>cti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Adds a binary operator's callback function and return type to the compilation map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a>. </p><dl class="section see"><dt>See also</dt><dd>Consider using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#acb762d501655b7cc2b74fc9b0d051b37">AddBinaryOps</a>, a variant of this method that allows effective bulk loading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operator. </td></tr>
    <tr><td class="paramname">lhsType</td><td>The left-hand side argument type that the operator is defined for. </td></tr>
    <tr><td class="paramname">rhsType</td><td>The right-hand side argument type that the operator is defined for. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function to execute. </td></tr>
    <tr><td class="paramname">dbgCallbackName</td><td>The name of the C++ name of the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This parameter is available only in debug version of the library. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cti</td><td>See <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> for the meaning of this flag. </td></tr>
    <tr><td class="paramname">resultType</td><td>The result type of the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49b4c0d3872b1d18018f5b3b508bf625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b4c0d3872b1d18018f5b3b508bf625">&#9670;&nbsp;</a></span>AddBinaryOpAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddBinaryOpAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>&#160;</td>
          <td class="paramname"><em>lhsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>&#160;</td>
          <td class="paramname"><em>rhsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Adds an alias operator to nested hash table <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a>. </p><dl class="section see"><dt>See also</dt><dd>Consider using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a672ba0d4902b6d18b08b3fbab8ba3f9e">AddBinaryOpAliases</a>, a variant of this method that allows effective bulk loading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias for operator <span>op</span>. </td></tr>
    <tr><td class="paramname">lhsType</td><td>The left-hand side argument type that the operator is defined for. </td></tr>
    <tr><td class="paramname">rhsType</td><td>The right-hand side argument type that the operator is defined for. </td></tr>
    <tr><td class="paramname">op</td><td>The operator aliased by <span>alias</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a672ba0d4902b6d18b08b3fbab8ba3f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672ba0d4902b6d18b08b3fbab8ba3f9e">&#9670;&nbsp;</a></span>AddBinaryOpAliases() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddBinaryOpAliases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a44b86c388937af5110a76620421b345c">BinaryOpAliasTableEntry</a>(&amp;)&#160;</td>
          <td class="paramname"><em>table</em>[TCapacity]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Templated helper method. Deduces the array size of the given table and passes it to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a5afd89c74d8c574894c9eddf2356ff8e">AddBinaryOpAliases(BinaryOpAliasTableEntry* table, size_t length)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCapacity</td><td>Implicitly deferred size of the array provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5afd89c74d8c574894c9eddf2356ff8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afd89c74d8c574894c9eddf2356ff8e">&#9670;&nbsp;</a></span>AddBinaryOpAliases() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddBinaryOpAliases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a44b86c388937af5110a76620421b345c">BinaryOpAliasTableEntry</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Loads all entries of the given table into nested map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a>.</p>
<p>Note, that usually, the given table is a constexpr array located in an anonymous namespace of a compilation unit.<br />
 It can be passed as a reference to templated helper method, which defers the length of the table implicitly.</p>
<dl class="section note"><dt>Note</dt><dd>It is slightly more performant and causes less memory fragmentation, if the given table is sorted by the operator column (first) and as a second order by the <span>lhsType</span> column (second).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
    <tr><td class="paramname">length</td><td>The table containing operator compilation information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a589611c4b9f2efa9b323425b650eaf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589611c4b9f2efa9b323425b650eaf2f">&#9670;&nbsp;</a></span>AddBinaryOpOptimizations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddBinaryOpOptimizations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a281fefd51a6dbcc32be53ea22e708375">BinaryOpOptimizationsTableEntry</a>(&amp;)&#160;</td>
          <td class="paramname"><em>table</em>[TCapacity], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lhsOrRhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Templated helper method. Deduces the array size of the given table and passes it to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a5199aaeff72d584296a5211530b8eefc">AddBinaryOpOptimizations(BinaryOpOptimizationsTableEntry*, size_t, bool)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
    <tr><td class="paramname">lhsOrRhs</td><td>If <code>false</code>, the entries passed go into table <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa245c95cee592e1090a088984941e4b6">BinaryOpConstLHSOptimizations</a> which provides information about optimizations if the lhs-operand is constant. If <code>true</code>, table <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3107055a490e640f0580570a4ef82767">BinaryOpConstRHSOptimizations</a> is chosen, which provides information about optimizations if the rhs-operand is constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCapacity</td><td>Implicitly deferred size of the array provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5199aaeff72d584296a5211530b8eefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5199aaeff72d584296a5211530b8eefc">&#9670;&nbsp;</a></span>AddBinaryOpOptimizations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddBinaryOpOptimizations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a281fefd51a6dbcc32be53ea22e708375">BinaryOpOptimizationsTableEntry</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lhsOrRhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Loads all entries of the given table into nested map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa245c95cee592e1090a088984941e4b6">BinaryOpConstLHSOptimizations</a> respectively BinaryOpConstRHSOptimizations.</p>
<p>Note, that usually, the given table is a constexpr array located in an anonymous namespace of a compilation unit.<br />
 It can be passed as a reference to templated helper method, which defers the length of the table implicitly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
    <tr><td class="paramname">length</td><td>The table containing operator compilation information. </td></tr>
    <tr><td class="paramname">lhsOrRhs</td><td>If <code>false</code>, the entries passed go into table <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa245c95cee592e1090a088984941e4b6">BinaryOpConstLHSOptimizations</a> which provides information about optimizations if the lhs-operand is constant. If <code>true</code>, table <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3107055a490e640f0580570a4ef82767">BinaryOpConstRHSOptimizations</a> is chosen, which provides information about optimizations if the rhs-operand is constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb762d501655b7cc2b74fc9b0d051b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb762d501655b7cc2b74fc9b0d051b37">&#9670;&nbsp;</a></span>AddBinaryOps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddBinaryOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">BinaryOpTableEntry</a>(&amp;)&#160;</td>
          <td class="paramname"><em>table</em>[TCapacity]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Templated helper method. Deduces the array size of the given table and passes it to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a962376ee94cff37a8e5ae810b89d1788">AddBinaryOps(BinaryOpTableEntry* table, size_t length)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCapacity</td><td>Implicitly deferred size of the array provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a962376ee94cff37a8e5ae810b89d1788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962376ee94cff37a8e5ae810b89d1788">&#9670;&nbsp;</a></span>AddBinaryOps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddBinaryOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a0cf27e1bce1168bcdbd913d38678c69d">BinaryOpTableEntry</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Loads all entries of the given table into nested map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a>.</p>
<p>Note, that usually, the given table is a constexpr array located in an anonymous namespace of a compilation unit.<br />
 It can be passed as a reference to templated helper method, which defers the length of the table implicitly.</p>
<dl class="section note"><dt>Note</dt><dd>It is slightly more performant and causes less memory fragmentation, if the given table is sorted by the operator column (first) and as a second order by the <span>lhsType</span> column (second).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
    <tr><td class="paramname">length</td><td>The table containing operator compilation information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab984cd5eb3d1267ad057e701af4dcc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984cd5eb3d1267ad057e701af4dcc56">&#9670;&nbsp;</a></span>AddUnaryOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddUnaryOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>&#160;</td>
          <td class="paramname"><em>argType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackTypes::Unary&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dbgCallbackName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a>&#160;</td>
          <td class="paramname"><em>cti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Adds an unary operator's callback function and return type to the compilation map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a>. </p><dl class="section see"><dt>See also</dt><dd>Consider using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a9b441eb6aa16bee58b41189071139a3a">AddUnaryOps</a>, a variant of this method that allows effective bulk loading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operator. </td></tr>
    <tr><td class="paramname">argType</td><td>The argument type that the operator is defined for. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function to execute. </td></tr>
    <tr><td class="paramname">dbgCallbackName</td><td>The name of the C++ name of the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This parameter is available only in debug version of the library. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cti</td><td>See <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> for the meaning of this flag. </td></tr>
    <tr><td class="paramname">resultType</td><td>The result type of the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8ccbbf281a8ef90c59a549f27bd8e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ccbbf281a8ef90c59a549f27bd8e05">&#9670;&nbsp;</a></span>AddUnaryOpAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddUnaryOpAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a6440e699eaabf1d1353221727a656a91">Type</a>&#160;</td>
          <td class="paramname"><em>argType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Adds an alias operator to nested hash table <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a>. </p><dl class="section see"><dt>See also</dt><dd>Consider using <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#ae193651ef315f1cf1143e54ecb18b890">AddUnaryOpAliases</a>, a variant of this method that allows effective bulk loading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias for operator <span>op</span>. </td></tr>
    <tr><td class="paramname">argType</td><td>The argument type that the operator is defined for. </td></tr>
    <tr><td class="paramname">op</td><td>The operator aliased by <span>alias</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae193651ef315f1cf1143e54ecb18b890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae193651ef315f1cf1143e54ecb18b890">&#9670;&nbsp;</a></span>AddUnaryOpAliases() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddUnaryOpAliases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa8ba776f87c79538751cd5b6c5ecd7da">UnaryOpAliasTableEntry</a>(&amp;)&#160;</td>
          <td class="paramname"><em>table</em>[TCapacity]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Templated helper method. Deduces the array size of the given table and passes it to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa233330f8d2c43320a63215dfededfd0">AddUnaryOpAliases(UnaryOpAliasTableEntry* table, size_t length)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCapacity</td><td>Implicitly deferred size of the array provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa233330f8d2c43320a63215dfededfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa233330f8d2c43320a63215dfededfd0">&#9670;&nbsp;</a></span>AddUnaryOpAliases() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddUnaryOpAliases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa8ba776f87c79538751cd5b6c5ecd7da">UnaryOpAliasTableEntry</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Loads all entries of the given table into nested map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a>.</p>
<p>Note, that usually, the given table is a constexpr array located in an anonymous namespace of a compilation unit.<br />
 It can be passed as a reference to templated helper method, which defers the length of the table implicitly.</p>
<dl class="section note"><dt>Note</dt><dd>It is slightly more performant and causes less memory fragmentation, if the given table is sorted by the operator (first) column.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
    <tr><td class="paramname">length</td><td>The table containing operator compilation information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b441eb6aa16bee58b41189071139a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b441eb6aa16bee58b41189071139a3a">&#9670;&nbsp;</a></span>AddUnaryOps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddUnaryOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a50a3b92edb8db6f058f7a13c1a066b1c">UnaryOpTableEntry</a>(&amp;)&#160;</td>
          <td class="paramname"><em>table</em>[TCapacity]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Templated helper method. Deduces the array size of the given table and passes it to <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a02a927739182e13b232cc4a3a71d52a8">AddUnaryOps(UnaryOpTableEntry* table, size_t length)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCapacity</td><td>Implicitly deferred size of the array provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02a927739182e13b232cc4a3a71d52a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a927739182e13b232cc4a3a71d52a8">&#9670;&nbsp;</a></span>AddUnaryOps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddUnaryOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a50a3b92edb8db6f058f7a13c1a066b1c">UnaryOpTableEntry</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Loads all entries of the given table into nested map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a>.</p>
<p>Note, that usually, the given table is a constexpr array located in an anonymous namespace of a compilation unit.<br />
 It can be passed as a reference to templated helper method, which defers the length of the table implicitly.</p>
<dl class="section note"><dt>Note</dt><dd>It is slightly more performant and causes less memory fragmentation, if the given table is sorted by the operator (first) column.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table containing operator compilation information. </td></tr>
    <tr><td class="paramname">length</td><td>The table containing operator compilation information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a098fc2b68c8d9a17aeaa2dd8dff31e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098fc2b68c8d9a17aeaa2dd8dff31e75">&#9670;&nbsp;</a></span>TryCompilation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TryCompilation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html">CIFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>ciFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches in vectors <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a7058d524e02a12c3c4a4a40e60415136" title="List of functions to be compiled by this plug-in. ">Functions</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a12b81e575790db8c949079e707fe1244" title="List of identifiers that return constant values to be compiled by this plug-in. ">ConstantIdentifiers</a> for an entry matching <span>name</span> and, if found, adds either a constant value or a callback function to <span>program</span>.</p>
<p>This plug-in corrects abbreviated and letter case differences in functions within in/out parameter <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIFunction.html#afe755384d6ef50944e770bc6aad27a2d">CIFunction::Name</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ciFunction</td><td>The compilation result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an entry was found in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a7058d524e02a12c3c4a4a40e60415136" title="List of functions to be compiled by this plug-in. ">Functions</a> and a corresponding command was added to <span>program</span>. <code>false</code> otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#af04a6f83b4d51fa8217ce2760791b18b">CompilerPlugin</a>.</p>

<p>Reimplemented in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html#a0baab3c8d1b98a03b3fe8250e1f3826d">Strings</a>, and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Arithmetics.html#a0baab3c8d1b98a03b3fe8250e1f3826d">Arithmetics</a>.</p>

</div>
</div>
<a id="ace3350452fbcb2317e43b2e2406c36f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3350452fbcb2317e43b2e2406c36f6">&#9670;&nbsp;</a></span>TryCompilation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TryCompilation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIUnaryOp.html">CIUnaryOp</a> &amp;&#160;</td>
          <td class="paramname"><em>ciUnaryOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a> for an entry matching the combination of <span>operation</span> and <span>argType</span>. If found, the corresponding callback function and result type are added the <span>program</span>.</p>
<p>Before the search, it is checked whether the given <span>operation</span> is an alias for another operator. Operator aliases might be defined by filling map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a> in the constructor of the derived types. The corrected operator is returned in in/out parameter <span>operation</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ciUnaryOp</td><td>The compilation result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an entry was found in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a> and a corresponding command was added to <span>program</span>. <code>false</code> otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#ae59450a0da6fc0ab65b05b90b898ae22">CompilerPlugin</a>.</p>

</div>
</div>
<a id="a84c99402490968c29e27e6bcffc4ee40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c99402490968c29e27e6bcffc4ee40">&#9670;&nbsp;</a></span>TryCompilation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TryCompilation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryOp.html">CIBinaryOp</a> &amp;&#160;</td>
          <td class="paramname"><em>ciBinaryOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a> for an entry matching the combination of <span>operation</span>, <span>lhsType</span> and <span>rhsType</span>. If found, the corresponding callback function and result type are added the <span>program</span>.</p>
<p>Before the search, it is checked whether the given <span>operation</span> is an alias for another operator. Operator aliases might be defined by filling map <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a> in the constructor of the derived types. The corrected operator is returned in in/out parameter <span>operation</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ciBinaryOp</td><td>The compilation info struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an entry was found in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a> and a corresponding command was added to <span>program</span>. <code>false</code> otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a2a9d4673228b1e2c4c89c6467c490262">CompilerPlugin</a>.</p>

<p>Reimplemented in <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Strings.html#ac8c09be3ae1f55352b07969020595015">Strings</a>.</p>

</div>
</div>
<a id="a7de6da5b8e856b151433f4782a465373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de6da5b8e856b151433f4782a465373">&#9670;&nbsp;</a></span>TryCompilation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TryCompilation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin_1_1CIBinaryAutoCast.html">CIBinaryAutoCast</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Re-implementing virtual method of basic class, to allow derived types to override this. </p><dl class="section return"><dt>Returns</dt><dd>returns constant <code>false</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="structaworx_1_1lib_1_1expressions_1_1CompilerPlugin.html#a87336db1fa6d0310add5cd5c21190783">CompilerPlugin</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abc20034d3657fc4928136b507744c179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc20034d3657fc4928136b507744c179">&#9670;&nbsp;</a></span>BinaryOpAliases</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt;<a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt;<a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt;<a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&gt; &gt; &gt; BinaryOpAliases</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nested hash map assigning combinations of alias versions of binary operators and their the argument types to the original operator.</p>
<dl class="section note"><dt>Note</dt><dd>This nested map, the same as <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a> is to be filled using corresponding <em>add-methods</em>. Usually this is done in the constructor of derived classes. </dd></dl>

</div>
</div>
<a id="aa245c95cee592e1090a088984941e4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa245c95cee592e1090a088984941e4b6">&#9670;&nbsp;</a></span>BinaryOpConstLHSOptimizations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt;<a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt;<a class="el" href="namespaceaworx.html#a934e14062eb77d29860412391c841690">UnorderedBoxMap</a>&lt;<a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&gt; &gt; &gt; BinaryOpConstLHSOptimizations</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nested hash map assigning combinations of binary operators and left-hand side operator constants to optimization information.</p>
<p>This map is to be filled with <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a589611c4b9f2efa9b323425b650eaf2f">AddBinaryOpOptimizations</a>, which is usually done in the. constructor of derived classes. </p>

</div>
</div>
<a id="a3107055a490e640f0580570a4ef82767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3107055a490e640f0580570a4ef82767">&#9670;&nbsp;</a></span>BinaryOpConstRHSOptimizations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt;<a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt;<a class="el" href="namespaceaworx.html#a934e14062eb77d29860412391c841690">UnorderedBoxMap</a>&lt;<a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&gt; &gt; &gt; BinaryOpConstRHSOptimizations</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nested hash map assigning combinations of binary operators and right-hand side operator constants to optimization information.</p>
<p>This map is to be filled with <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a589611c4b9f2efa9b323425b650eaf2f">AddBinaryOpOptimizations</a>, which is usually done in the. constructor of derived classes. </p>

</div>
</div>
<a id="a033a0344c10e80fa7f3176bbb00251e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033a0344c10e80fa7f3176bbb00251e4">&#9670;&nbsp;</a></span>BinaryOpMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt;<a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt;<a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt;std::tuple&lt;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>, <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> , const char* &gt; &gt; &gt; &gt; BinaryOpMap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nested hash map assigning combinations of binary operators and its argument types to a tuple of n callback function and its return type.</p>
<p>A third member of type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> is to be set to <code>true</code>, if the callback function is allowed to be invoked on the <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a> object used at compile time. This scope object is of the same (eventually custom) type as the one for evaluation, however the evaluation-specific data is not set. In other words, the third tuple member denotes if during program compilation, constant input values might be evaluated right away.</p>
<p>A fourth tuple member of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">String</a> is available only in debug compilations and receives the name of the callback function.</p>
<dl class="section note"><dt>Note</dt><dd>This nested map, the same as <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a> is to be filled using corresponding <em>add-methods</em>. Usually this is done in the constructor of derived classes. </dd></dl>

</div>
</div>
<a id="aca7d895c9d90f88412d70322cc52a758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7d895c9d90f88412d70322cc52a758">&#9670;&nbsp;</a></span>CTI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> CTI = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used for values of <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> flags.<br />
 The use of this constant makes code more readable. </p>

</div>
</div>
<a id="a9dd3f41961ca66ba27a5c43747458b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd3f41961ca66ba27a5c43747458b67">&#9670;&nbsp;</a></span>ETI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> ETI = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used for values of <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> flags to denote that a callback function is only invokable at evaluation-time.<br />
 The use of this constant makes code more readable. </p>

</div>
</div>
<a id="aa71e0f4571d9018e32ffe4d5b9333a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71e0f4571d9018e32ffe4d5b9333a61">&#9670;&nbsp;</a></span>UnaryOpAliases</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt;<a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt;<a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&gt; &gt; UnaryOpAliases</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nested hash map assigning combinations of alias versions of unary operators and their the argument type to the original operator.</p>
<dl class="section note"><dt>Note</dt><dd>This nested map, the same as <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a3888e8792f7083550cce0c47ad1a949a">UnaryOpMap</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a> is to be filled using corresponding <em>add-methods</em>. Usually this is done in the constructor of derived classes. </dd></dl>

</div>
</div>
<a id="a3888e8792f7083550cce0c47ad1a949a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3888e8792f7083550cce0c47ad1a949a">&#9670;&nbsp;</a></span>UnaryOpMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#ae19a3a37e8110ed78a93a420ceb5d74d">UnorderedStringMap</a>&lt;<a class="el" href="namespaceaworx.html#ac6a830d17aea9f0c590128b88affdc5a">TypeMap</a>&lt;std::tuple&lt;<a class="el" href="namespaceaworx_1_1lib_1_1expressions.html#a84930fc6785d99ed8a3240026868e3a1">CallbackDecl</a>, <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> , const char* &gt; &gt; &gt; UnaryOpMap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nested hash map assigning combinations of unary operators and argument type to a tuple of an evaluation function and a return type.</p>
<p>A third member of type <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#af55b508702600cd59382f1623a5ca53c">CTInvokable</a> is to be set to <code>true</code>, if the callback function is allowed to be invoked on the <a class="el" href="structaworx_1_1lib_1_1expressions_1_1Scope.html">Scope</a> object used at compile time. This scope object is of the same (eventually custom) type as the one for evaluation, however the evaluation-specific data is not set. In other words, the third tuple member denotes if during program compilation, constant input values might be evaluated right away.</p>
<p>A fourth tuple member of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">String</a> is available only in debug compilations and receives the name of the callback function.</p>
<dl class="section note"><dt>Note</dt><dd>This nested map, the same as <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#aa71e0f4571d9018e32ffe4d5b9333a61">UnaryOpAliases</a>, <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#a033a0344c10e80fa7f3176bbb00251e4">BinaryOpMap</a> and <a class="el" href="structaworx_1_1lib_1_1expressions_1_1plugins_1_1Calculus.html#abc20034d3657fc4928136b507744c179">BinaryOpAliases</a> is to be filled using corresponding <em>add-methods</em>. Usually this is done in the constructor of derived classes. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="calculus_8hpp_source.html">calculus.hpp</a></li>
<li>calculus.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 12 2018 15:57:47 for ALib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
