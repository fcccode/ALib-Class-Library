<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALib: PropertyFormatter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALib
   &#160;<span id="projectnumber">V. 1805 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html">strings</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1format.html">format</a></li><li class="navelem"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html">PropertyFormatter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-attribs">Public Fields</a> &#124;
<a href="#pub-methods">Public Methods</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Fields</a> &#124;
<a href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PropertyFormatter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="propertyformatter_8hpp_source.html">propertyformatter.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for PropertyFormatter:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter__coll__graph.svg" width="571" height="307"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
 <h1><a class="anchor" id="alib_namespace_strings_propertyformatter_overview"></a>
Introduction</h1>
<p>This class can be used to offer customized format strings to end users. For this, the format string definition of <b>ALib</b> <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterBase.html">Formatter</a> types is extended to support identifiers, which act as placeholders for object values. The identifiers placed in the string have to match to the normal formatting placeholders in respect to their total number and value type.</p>
<p>In the constructor of this class, a custom format string which is based on standard <b>ALib</b> format strings is passed. This string is processed as follows:</p><ul>
<li>all custom identifiers are removed</li>
<li>for each identifier found, a reference to an associated callback function is stored.</li>
</ul>
<p>Hence, the translation of the custom format string into <b>ALib</b> formatter strings and the selection of the callback functions is done only once.</p>
<p>The only interface method <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7b029f99f6c34163db2b596865110439">Format</a> then accepts a target string object and a <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">boxed object</a> of custom type.</p>
<p>A vector of tuples is defined and needs to be passed to the constructor of this class. The first element of each tuple contains the <em>'identifier'</em> string which is removed from the format string if found. The second element contains a callback function used to retrieve the data when the identifier is found in the format string.</p>
<p>The whole approach is useful in cases where an application wants to allow a customizable output format of data objects.</p>
<h1><a class="anchor" id="alib_namespace_strings_propertyformatter_sample"></a>
Sample</h1>
<p>Let us assume, an application uses an enumeration and a simple struct: </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> Hobbies</div><div class="line">{</div><div class="line">    Hacking,</div><div class="line">    FineArts,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct  </span>Person</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>        Name;</div><div class="line">    <span class="keywordtype">int</span>           Age;</div><div class="line">    Hobbies       Hobby;</div><div class="line">};</div></div><!-- fragment --><p> In the application's configuration file, a custom output format for objects of type <b>Person</b> should be user defined. We document to the user that he can use Python-style or Java-style output formats - extended by the ability to place the following three identifiers in the string:</p><ul>
<li>@name</li>
<li>@age</li>
<li>@hobby.</li>
</ul>
<p>A possible format string then would be: </p><pre class="fragment">     "{@name} is aged {@age} and his/her hobby is {@hobby}"
</pre><p>To tell this class how to retrieve the replacement values, we need to define three callback functions: </p><div class="fragment"><div class="line"><span class="keyword">namespace</span></div><div class="line">{</div><div class="line">    <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getName  ( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; p, <a class="code" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a>&amp;  ) { <span class="keywordflow">return</span>  p.Unbox&lt;Person*&gt;()-&gt;Name;  }</div><div class="line">    <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getAge   ( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; p, <a class="code" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a>&amp;  ) { <span class="keywordflow">return</span>  p.Unbox&lt;Person*&gt;()-&gt;Age;   }</div><div class="line">    <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> getHobby ( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; p, <a class="code" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a>&amp;  ) { <span class="keywordflow">return</span>  p.Unbox&lt;Person*&gt;()-&gt;Hobby == Hobbies::Hacking</div><div class="line">                                                       ? <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;hacking&quot;</span>) : <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;fine arts&quot;</span>)  ;      }</div><div class="line">}</div></div><!-- fragment --><p> It is a good idea to place the callback functions in an anonymous (sub-) namespace as they are only referred to once (in the next step).<br />
 As this sample is very trivial, the second parameter <code>AString&amp;</code> is not used and named. Details on the purpose and use of this parameter is addressed <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#alib_namespace_strings_propertyformatter_callbacks">below</a>.</p>
<p>As a next step, these functions need to be collected together in a "translation table". The table primarily holds a string denoting the replacement identifier and a pointer to the corresponding callback function. For convenience, the table type is provided with <code>using</code> defintion <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ac1afadc6413a8b3bbf96543425cabd68" title="Type definition of the callback table. A simple vector of TCallbackTableEntry objects. ">TCallbackTable</a>.</p>
<p>In our sample, the definition of the table looks like this: </p><div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ac1afadc6413a8b3bbf96543425cabd68">PropertyFormatter::TCallbackTable</a>  PersonCallbacks=</div><div class="line">{</div><div class="line">      { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;name&quot;</span>)  , 1, getName  },</div><div class="line">      { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;age&quot;</span>)   , 1, getAge   },</div><div class="line">      { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;hobby&quot;</span>) , 1, getHobby },</div><div class="line">};</div></div><!-- fragment --><p> This is all we need! Of-course, an external declaration of our table <b>PersonCallbacks</b> should be placed somewhere in the projects' header file. With this, a code like this may now use the custom formatter strings: </p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">// Our data objects</span></div><div class="line">Person p1= { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;Sue&quot;</span>) , 28, Hobbies::Hacking };</div><div class="line">Person p2= { <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;John&quot;</span>), 35, Hobbies::Hacking };</div><div class="line"></div><div class="line"><span class="comment">// The format string. Make this changeable at runtime, e.g. load from INI-file!</span></div><div class="line"><a class="code" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> format= <a class="code" href="group__GrpALibMacros.html#ga071fd3336e2fab8c70950233a50aa397">ASTR</a>(<span class="stringliteral">&quot;{@name} is aged {@age} and his/her hobby is {@hobby}&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// create a formatter</span></div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html">aworx::PropertyFormatter</a>  propertyFormatter( format, PersonCallbacks  );</div><div class="line"></div><div class="line"><span class="comment">// format the two data objects</span></div><div class="line"><a class="code" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a> target;</div><div class="line">propertyFormatter.Format( target, p1 );</div><div class="line">target &lt;&lt; <a class="code" href="namespaceaworx.html#aee8505e9a58c815dc8f99ac8565439da">NewLine</a>;</div><div class="line">propertyFormatter.Format( target, p2 );</div><div class="line">target &lt;&lt; <a class="code" href="namespaceaworx.html#aee8505e9a58c815dc8f99ac8565439da">NewLine</a>;</div><div class="line"></div><div class="line"><span class="comment">// that&#39;s it!</span></div><div class="line">std::cout &lt;&lt; target;</div><div class="line"></div></div><!-- fragment --><p> Running the code above produces the following output: </p><div class="fragment"><div class="line">Sue is aged 28 and his/her hobby is hacking</div><div class="line">John is aged 35 and his/her hobby is hacking</div></div><!-- fragment --><p> Serializing objects in a custom format (e.g. a user could define its own <b>JSon</b> object output) should be the most obvious and frequent use case. And this is what the classes name suggests. Nevertheless, the callback methods might be more complex than just returning "properties" of objects. The next sections gives more details on the custom callbacks.</p>
<h1><a class="anchor" id="alib_namespace_strings_propertyformatter_callbacks"></a>
Callback Functions</h1>
<p>The call back function's signature is defined with <code>using</code> definition <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7bcc66aeadceb0b42951b7f4f772bd94">TCallback</a> which evaluates to </p><pre class="fragment">           Box (*)(const Box&amp;, AString&amp;)
</pre><p>The return type is <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>, which allows the callback function to return objects of arbitrary type, respectively all types that received support with <b>ALib</b> formatters.</p>
<p>The first input parameter provides the data object passed to method <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7b029f99f6c34163db2b596865110439">Format</a>. If the callback functions are dedicated to a property formatter that receives a certain object type (what they usually are), the custom type can be straightly unboxed.</p>
<p>The second parameter is an <b>AString</b> object which optionally can be used to assemble string objects in more complex callback methods. Note, that if this string is not empty after the callback invocation, the result is copied to a string buffer allocated in the heap memory. In this case, the box object returned by the callback is ignored and instead the copy of the string is passed to the formatter. If C++ string constants (e.g <code>"true"</code> are to be returned by the callbacks, those constants do not need to be copied to the buffer, as their memory is statically allocated. In other words, the <b>AString</b> buffer provided in the second parameter is needed to be used only in cases that a string gets assembled in the callback function!</p>
<h1><a class="anchor" id="alib_namespace_strings_propertyformatter_escape"></a>
Identifiers And The Escape Character '@'</h1>
<p>The escape character used to find custom identifiers in the format string is defined with member <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ac55e24508386d5c8686ec973ce78495c">ESCCharacter</a> and defaults to <b>'@'</b>. This escape character is searched in the format string. If found, the identifier is read by consuming alphabetic characters. If a 'closing' second occurrence of <b>'@'</b> is found while the identifier is parsed, then this character gets eliminated from the custom format string as well. Hence, the two format strings </p><pre class="fragment">     "{@name}"
     "{@name@}"
</pre><p> are both valid and equal.<br />
</p>
<p>In case of <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterPythonStyleBase.html">FormatterPythonStyle</a> format strings, it is a good idea to place the identifier right inside the brackets. It just looks very intuitive. However, these versions: </p><pre class="fragment">     "@name{}"
     "{}@name"
</pre><p> are also valid custom format strings.</p>
<p>In case of <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1FormatterJavaStyleBase.html">FormatterJavaStyle</a>, which uses <b>'%'</b> as its escape character, we consider the best option to put the custom identifier in front of each <b>'%'</b> symbol. The string of the example given above would then look like this: </p><pre class="fragment">     "@name%s is aged @age%d and his/her hobby is @hobby%s"
</pre><p> Doing it this way, the <b>'%'</b> symbol acts as a very natural delimiter for the custom identifier.</p>
<p>As a final note, with the second element of tuple <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#aa58330f4b28f399d6a471177daaedb01">TCallbackTableEntry</a>, it is possible to allow abbreviations of identifier names. This column denotes the minimum number of characters to be matched. As in the above sample a value of <code>1</code> is provided, each identifier of the custom format string can be abbreviated down to one character. Consequently the following format string samples are all equal and allowed: </p><pre class="fragment">     "{@name}"
     "{@nam}"
     "{@na}"
     "{@n}"
</pre> <h1>Reference Documentation</h1>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1format.html#a8d828d7f6e0c02a7815c7e1308d3b06ea8f0d58f2db3173f82663f74b4152f063">aworx::lib::strings::format::Exceptions::UnknownPropertyInFormatString</a></td><td></td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7bcc66aeadceb0b42951b7f4f772bd94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7bcc66aeadceb0b42951b7f4f772bd94">TCallback</a> = <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>(*)(const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> &amp;, <a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a> &amp;)</td></tr>
<tr class="separator:a7bcc66aeadceb0b42951b7f4f772bd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1afadc6413a8b3bbf96543425cabd68"><td class="memItemLeft" align="right" valign="top"><a id="ac1afadc6413a8b3bbf96543425cabd68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ac1afadc6413a8b3bbf96543425cabd68">TCallbackTable</a> = std::vector&lt; <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#aa58330f4b28f399d6a471177daaedb01">TCallbackTableEntry</a> &gt;</td></tr>
<tr class="memdesc:ac1afadc6413a8b3bbf96543425cabd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition of the callback table. A simple vector of <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#aa58330f4b28f399d6a471177daaedb01">TCallbackTableEntry</a> objects. <br /></td></tr>
<tr class="separator:ac1afadc6413a8b3bbf96543425cabd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58330f4b28f399d6a471177daaedb01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#aa58330f4b28f399d6a471177daaedb01">TCallbackTableEntry</a> = std::tuple&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, int, <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7bcc66aeadceb0b42951b7f4f772bd94">TCallback</a> &gt;</td></tr>
<tr class="separator:aa58330f4b28f399d6a471177daaedb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Fields</h2></td></tr>
<tr class="memitem:ac55e24508386d5c8686ec973ce78495c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">character</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ac55e24508386d5c8686ec973ce78495c">ESCCharacter</a> = '@'</td></tr>
<tr class="separator:ac55e24508386d5c8686ec973ce78495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ea90081bf7a05402df817b08b086e6"><td class="memItemLeft" align="right" valign="top"><a id="ae6ea90081bf7a05402df817b08b086e6"></a>
<a class="el" href="namespaceaworx.html#a165c16cef7a2da498d4de43c488f78a5">SPFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ae6ea90081bf7a05402df817b08b086e6">stdFormatter</a></td></tr>
<tr class="memdesc:ae6ea90081bf7a05402df817b08b086e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resulting format string passed to <b>ALib</b> formatters. <br /></td></tr>
<tr class="separator:ae6ea90081bf7a05402df817b08b086e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr class="memitem:a19559ca6b45ea195c447ab233e9f43c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a19559ca6b45ea195c447ab233e9f43c7">PropertyFormatter</a> (const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a> customFormatString, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ac1afadc6413a8b3bbf96543425cabd68">TCallbackTable</a> &amp;propertyTable, <a class="el" href="namespaceaworx.html#a165c16cef7a2da498d4de43c488f78a5">SPFormatter</a> formatter=nullptr)</td></tr>
<tr class="separator:a19559ca6b45ea195c447ab233e9f43c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b029f99f6c34163db2b596865110439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7b029f99f6c34163db2b596865110439">Format</a> (<a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a> &amp;target, const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> &amp;src)</td></tr>
<tr class="separator:a7b029f99f6c34163db2b596865110439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ae2f43583c0d4aa1d4be57b741fb8e2fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ae2f43583c0d4aa1d4be57b741fb8e2fd">TCallbackResultTable</a> = std::vector&lt; const <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#aa58330f4b28f399d6a471177daaedb01">TCallbackTableEntry</a> * &gt;</td></tr>
<tr class="separator:ae2f43583c0d4aa1d4be57b741fb8e2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Fields</h2></td></tr>
<tr class="memitem:ae3daf3750096d91e4fe693ae286ccdc2"><td class="memItemLeft" align="right" valign="top"><a id="ae3daf3750096d91e4fe693ae286ccdc2"></a>
<a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ae2f43583c0d4aa1d4be57b741fb8e2fd">TCallbackResultTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ae3daf3750096d91e4fe693ae286ccdc2">callBacks</a></td></tr>
<tr class="memdesc:ae3daf3750096d91e4fe693ae286ccdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback functions to receive the format data. <br /></td></tr>
<tr class="separator:ae3daf3750096d91e4fe693ae286ccdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c51abb0f4a3f3140bd1c77e0614e65"><td class="memItemLeft" align="right" valign="top"><a id="a14c51abb0f4a3f3140bd1c77e0614e65"></a>
<a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a14c51abb0f4a3f3140bd1c77e0614e65">formatString</a></td></tr>
<tr class="memdesc:a14c51abb0f4a3f3140bd1c77e0614e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resulting format string passed to <b>ALib</b> formatters. <br /></td></tr>
<tr class="separator:a14c51abb0f4a3f3140bd1c77e0614e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c37804df1649a5be1408ef1f9f5510"><td class="memItemLeft" align="right" valign="top"><a id="a89c37804df1649a5be1408ef1f9f5510"></a>
<a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a89c37804df1649a5be1408ef1f9f5510">propertyFormatString</a></td></tr>
<tr class="memdesc:a89c37804df1649a5be1408ef1f9f5510"><td class="mdescLeft">&#160;</td><td class="mdescRight">The original format string. Used only for exception information. <br /></td></tr>
<tr class="separator:a89c37804df1649a5be1408ef1f9f5510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aa27248b266384f5ad04392c0b522e"><td class="memItemLeft" align="right" valign="top"><a id="ad5aa27248b266384f5ad04392c0b522e"></a>
<a class="el" href="namespaceaworx.html#a13da4402eea5d25b5fbddc19c3605e22">Boxes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ad5aa27248b266384f5ad04392c0b522e">results</a></td></tr>
<tr class="memdesc:ad5aa27248b266384f5ad04392c0b522e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boxed results of the callbacks (reused container) <br /></td></tr>
<tr class="separator:ad5aa27248b266384f5ad04392c0b522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7bcc66aeadceb0b42951b7f4f772bd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcc66aeadceb0b42951b7f4f772bd94">&#9670;&nbsp;</a></span>TCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7bcc66aeadceb0b42951b7f4f772bd94">TCallback</a> =  <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> (*)(const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp;, <a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a>&amp;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The signature of the callback functions. See <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#alib_namespace_strings_propertyformatter_callbacks">Callback Functions</a> for more information. </p>

</div>
</div>
<a id="ae2f43583c0d4aa1d4be57b741fb8e2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f43583c0d4aa1d4be57b741fb8e2fd">&#9670;&nbsp;</a></span>TCallbackResultTable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ae2f43583c0d4aa1d4be57b741fb8e2fd">TCallbackResultTable</a> =  std::vector&lt;const <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#aa58330f4b28f399d6a471177daaedb01">TCallbackTableEntry</a>*&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal type definition for the list of callback table entries collected in the constructor by parsing the extended format string. </p>

</div>
</div>
<a id="aa58330f4b28f399d6a471177daaedb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58330f4b28f399d6a471177daaedb01">&#9670;&nbsp;</a></span>TCallbackTableEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#aa58330f4b28f399d6a471177daaedb01">TCallbackTableEntry</a> =  std::tuple&lt; <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>, int, <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7bcc66aeadceb0b42951b7f4f772bd94">TCallback</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The entry type expected/used in the translation table. The entries are tuples with the following elements:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><center>Idx</center>  </th><th class="markdownTableHeadNone"><center>type</center>  </th><th class="markdownTableHeadNone"><center>Description</center><ul>
<li>- - - -   </li>
</ul>
</th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringBase.html">String</a>  </td><td class="markdownTableBodyNone">The identifier string   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone"><code>int</code>  </td><td class="markdownTableBodyNone">The minimum characters of the identifier to read in the format string. If less or equal to zero, abbreviations are not allowed)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7bcc66aeadceb0b42951b7f4f772bd94">TCallback</a>  </td><td class="markdownTableBodyNone">The callback function for this identifier. See <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#alib_namespace_strings_propertyformatter_callbacks">Callback Functions</a>   </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a19559ca6b45ea195c447ab233e9f43c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19559ca6b45ea195c447ab233e9f43c7">&#9670;&nbsp;</a></span>PropertyFormatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html">PropertyFormatter</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#a7de040be7805ead78a8adcc918c9012b">String</a>&#160;</td>
          <td class="paramname"><em>customFormatString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#ac1afadc6413a8b3bbf96543425cabd68">TCallbackTable</a> &amp;&#160;</td>
          <td class="paramname"><em>propertyTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a165c16cef7a2da498d4de43c488f78a5">SPFormatter</a>&#160;</td>
          <td class="paramname"><em>formatter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Processes the given format string and builds internal structures to be able to quickly process invocations of method <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1PropertyFormatter.html#a7b029f99f6c34163db2b596865110439">Format</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customFormatString</td><td>The format string as described in the class documentation. </td></tr>
    <tr><td class="paramname">propertyTable</td><td>Table with property identifier names and callback functions to retrieve the property values. </td></tr>
    <tr><td class="paramname">formatter</td><td>The formatter to use. Defaults to <code>nullptr</code> which selects <b>ALib</b> <a class="el" href="classaworx_1_1lib_1_1strings_1_1Strings.html#a24edb26b4d3f4233922804d003397ee3">default formatter</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1format.html#a8d828d7f6e0c02a7815c7e1308d3b06ea8f0d58f2db3173f82663f74b4152f063">aworx::lib::strings::format::Exceptions::UnknownPropertyInFormatString</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7b029f99f6c34163db2b596865110439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b029f99f6c34163db2b596865110439">&#9670;&nbsp;</a></span>Format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceaworx.html#a1560a557676f73ac8ce95f0f192a6957">Format</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a97d89c97e084400c205acd8103539f61">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the formatted output of the properties of the given <span>TFormattable</span> object to a given target string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target string to write into. </td></tr>
    <tr><td class="paramname">src</td><td>The custom object which is passed to the callback methods to collect the formatter arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac55e24508386d5c8686ec973ce78495c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55e24508386d5c8686ec973ce78495c">&#9670;&nbsp;</a></span>ESCCharacter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a7491da138b073b28da05b09c730fe608">character</a> ESCCharacter = '@'</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The prefix used to search identifiers in the user defined format string. Defaults Defaults to <code>'@'</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="propertyformatter_8hpp_source.html">propertyformatter.hpp</a></li>
<li>propertyformatter.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 12 2018 15:57:48 for ALib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
